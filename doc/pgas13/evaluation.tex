\section{Evaluation}
To evaluate the impact flat combining has on the global data structures, we ran a series of experiments to test the raw performance of the data structures themselves under different workloads, and further measured their impact on performance of two simple graph benchmarks.

\subsection{Data Structure Throughput}
First we measured the performance of the global data structures on extremely simple workloads to understand their raw performance.

\begin{figure*}[t]
  \centering
  \begin{subfigure}[b]{0.45\textwidth}
  \centering
  \includegraphics[width=\textwidth]{data/plots/stack_perf.pdf}
  \caption{Stack performance.}
  \label{fig:stack}
  \end{subfigure}%
  \hspace{0.05\textwidth}
  % ~ %add desired spacing between images, e. g. ~, \quad, \qquad etc.
  %(or a blank line to force the subfigure onto a new line)
  \begin{subfigure}[b]{0.45\textwidth}
  \centering
  \includegraphics[width=\textwidth]{data/plots/queue_perf.pdf}
  \caption{Queue performance.}
  \label{fig:queue}
  \end{subfigure}
  
  \begin{subfigure}[b]{0.45\textwidth}
  \centering
  \includegraphics[width=\textwidth]{data/plots/hashset_perf.pdf}
  \caption{GlobalHashSet performance.}
  \label{fig:hashset}
  \end{subfigure}
  %
  \hspace{0.05\textwidth}
  %
  \begin{subfigure}[b]{0.45\textwidth}
  \centering
  \includegraphics[width=\textwidth]{data/plots/hashmap_perf.pdf}
  \caption{GlobalHashMap performance.}
  \label{fig:hashmap}
  \end{subfigure}%
  %
  \caption{Raw performance of global data structures.
    \TODO{describe results.}
    \TODO{either all with error bars or none.}
  }\label{fig:datastructs}
\end{figure*}

\paragraph{Queue and Stack}
The GlobalQueue and GlobalStack have very similar implementations in terms of how they are synchronized. Both benefit greatly from flat combining. This is because only one round-trip message 

However, due to the nature of concurrent stacks, the stack is able to match up pushes and pops locally. This leads to performance on an even mix of pushes and pops far outstripping the case where all pushes are performed due to requiring vastly less communication.

\paragraph{HashSet and HashMap}
The GlobalHashSet and GlobalHashMap have the same synchronization strategy (serialization happens at each hashed location).

\subsection{Application Kernel Performance}
The impetus for this work was that naive implementations of standard data structures are insufficient for use in high-performance kernels.

\paragraph{Breadth-First Search}
\begin{figure}[t]
  \centering
  \includegraphics[width=0.5\textwidth]{data/plots/bfs_perf.pdf}
  \caption{BFS on a Graph500-spec graph of scale 26 (64 million vertices, 1 billion edges), with the direction-optimizing BFS algorithm. Performance is shown in millions of Traversed Edges Per Second (MTEPS).}
  \label{fig:bfs_perf}
\end{figure}


\paragraph{Connected Components}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.5\textwidth]{data/plots/cc_perf.pdf}
  \caption{Connected Components on the same scale 26 Graph500 graph. Performance is measured in TEPS, parameterized only by the total number of edges in the graph, regardless of the algorithm used.}
  \label{fig:cc_perf}
\end{figure}

