// WARNING!  This file was automatically generated by macexp.
//           Do not edit this file, any changes made will be lost.

`celldefine

// macexp DFF 5
// macexp $size 48
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_48 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_48 "true";
	input clk;
	input [47:0] d;
	output [47:0] q;
	reg [47:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp MUX8 12
// macexp $size 115
// macexp $instance
// macexp s
// macexp i0
// macexp i1
// macexp i2
// macexp i3
// macexp i4
// macexp i5
// macexp i6
// macexp i7
// macexp o

module mux8_115 ( s, i0, i1, i2, i3, i4, i5, i6, i7, o );
	// synthesis attribute keep_hierarchy mux8_115 "true";
	input  [2:0] s;
	input  [114:0] i0, i1, i2, i3, i4, i5, i6, i7;
	output [114:0] o;
	wire [7:0] in0;
	wire [7:0] in1;
	wire [7:0] in2;
	wire [7:0] in3;
	wire [7:0] in4;
	wire [7:0] in5;
	wire [7:0] in6;
	wire [7:0] in7;
	wire [7:0] in8;
	wire [7:0] in9;
	wire [7:0] in10;
	wire [7:0] in11;
	wire [7:0] in12;
	wire [7:0] in13;
	wire [7:0] in14;
	wire [7:0] in15;
	wire [7:0] in16;
	wire [7:0] in17;
	wire [7:0] in18;
	wire [7:0] in19;
	wire [7:0] in20;
	wire [7:0] in21;
	wire [7:0] in22;
	wire [7:0] in23;
	wire [7:0] in24;
	wire [7:0] in25;
	wire [7:0] in26;
	wire [7:0] in27;
	wire [7:0] in28;
	wire [7:0] in29;
	wire [7:0] in30;
	wire [7:0] in31;
	wire [7:0] in32;
	wire [7:0] in33;
	wire [7:0] in34;
	wire [7:0] in35;
	wire [7:0] in36;
	wire [7:0] in37;
	wire [7:0] in38;
	wire [7:0] in39;
	wire [7:0] in40;
	wire [7:0] in41;
	wire [7:0] in42;
	wire [7:0] in43;
	wire [7:0] in44;
	wire [7:0] in45;
	wire [7:0] in46;
	wire [7:0] in47;
	wire [7:0] in48;
	wire [7:0] in49;
	wire [7:0] in50;
	wire [7:0] in51;
	wire [7:0] in52;
	wire [7:0] in53;
	wire [7:0] in54;
	wire [7:0] in55;
	wire [7:0] in56;
	wire [7:0] in57;
	wire [7:0] in58;
	wire [7:0] in59;
	wire [7:0] in60;
	wire [7:0] in61;
	wire [7:0] in62;
	wire [7:0] in63;
	wire [7:0] in64;
	wire [7:0] in65;
	wire [7:0] in66;
	wire [7:0] in67;
	wire [7:0] in68;
	wire [7:0] in69;
	wire [7:0] in70;
	wire [7:0] in71;
	wire [7:0] in72;
	wire [7:0] in73;
	wire [7:0] in74;
	wire [7:0] in75;
	wire [7:0] in76;
	wire [7:0] in77;
	wire [7:0] in78;
	wire [7:0] in79;
	wire [7:0] in80;
	wire [7:0] in81;
	wire [7:0] in82;
	wire [7:0] in83;
	wire [7:0] in84;
	wire [7:0] in85;
	wire [7:0] in86;
	wire [7:0] in87;
	wire [7:0] in88;
	wire [7:0] in89;
	wire [7:0] in90;
	wire [7:0] in91;
	wire [7:0] in92;
	wire [7:0] in93;
	wire [7:0] in94;
	wire [7:0] in95;
	wire [7:0] in96;
	wire [7:0] in97;
	wire [7:0] in98;
	wire [7:0] in99;
	wire [7:0] in100;
	wire [7:0] in101;
	wire [7:0] in102;
	wire [7:0] in103;
	wire [7:0] in104;
	wire [7:0] in105;
	wire [7:0] in106;
	wire [7:0] in107;
	wire [7:0] in108;
	wire [7:0] in109;
	wire [7:0] in110;
	wire [7:0] in111;
	wire [7:0] in112;
	wire [7:0] in113;
	wire [7:0] in114;
	assign in0[3:0] = {i3[0], i2[0], i1[0], i0[0]};
	assign in0[7:4] = {i7[0], i6[0], i5[0], i4[0]};
	assign in1[3:0] = {i3[1], i2[1], i1[1], i0[1]};
	assign in1[7:4] = {i7[1], i6[1], i5[1], i4[1]};
	mux8to1x2 m0 (.in0(in0), .sel0(s), .in1(in1), .sel1(s), .out(o[1:0]));
	assign in2[3:0] = {i3[2], i2[2], i1[2], i0[2]};
	assign in2[7:4] = {i7[2], i6[2], i5[2], i4[2]};
	assign in3[3:0] = {i3[3], i2[3], i1[3], i0[3]};
	assign in3[7:4] = {i7[3], i6[3], i5[3], i4[3]};
	mux8to1x2 m2 (.in0(in2), .sel0(s), .in1(in3), .sel1(s), .out(o[3:2]));
	assign in4[3:0] = {i3[4], i2[4], i1[4], i0[4]};
	assign in4[7:4] = {i7[4], i6[4], i5[4], i4[4]};
	assign in5[3:0] = {i3[5], i2[5], i1[5], i0[5]};
	assign in5[7:4] = {i7[5], i6[5], i5[5], i4[5]};
	mux8to1x2 m4 (.in0(in4), .sel0(s), .in1(in5), .sel1(s), .out(o[5:4]));
	assign in6[3:0] = {i3[6], i2[6], i1[6], i0[6]};
	assign in6[7:4] = {i7[6], i6[6], i5[6], i4[6]};
	assign in7[3:0] = {i3[7], i2[7], i1[7], i0[7]};
	assign in7[7:4] = {i7[7], i6[7], i5[7], i4[7]};
	mux8to1x2 m6 (.in0(in6), .sel0(s), .in1(in7), .sel1(s), .out(o[7:6]));
	assign in8[3:0] = {i3[8], i2[8], i1[8], i0[8]};
	assign in8[7:4] = {i7[8], i6[8], i5[8], i4[8]};
	assign in9[3:0] = {i3[9], i2[9], i1[9], i0[9]};
	assign in9[7:4] = {i7[9], i6[9], i5[9], i4[9]};
	mux8to1x2 m8 (.in0(in8), .sel0(s), .in1(in9), .sel1(s), .out(o[9:8]));
	assign in10[3:0] = {i3[10], i2[10], i1[10], i0[10]};
	assign in10[7:4] = {i7[10], i6[10], i5[10], i4[10]};
	assign in11[3:0] = {i3[11], i2[11], i1[11], i0[11]};
	assign in11[7:4] = {i7[11], i6[11], i5[11], i4[11]};
	mux8to1x2 m10 (.in0(in10), .sel0(s), .in1(in11), .sel1(s), .out(o[11:10]));
	assign in12[3:0] = {i3[12], i2[12], i1[12], i0[12]};
	assign in12[7:4] = {i7[12], i6[12], i5[12], i4[12]};
	assign in13[3:0] = {i3[13], i2[13], i1[13], i0[13]};
	assign in13[7:4] = {i7[13], i6[13], i5[13], i4[13]};
	mux8to1x2 m12 (.in0(in12), .sel0(s), .in1(in13), .sel1(s), .out(o[13:12]));
	assign in14[3:0] = {i3[14], i2[14], i1[14], i0[14]};
	assign in14[7:4] = {i7[14], i6[14], i5[14], i4[14]};
	assign in15[3:0] = {i3[15], i2[15], i1[15], i0[15]};
	assign in15[7:4] = {i7[15], i6[15], i5[15], i4[15]};
	mux8to1x2 m14 (.in0(in14), .sel0(s), .in1(in15), .sel1(s), .out(o[15:14]));
	assign in16[3:0] = {i3[16], i2[16], i1[16], i0[16]};
	assign in16[7:4] = {i7[16], i6[16], i5[16], i4[16]};
	assign in17[3:0] = {i3[17], i2[17], i1[17], i0[17]};
	assign in17[7:4] = {i7[17], i6[17], i5[17], i4[17]};
	mux8to1x2 m16 (.in0(in16), .sel0(s), .in1(in17), .sel1(s), .out(o[17:16]));
	assign in18[3:0] = {i3[18], i2[18], i1[18], i0[18]};
	assign in18[7:4] = {i7[18], i6[18], i5[18], i4[18]};
	assign in19[3:0] = {i3[19], i2[19], i1[19], i0[19]};
	assign in19[7:4] = {i7[19], i6[19], i5[19], i4[19]};
	mux8to1x2 m18 (.in0(in18), .sel0(s), .in1(in19), .sel1(s), .out(o[19:18]));
	assign in20[3:0] = {i3[20], i2[20], i1[20], i0[20]};
	assign in20[7:4] = {i7[20], i6[20], i5[20], i4[20]};
	assign in21[3:0] = {i3[21], i2[21], i1[21], i0[21]};
	assign in21[7:4] = {i7[21], i6[21], i5[21], i4[21]};
	mux8to1x2 m20 (.in0(in20), .sel0(s), .in1(in21), .sel1(s), .out(o[21:20]));
	assign in22[3:0] = {i3[22], i2[22], i1[22], i0[22]};
	assign in22[7:4] = {i7[22], i6[22], i5[22], i4[22]};
	assign in23[3:0] = {i3[23], i2[23], i1[23], i0[23]};
	assign in23[7:4] = {i7[23], i6[23], i5[23], i4[23]};
	mux8to1x2 m22 (.in0(in22), .sel0(s), .in1(in23), .sel1(s), .out(o[23:22]));
	assign in24[3:0] = {i3[24], i2[24], i1[24], i0[24]};
	assign in24[7:4] = {i7[24], i6[24], i5[24], i4[24]};
	assign in25[3:0] = {i3[25], i2[25], i1[25], i0[25]};
	assign in25[7:4] = {i7[25], i6[25], i5[25], i4[25]};
	mux8to1x2 m24 (.in0(in24), .sel0(s), .in1(in25), .sel1(s), .out(o[25:24]));
	assign in26[3:0] = {i3[26], i2[26], i1[26], i0[26]};
	assign in26[7:4] = {i7[26], i6[26], i5[26], i4[26]};
	assign in27[3:0] = {i3[27], i2[27], i1[27], i0[27]};
	assign in27[7:4] = {i7[27], i6[27], i5[27], i4[27]};
	mux8to1x2 m26 (.in0(in26), .sel0(s), .in1(in27), .sel1(s), .out(o[27:26]));
	assign in28[3:0] = {i3[28], i2[28], i1[28], i0[28]};
	assign in28[7:4] = {i7[28], i6[28], i5[28], i4[28]};
	assign in29[3:0] = {i3[29], i2[29], i1[29], i0[29]};
	assign in29[7:4] = {i7[29], i6[29], i5[29], i4[29]};
	mux8to1x2 m28 (.in0(in28), .sel0(s), .in1(in29), .sel1(s), .out(o[29:28]));
	assign in30[3:0] = {i3[30], i2[30], i1[30], i0[30]};
	assign in30[7:4] = {i7[30], i6[30], i5[30], i4[30]};
	assign in31[3:0] = {i3[31], i2[31], i1[31], i0[31]};
	assign in31[7:4] = {i7[31], i6[31], i5[31], i4[31]};
	mux8to1x2 m30 (.in0(in30), .sel0(s), .in1(in31), .sel1(s), .out(o[31:30]));
	assign in32[3:0] = {i3[32], i2[32], i1[32], i0[32]};
	assign in32[7:4] = {i7[32], i6[32], i5[32], i4[32]};
	assign in33[3:0] = {i3[33], i2[33], i1[33], i0[33]};
	assign in33[7:4] = {i7[33], i6[33], i5[33], i4[33]};
	mux8to1x2 m32 (.in0(in32), .sel0(s), .in1(in33), .sel1(s), .out(o[33:32]));
	assign in34[3:0] = {i3[34], i2[34], i1[34], i0[34]};
	assign in34[7:4] = {i7[34], i6[34], i5[34], i4[34]};
	assign in35[3:0] = {i3[35], i2[35], i1[35], i0[35]};
	assign in35[7:4] = {i7[35], i6[35], i5[35], i4[35]};
	mux8to1x2 m34 (.in0(in34), .sel0(s), .in1(in35), .sel1(s), .out(o[35:34]));
	assign in36[3:0] = {i3[36], i2[36], i1[36], i0[36]};
	assign in36[7:4] = {i7[36], i6[36], i5[36], i4[36]};
	assign in37[3:0] = {i3[37], i2[37], i1[37], i0[37]};
	assign in37[7:4] = {i7[37], i6[37], i5[37], i4[37]};
	mux8to1x2 m36 (.in0(in36), .sel0(s), .in1(in37), .sel1(s), .out(o[37:36]));
	assign in38[3:0] = {i3[38], i2[38], i1[38], i0[38]};
	assign in38[7:4] = {i7[38], i6[38], i5[38], i4[38]};
	assign in39[3:0] = {i3[39], i2[39], i1[39], i0[39]};
	assign in39[7:4] = {i7[39], i6[39], i5[39], i4[39]};
	mux8to1x2 m38 (.in0(in38), .sel0(s), .in1(in39), .sel1(s), .out(o[39:38]));
	assign in40[3:0] = {i3[40], i2[40], i1[40], i0[40]};
	assign in40[7:4] = {i7[40], i6[40], i5[40], i4[40]};
	assign in41[3:0] = {i3[41], i2[41], i1[41], i0[41]};
	assign in41[7:4] = {i7[41], i6[41], i5[41], i4[41]};
	mux8to1x2 m40 (.in0(in40), .sel0(s), .in1(in41), .sel1(s), .out(o[41:40]));
	assign in42[3:0] = {i3[42], i2[42], i1[42], i0[42]};
	assign in42[7:4] = {i7[42], i6[42], i5[42], i4[42]};
	assign in43[3:0] = {i3[43], i2[43], i1[43], i0[43]};
	assign in43[7:4] = {i7[43], i6[43], i5[43], i4[43]};
	mux8to1x2 m42 (.in0(in42), .sel0(s), .in1(in43), .sel1(s), .out(o[43:42]));
	assign in44[3:0] = {i3[44], i2[44], i1[44], i0[44]};
	assign in44[7:4] = {i7[44], i6[44], i5[44], i4[44]};
	assign in45[3:0] = {i3[45], i2[45], i1[45], i0[45]};
	assign in45[7:4] = {i7[45], i6[45], i5[45], i4[45]};
	mux8to1x2 m44 (.in0(in44), .sel0(s), .in1(in45), .sel1(s), .out(o[45:44]));
	assign in46[3:0] = {i3[46], i2[46], i1[46], i0[46]};
	assign in46[7:4] = {i7[46], i6[46], i5[46], i4[46]};
	assign in47[3:0] = {i3[47], i2[47], i1[47], i0[47]};
	assign in47[7:4] = {i7[47], i6[47], i5[47], i4[47]};
	mux8to1x2 m46 (.in0(in46), .sel0(s), .in1(in47), .sel1(s), .out(o[47:46]));
	assign in48[3:0] = {i3[48], i2[48], i1[48], i0[48]};
	assign in48[7:4] = {i7[48], i6[48], i5[48], i4[48]};
	assign in49[3:0] = {i3[49], i2[49], i1[49], i0[49]};
	assign in49[7:4] = {i7[49], i6[49], i5[49], i4[49]};
	mux8to1x2 m48 (.in0(in48), .sel0(s), .in1(in49), .sel1(s), .out(o[49:48]));
	assign in50[3:0] = {i3[50], i2[50], i1[50], i0[50]};
	assign in50[7:4] = {i7[50], i6[50], i5[50], i4[50]};
	assign in51[3:0] = {i3[51], i2[51], i1[51], i0[51]};
	assign in51[7:4] = {i7[51], i6[51], i5[51], i4[51]};
	mux8to1x2 m50 (.in0(in50), .sel0(s), .in1(in51), .sel1(s), .out(o[51:50]));
	assign in52[3:0] = {i3[52], i2[52], i1[52], i0[52]};
	assign in52[7:4] = {i7[52], i6[52], i5[52], i4[52]};
	assign in53[3:0] = {i3[53], i2[53], i1[53], i0[53]};
	assign in53[7:4] = {i7[53], i6[53], i5[53], i4[53]};
	mux8to1x2 m52 (.in0(in52), .sel0(s), .in1(in53), .sel1(s), .out(o[53:52]));
	assign in54[3:0] = {i3[54], i2[54], i1[54], i0[54]};
	assign in54[7:4] = {i7[54], i6[54], i5[54], i4[54]};
	assign in55[3:0] = {i3[55], i2[55], i1[55], i0[55]};
	assign in55[7:4] = {i7[55], i6[55], i5[55], i4[55]};
	mux8to1x2 m54 (.in0(in54), .sel0(s), .in1(in55), .sel1(s), .out(o[55:54]));
	assign in56[3:0] = {i3[56], i2[56], i1[56], i0[56]};
	assign in56[7:4] = {i7[56], i6[56], i5[56], i4[56]};
	assign in57[3:0] = {i3[57], i2[57], i1[57], i0[57]};
	assign in57[7:4] = {i7[57], i6[57], i5[57], i4[57]};
	mux8to1x2 m56 (.in0(in56), .sel0(s), .in1(in57), .sel1(s), .out(o[57:56]));
	assign in58[3:0] = {i3[58], i2[58], i1[58], i0[58]};
	assign in58[7:4] = {i7[58], i6[58], i5[58], i4[58]};
	assign in59[3:0] = {i3[59], i2[59], i1[59], i0[59]};
	assign in59[7:4] = {i7[59], i6[59], i5[59], i4[59]};
	mux8to1x2 m58 (.in0(in58), .sel0(s), .in1(in59), .sel1(s), .out(o[59:58]));
	assign in60[3:0] = {i3[60], i2[60], i1[60], i0[60]};
	assign in60[7:4] = {i7[60], i6[60], i5[60], i4[60]};
	assign in61[3:0] = {i3[61], i2[61], i1[61], i0[61]};
	assign in61[7:4] = {i7[61], i6[61], i5[61], i4[61]};
	mux8to1x2 m60 (.in0(in60), .sel0(s), .in1(in61), .sel1(s), .out(o[61:60]));
	assign in62[3:0] = {i3[62], i2[62], i1[62], i0[62]};
	assign in62[7:4] = {i7[62], i6[62], i5[62], i4[62]};
	assign in63[3:0] = {i3[63], i2[63], i1[63], i0[63]};
	assign in63[7:4] = {i7[63], i6[63], i5[63], i4[63]};
	mux8to1x2 m62 (.in0(in62), .sel0(s), .in1(in63), .sel1(s), .out(o[63:62]));
	assign in64[3:0] = {i3[64], i2[64], i1[64], i0[64]};
	assign in64[7:4] = {i7[64], i6[64], i5[64], i4[64]};
	assign in65[3:0] = {i3[65], i2[65], i1[65], i0[65]};
	assign in65[7:4] = {i7[65], i6[65], i5[65], i4[65]};
	mux8to1x2 m64 (.in0(in64), .sel0(s), .in1(in65), .sel1(s), .out(o[65:64]));
	assign in66[3:0] = {i3[66], i2[66], i1[66], i0[66]};
	assign in66[7:4] = {i7[66], i6[66], i5[66], i4[66]};
	assign in67[3:0] = {i3[67], i2[67], i1[67], i0[67]};
	assign in67[7:4] = {i7[67], i6[67], i5[67], i4[67]};
	mux8to1x2 m66 (.in0(in66), .sel0(s), .in1(in67), .sel1(s), .out(o[67:66]));
	assign in68[3:0] = {i3[68], i2[68], i1[68], i0[68]};
	assign in68[7:4] = {i7[68], i6[68], i5[68], i4[68]};
	assign in69[3:0] = {i3[69], i2[69], i1[69], i0[69]};
	assign in69[7:4] = {i7[69], i6[69], i5[69], i4[69]};
	mux8to1x2 m68 (.in0(in68), .sel0(s), .in1(in69), .sel1(s), .out(o[69:68]));
	assign in70[3:0] = {i3[70], i2[70], i1[70], i0[70]};
	assign in70[7:4] = {i7[70], i6[70], i5[70], i4[70]};
	assign in71[3:0] = {i3[71], i2[71], i1[71], i0[71]};
	assign in71[7:4] = {i7[71], i6[71], i5[71], i4[71]};
	mux8to1x2 m70 (.in0(in70), .sel0(s), .in1(in71), .sel1(s), .out(o[71:70]));
	assign in72[3:0] = {i3[72], i2[72], i1[72], i0[72]};
	assign in72[7:4] = {i7[72], i6[72], i5[72], i4[72]};
	assign in73[3:0] = {i3[73], i2[73], i1[73], i0[73]};
	assign in73[7:4] = {i7[73], i6[73], i5[73], i4[73]};
	mux8to1x2 m72 (.in0(in72), .sel0(s), .in1(in73), .sel1(s), .out(o[73:72]));
	assign in74[3:0] = {i3[74], i2[74], i1[74], i0[74]};
	assign in74[7:4] = {i7[74], i6[74], i5[74], i4[74]};
	assign in75[3:0] = {i3[75], i2[75], i1[75], i0[75]};
	assign in75[7:4] = {i7[75], i6[75], i5[75], i4[75]};
	mux8to1x2 m74 (.in0(in74), .sel0(s), .in1(in75), .sel1(s), .out(o[75:74]));
	assign in76[3:0] = {i3[76], i2[76], i1[76], i0[76]};
	assign in76[7:4] = {i7[76], i6[76], i5[76], i4[76]};
	assign in77[3:0] = {i3[77], i2[77], i1[77], i0[77]};
	assign in77[7:4] = {i7[77], i6[77], i5[77], i4[77]};
	mux8to1x2 m76 (.in0(in76), .sel0(s), .in1(in77), .sel1(s), .out(o[77:76]));
	assign in78[3:0] = {i3[78], i2[78], i1[78], i0[78]};
	assign in78[7:4] = {i7[78], i6[78], i5[78], i4[78]};
	assign in79[3:0] = {i3[79], i2[79], i1[79], i0[79]};
	assign in79[7:4] = {i7[79], i6[79], i5[79], i4[79]};
	mux8to1x2 m78 (.in0(in78), .sel0(s), .in1(in79), .sel1(s), .out(o[79:78]));
	assign in80[3:0] = {i3[80], i2[80], i1[80], i0[80]};
	assign in80[7:4] = {i7[80], i6[80], i5[80], i4[80]};
	assign in81[3:0] = {i3[81], i2[81], i1[81], i0[81]};
	assign in81[7:4] = {i7[81], i6[81], i5[81], i4[81]};
	mux8to1x2 m80 (.in0(in80), .sel0(s), .in1(in81), .sel1(s), .out(o[81:80]));
	assign in82[3:0] = {i3[82], i2[82], i1[82], i0[82]};
	assign in82[7:4] = {i7[82], i6[82], i5[82], i4[82]};
	assign in83[3:0] = {i3[83], i2[83], i1[83], i0[83]};
	assign in83[7:4] = {i7[83], i6[83], i5[83], i4[83]};
	mux8to1x2 m82 (.in0(in82), .sel0(s), .in1(in83), .sel1(s), .out(o[83:82]));
	assign in84[3:0] = {i3[84], i2[84], i1[84], i0[84]};
	assign in84[7:4] = {i7[84], i6[84], i5[84], i4[84]};
	assign in85[3:0] = {i3[85], i2[85], i1[85], i0[85]};
	assign in85[7:4] = {i7[85], i6[85], i5[85], i4[85]};
	mux8to1x2 m84 (.in0(in84), .sel0(s), .in1(in85), .sel1(s), .out(o[85:84]));
	assign in86[3:0] = {i3[86], i2[86], i1[86], i0[86]};
	assign in86[7:4] = {i7[86], i6[86], i5[86], i4[86]};
	assign in87[3:0] = {i3[87], i2[87], i1[87], i0[87]};
	assign in87[7:4] = {i7[87], i6[87], i5[87], i4[87]};
	mux8to1x2 m86 (.in0(in86), .sel0(s), .in1(in87), .sel1(s), .out(o[87:86]));
	assign in88[3:0] = {i3[88], i2[88], i1[88], i0[88]};
	assign in88[7:4] = {i7[88], i6[88], i5[88], i4[88]};
	assign in89[3:0] = {i3[89], i2[89], i1[89], i0[89]};
	assign in89[7:4] = {i7[89], i6[89], i5[89], i4[89]};
	mux8to1x2 m88 (.in0(in88), .sel0(s), .in1(in89), .sel1(s), .out(o[89:88]));
	assign in90[3:0] = {i3[90], i2[90], i1[90], i0[90]};
	assign in90[7:4] = {i7[90], i6[90], i5[90], i4[90]};
	assign in91[3:0] = {i3[91], i2[91], i1[91], i0[91]};
	assign in91[7:4] = {i7[91], i6[91], i5[91], i4[91]};
	mux8to1x2 m90 (.in0(in90), .sel0(s), .in1(in91), .sel1(s), .out(o[91:90]));
	assign in92[3:0] = {i3[92], i2[92], i1[92], i0[92]};
	assign in92[7:4] = {i7[92], i6[92], i5[92], i4[92]};
	assign in93[3:0] = {i3[93], i2[93], i1[93], i0[93]};
	assign in93[7:4] = {i7[93], i6[93], i5[93], i4[93]};
	mux8to1x2 m92 (.in0(in92), .sel0(s), .in1(in93), .sel1(s), .out(o[93:92]));
	assign in94[3:0] = {i3[94], i2[94], i1[94], i0[94]};
	assign in94[7:4] = {i7[94], i6[94], i5[94], i4[94]};
	assign in95[3:0] = {i3[95], i2[95], i1[95], i0[95]};
	assign in95[7:4] = {i7[95], i6[95], i5[95], i4[95]};
	mux8to1x2 m94 (.in0(in94), .sel0(s), .in1(in95), .sel1(s), .out(o[95:94]));
	assign in96[3:0] = {i3[96], i2[96], i1[96], i0[96]};
	assign in96[7:4] = {i7[96], i6[96], i5[96], i4[96]};
	assign in97[3:0] = {i3[97], i2[97], i1[97], i0[97]};
	assign in97[7:4] = {i7[97], i6[97], i5[97], i4[97]};
	mux8to1x2 m96 (.in0(in96), .sel0(s), .in1(in97), .sel1(s), .out(o[97:96]));
	assign in98[3:0] = {i3[98], i2[98], i1[98], i0[98]};
	assign in98[7:4] = {i7[98], i6[98], i5[98], i4[98]};
	assign in99[3:0] = {i3[99], i2[99], i1[99], i0[99]};
	assign in99[7:4] = {i7[99], i6[99], i5[99], i4[99]};
	mux8to1x2 m98 (.in0(in98), .sel0(s), .in1(in99), .sel1(s), .out(o[99:98]));
	assign in100[3:0] = {i3[100], i2[100], i1[100], i0[100]};
	assign in100[7:4] = {i7[100], i6[100], i5[100], i4[100]};
	assign in101[3:0] = {i3[101], i2[101], i1[101], i0[101]};
	assign in101[7:4] = {i7[101], i6[101], i5[101], i4[101]};
	mux8to1x2 m100 (.in0(in100), .sel0(s), .in1(in101), .sel1(s), .out(o[101:100]));
	assign in102[3:0] = {i3[102], i2[102], i1[102], i0[102]};
	assign in102[7:4] = {i7[102], i6[102], i5[102], i4[102]};
	assign in103[3:0] = {i3[103], i2[103], i1[103], i0[103]};
	assign in103[7:4] = {i7[103], i6[103], i5[103], i4[103]};
	mux8to1x2 m102 (.in0(in102), .sel0(s), .in1(in103), .sel1(s), .out(o[103:102]));
	assign in104[3:0] = {i3[104], i2[104], i1[104], i0[104]};
	assign in104[7:4] = {i7[104], i6[104], i5[104], i4[104]};
	assign in105[3:0] = {i3[105], i2[105], i1[105], i0[105]};
	assign in105[7:4] = {i7[105], i6[105], i5[105], i4[105]};
	mux8to1x2 m104 (.in0(in104), .sel0(s), .in1(in105), .sel1(s), .out(o[105:104]));
	assign in106[3:0] = {i3[106], i2[106], i1[106], i0[106]};
	assign in106[7:4] = {i7[106], i6[106], i5[106], i4[106]};
	assign in107[3:0] = {i3[107], i2[107], i1[107], i0[107]};
	assign in107[7:4] = {i7[107], i6[107], i5[107], i4[107]};
	mux8to1x2 m106 (.in0(in106), .sel0(s), .in1(in107), .sel1(s), .out(o[107:106]));
	assign in108[3:0] = {i3[108], i2[108], i1[108], i0[108]};
	assign in108[7:4] = {i7[108], i6[108], i5[108], i4[108]};
	assign in109[3:0] = {i3[109], i2[109], i1[109], i0[109]};
	assign in109[7:4] = {i7[109], i6[109], i5[109], i4[109]};
	mux8to1x2 m108 (.in0(in108), .sel0(s), .in1(in109), .sel1(s), .out(o[109:108]));
	assign in110[3:0] = {i3[110], i2[110], i1[110], i0[110]};
	assign in110[7:4] = {i7[110], i6[110], i5[110], i4[110]};
	assign in111[3:0] = {i3[111], i2[111], i1[111], i0[111]};
	assign in111[7:4] = {i7[111], i6[111], i5[111], i4[111]};
	mux8to1x2 m110 (.in0(in110), .sel0(s), .in1(in111), .sel1(s), .out(o[111:110]));
	assign in112[3:0] = {i3[112], i2[112], i1[112], i0[112]};
	assign in112[7:4] = {i7[112], i6[112], i5[112], i4[112]};
	assign in113[3:0] = {i3[113], i2[113], i1[113], i0[113]};
	assign in113[7:4] = {i7[113], i6[113], i5[113], i4[113]};
	mux8to1x2 m112 (.in0(in112), .sel0(s), .in1(in113), .sel1(s), .out(o[113:112]));
	wire [3:0] m0i;
	wire [3:0] m1i;
	wire m0o;
	wire m1o;
	assign in114 = {i7[114], i6[114], i5[114], i4[114], 
	i3[114], i2[114], i1[114], i0[114]};
	assign m0i = in114[3:0];
	assign m1i = in114[7:4];
	assign m0o = m0i[s[1:0]];
	assign m1o = m1i[s[1:0]];
	MUXF7 m114 (.S(s[2]), .I0(m0o), .I1(m1o), .O(o[114]));
endmodule

// macexp DFF 5
// macexp $size 9
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_9 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_9 "true";
	input clk;
	input [8:0] d;
	output [8:0] q;
	reg [8:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 1
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_1 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_1 "true";
	input clk;
	input reset;
	input d;
	output q;
	reg q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 1'b0;
	else
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 9
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_9 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_9 "true";
	input clk;
	input reset;
	input [8:0] d;
	output [8:0] q;
	reg [8:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 9'b0;
	else
	q <= d;
	end
endmodule

// macexp SYNC2 5
// macexp $size 6
// macexp $instance
// macexp clk
// macexp d
// macexp q

module sync2_6 ( clk, d, q );
	// synthesis attribute keep_hierarchy sync2_6 "true";
	// synthesis attribute equivalent_register_removal sync2_6 "no";
	// synthesis attribute register_duplication sync2_6 "no";
	// synthesis attribute shift_extract sync2_6 "no";
	// synthesis attribute shreg_extract sync2_6 "no";
	input clk;
	input [5:0] d;
	output [5:0] q;
	// the simulation model has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles
	// synthesis attribute keep q "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg [5:0] /* synthesis syn_preserve = 1 */ q;
	reg [5:0] c_q;
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	// synthesis attribute keep meta1 "true";
	reg [5:0] /* synthesis syn_preserve = 1 */ meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [5:0] c_meta2;
	reg [5:0] meta2;
`endif
	// synopsys translate_on
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta2
`endif
	// synopsys translate_on
	) begin
	c_q = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	c_meta2 = (d ^ meta1) & $random(seed);
	c_q = c_meta2 | ((meta1 ^ meta2) & $random(seed)) |
	(d & meta1 & meta2);
	c_meta2 = c_meta2 | (d & meta1);
`endif
	// synopsys translate_on
	end
	always @(posedge clk) begin
	meta1 <= d;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta2 <= c_meta2;
`endif
	// synopsys translate_on
	q <= c_q;
	end
endmodule

// macexp MUX2 6
// macexp $size 1
// macexp $instance
// macexp s
// macexp i0
// macexp i1
// macexp o

module mux2_1 ( s, i0, i1, o );
	// synthesis attribute keep_hierarchy mux2_1 "no";
	input s;
	input i0, i1;
	output o;
	wire [1:0] mi;
	assign mi = {i1, i0};
	assign o = mi[s];
endmodule

// macexp DFFL 6
// macexp $size 34
// macexp $instance
// macexp clk
// macexp ld
// macexp d
// macexp q

module dffl_34 ( clk, ld, d, q );
	// synthesis attribute keep_hierarchy dffl_34 "true";
	input clk;
	input ld;
	input [33:0] d;
	output [33:0] q;
	reg [33:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	// leda XV2P_1006 off Multiple synchronous resets detected
	// leda XV2P_1007 off Multiple synchronous resets detected
	// leda G_551_1_K off Multiple synchronous resets detected
	if (ld)
	q <= d;
	// leda XV2P_1006 on Multiple synchronous resets detected
	// leda XV2P_1007 on Multiple synchronous resets detected
	// leda G_551_1_K on Multiple synchronous resets detected
	end
endmodule

// macexp PHASEGEN 7
// macexp $size 1
// macexp $instance
// macexp clk
// macexp clk_2x
// macexp set
// macexp phase
// macexp reset

module phasegen_1 ( clk, clk_2x, set, phase, reset );
	// synthesis attribute keep_hierarchy phasegen_1 "true";
	// synthesis attribute equivalent_register_removal phasegen_1 "no";
	// synthesis attribute shift_extract phasegen_1 "no";
	// synthesis attribute shreg_extract phasegen_1 "no";
	input clk;
	input clk_2x;
	input set;
	output phase;
	output reset;
	// synopsys translate_off
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: set still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(set),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	wire my_zero, set_ls;
	assign reset = set_ls;
	LUT1_L #(
	.INIT(2'h0)
	) rset_ls_lut (
	.LO(my_zero),
	.I0(set_ls)
	);
	FDS rset_ls (
	.Q(set_ls), 
	.C(clk), 
	.D(my_zero), 
	.S(set)
	);
	FDS rphase (
	.Q(phase), 
	.C(clk_2x), 
	.D(~phase), 
	.S(set_ls)
	);
endmodule

// macexp DFF 5
// macexp $size 5
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_5 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_5 "true";
	input clk;
	input [4:0] d;
	output [4:0] q;
	reg [4:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp REGFILE 10
// macexp $depth 8
// macexp $size 12
// macexp $instance
// macexp clk_wr
// macexp wr_en
// macexp wr_addr
// macexp wr_data
// macexp clk_rd
// macexp rd_addr
// macexp rd_data

module regfile_8x12 ( clk_wr, wr_en, wr_addr, wr_data, clk_rd, rd_addr, rd_data );
	// synthesis attribute keep_hierarchy regfile_8x12 "true";
	input clk_wr, clk_rd;
	input wr_en;
	input  [2:0] wr_addr;
	input  [11:0] wr_data;
	input  [2:0] rd_addr;
	output [11:0] rd_data;
	// leda XV2P_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV2_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg    [11:0] data [8 - 1:0];
	// leda XV2P_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV2_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg	[2:0]    r_rd_addr;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	begin
	$random_init("r_rd_addr", "data");
	end
`endif
	// synopsys translate_on
	always @(posedge clk_wr)
	begin
	if (wr_en) begin
	// synopsys translate_off
	if (wr_addr >= 8) begin
	data[7] <= ~(12'b0);
	data[6] <= ~(12'b0);
	data[5] <= ~(12'b0);
	data[4] <= ~(12'b0);
	data[3] <= ~(12'b0);
	data[2] <= ~(12'b0);
	data[1] <= ~(12'b0);
	data[0] <= ~(12'b0);
	end
	else
	// synopsys translate_on
	data[wr_addr] <= wr_data;
	end
	end
	// leda VER_1_4_4_1 off Do not use multiple clocks in a module
	// leda DFT_006 off 2 clocks in a block
	// leda W389 off 2 clocks in the module
	// leda B_1202 off 2 clocks in this unit detected
	always @(posedge clk_rd)
	r_rd_addr <= rd_addr;
	// leda VER_1_4_4_1 on Do not use multiple clocks in a module
	// leda DFT_006 on 2 clocks in a block
	// leda W389 on 2 clocks in the module
	// leda B_1202 on 2 clocks in this unit detected
	assign rd_data = 
	// synopsys translate_off
	(r_rd_addr >= 8) ? ~(12'b0) :
	// synopsys translate_on
	data[r_rd_addr];
endmodule

// macexp REGFILE 10
// macexp $depth 8
// macexp $size 11
// macexp $instance
// macexp clk_wr
// macexp wr_en
// macexp wr_addr
// macexp wr_data
// macexp clk_rd
// macexp rd_addr
// macexp rd_data

module regfile_8x11 ( clk_wr, wr_en, wr_addr, wr_data, clk_rd, rd_addr, rd_data );
	// synthesis attribute keep_hierarchy regfile_8x11 "true";
	input clk_wr, clk_rd;
	input wr_en;
	input  [2:0] wr_addr;
	input  [10:0] wr_data;
	input  [2:0] rd_addr;
	output [10:0] rd_data;
	// leda XV2P_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV2_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg    [10:0] data [8 - 1:0];
	// leda XV2P_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV2_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg	[2:0]    r_rd_addr;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	begin
	$random_init("r_rd_addr", "data");
	end
`endif
	// synopsys translate_on
	always @(posedge clk_wr)
	begin
	if (wr_en) begin
	// synopsys translate_off
	if (wr_addr >= 8) begin
	data[7] <= ~(11'b0);
	data[6] <= ~(11'b0);
	data[5] <= ~(11'b0);
	data[4] <= ~(11'b0);
	data[3] <= ~(11'b0);
	data[2] <= ~(11'b0);
	data[1] <= ~(11'b0);
	data[0] <= ~(11'b0);
	end
	else
	// synopsys translate_on
	data[wr_addr] <= wr_data;
	end
	end
	// leda VER_1_4_4_1 off Do not use multiple clocks in a module
	// leda DFT_006 off 2 clocks in a block
	// leda W389 off 2 clocks in the module
	// leda B_1202 off 2 clocks in this unit detected
	always @(posedge clk_rd)
	r_rd_addr <= rd_addr;
	// leda VER_1_4_4_1 on Do not use multiple clocks in a module
	// leda DFT_006 on 2 clocks in a block
	// leda W389 on 2 clocks in the module
	// leda B_1202 on 2 clocks in this unit detected
	assign rd_data = 
	// synopsys translate_off
	(r_rd_addr >= 8) ? ~(11'b0) :
	// synopsys translate_on
	data[r_rd_addr];
endmodule

// macexp DFF_KEEP 5
// macexp $size 1
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_1 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_1 "true";
	// synthesis attribute equivalent_register_removal dff_keep_1 "no";
	// synthesis attribute shift_extract dff_keep_1 "no";
	// synthesis attribute shreg_extract dff_keep_1 "no";
	input clk;
	input d;
	// synthesis attribute keep q "true";
	output q;
	(* S = "TRUE" *)
	FD q0 (
	.Q(q),
	.C(clk),
	.D(d)
	);
endmodule

// macexp DFF_KEEP 5
// macexp $size 9
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_9 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_9 "true";
	// synthesis attribute equivalent_register_removal dff_keep_9 "no";
	// synthesis attribute shift_extract dff_keep_9 "no";
	// synthesis attribute shreg_extract dff_keep_9 "no";
	input clk;
	input [8:0] d;
	// synthesis attribute keep q "true";
	output [8:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FD q_3 (
	.Q(q[3]),
	.C(clk),
	.D(d[3])
	);
	(* S = "TRUE" *)
	FD q_4 (
	.Q(q[4]),
	.C(clk),
	.D(d[4])
	);
	(* S = "TRUE" *)
	FD q_5 (
	.Q(q[5]),
	.C(clk),
	.D(d[5])
	);
	(* S = "TRUE" *)
	FD q_6 (
	.Q(q[6]),
	.C(clk),
	.D(d[6])
	);
	(* S = "TRUE" *)
	FD q_7 (
	.Q(q[7]),
	.C(clk),
	.D(d[7])
	);
	(* S = "TRUE" *)
	FD q_8 (
	.Q(q[8]),
	.C(clk),
	.D(d[8])
	);
endmodule

// macexp DFF 5
// macexp $size 8
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_8 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_8 "true";
	input clk;
	input [7:0] d;
	output [7:0] q;
	reg [7:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 16
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_16 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_16 "true";
	input clk;
	input [15:0] d;
	output [15:0] q;
	reg [15:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 4
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_4 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_4 "true";
	input clk;
	input [3:0] d;
	output [3:0] q;
	reg [3:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 6
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_6 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_6 "true";
	input clk;
	input [5:0] d;
	output [5:0] q;
	reg [5:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFFC_KEEP 6
// macexp $size 3
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_keep_3 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_keep_3 "true";
	// synthesis attribute equivalent_register_removal dffc_keep_3 "no";
	// synthesis attribute shift_extract dffc_keep_3 "no";
	// synthesis attribute shreg_extract dffc_keep_3 "no";
	input clk;
	input reset;
	input [2:0] d;
	// synthesis attribute keep q "true";
	output [2:0] q;
	// synopsys translate_off
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	(* S = "TRUE" *)
	FDR q_0 (
	.Q(q[0]),
	.C(clk),
	.R(reset),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FDR q_1 (
	.Q(q[1]),
	.C(clk),
	.R(reset),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FDR q_2 (
	.Q(q[2]),
	.C(clk),
	.R(reset),
	.D(d[2])
	);
endmodule

// macexp SYNC_PEDGE 5
// macexp $size 1
// macexp $instance
// macexp clk
// macexp d
// macexp pulse

module sync_pedge_1 ( clk, d, pulse );
	// synthesis attribute keep_hierarchy sync_pedge_1 "true";
	// synthesis attribute equivalent_register_removal sync_pedge_1 "no";
	// synthesis attribute register_duplication sync_pedge_1 "no";
	// synthesis attribute shift_extract sync_pedge_1 "no";
	// synthesis attribute shreg_extract sync_pedge_1 "no";
	input clk;
	input d;
	output pulse;
	reg pulse;
	reg q;
	reg c_q;
	// synthesis attribute keep meta1 "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ meta1;
	// synthesis attribute keep meta2 "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ meta2;
	reg c_meta2;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg meta3;
	reg c_meta3;
	reg rnd1, rnd2, in_change;
`endif
	// synopsys translate_on
	// the simulation mode has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles.
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2", "meta3");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 or meta2 or q
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta3
`endif
	// synopsys translate_on
	) begin
	pulse = ~q & meta2;
	c_q = meta2;
	c_meta2 = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	// the logic in front of the flops attempts to be careful not to
	// generate multiple edges into the pulse generator from a single
	// input edge while delaying the output edge by 1, 2 or 3 cycles.
	pulse = ~q & meta3;
	in_change = (d & ~(meta1 | meta2 | meta3)) |
	(~d & (meta1 & meta2 & meta3));
	c_meta2 = meta1;
	c_meta3 = meta2;
	c_q = meta3;
	if (in_change)
	begin
	rnd1 = $random(seed);
	rnd2 = $random(seed);
	c_meta3 = (~in_change & meta2) | (in_change & (d ^ (rnd1 | rnd2)
	));
	c_meta2 = (~in_change & meta1) | (in_change & (d ^ rnd1));
	end
`endif
	// synopsys translate_on
	end
	always @(posedge clk) begin
	meta1 <= d;
	meta2 <= c_meta2;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta3 <= c_meta3;
`endif
	// synopsys translate_on
	q <= c_q;
	end
endmodule

// macexp DFF 5
// macexp $size 2
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_2 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_2 "true";
	input clk;
	input [1:0] d;
	output [1:0] q;
	reg [1:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp SYNC2 5
// macexp $size 1
// macexp $instance
// macexp clk
// macexp d
// macexp q

module sync2_1 ( clk, d, q );
	// synthesis attribute keep_hierarchy sync2_1 "true";
	// synthesis attribute equivalent_register_removal sync2_1 "no";
	// synthesis attribute register_duplication sync2_1 "no";
	// synthesis attribute shift_extract sync2_1 "no";
	// synthesis attribute shreg_extract sync2_1 "no";
	input clk;
	input d;
	output q;
	// the simulation model has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles
	// synthesis attribute keep q "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ q;
	reg c_q;
	// synthesis attribute keep meta1 "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg c_meta2;
	reg meta2;
`endif
	// synopsys translate_on
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta2
`endif
	// synopsys translate_on
	) begin
	c_q = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	c_meta2 = (d ^ meta1) & $random(seed);
	c_q = c_meta2 | ((meta1 ^ meta2) & $random(seed)) |
	(d & meta1 & meta2);
	c_meta2 = c_meta2 | (d & meta1);
`endif
	// synopsys translate_on
	end
	always @(posedge clk) begin
	meta1 <= d;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta2 <= c_meta2;
`endif
	// synopsys translate_on
	q <= c_q;
	end
endmodule

// macexp REGFILE 10
// macexp $depth 8
// macexp $size 1
// macexp $instance
// macexp clk_wr
// macexp wr_en
// macexp wr_addr
// macexp wr_data
// macexp clk_rd
// macexp rd_addr
// macexp rd_data

module regfile_8x1 ( clk_wr, wr_en, wr_addr, wr_data, clk_rd, rd_addr, rd_data );
	// synthesis attribute keep_hierarchy regfile_8x1 "true";
	input clk_wr, clk_rd;
	input wr_en;
	input  [2:0] wr_addr;
	input                    wr_data;
	input  [2:0] rd_addr;
	output                   rd_data;
	// leda XV2P_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg			     data [8 - 1:0];
	// leda XV2P_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg	[2:0]    r_rd_addr;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	begin
	$random_init("r_rd_addr", "data");
	end
`endif
	// synopsys translate_on
	always @(posedge clk_wr)
	begin
	if (wr_en) begin
	// synopsys translate_off
	if (wr_addr >= 8) begin
	data[7] <= ~(1'b0);
	data[6] <= ~(1'b0);
	data[5] <= ~(1'b0);
	data[4] <= ~(1'b0);
	data[3] <= ~(1'b0);
	data[2] <= ~(1'b0);
	data[1] <= ~(1'b0);
	data[0] <= ~(1'b0);
	end
	else
	// synopsys translate_on
	data[wr_addr] <= wr_data;
	end
	end
	// leda VER_1_4_4_1 off Do not use multiple clocks in a module
	// leda DFT_006 off 2 clocks in a block
	// leda W389 off 2 clocks in the module
	// leda B_1202 off 2 clocks in this unit detected
	always @(posedge clk_rd)
	r_rd_addr <= rd_addr;
	// leda VER_1_4_4_1 on Do not use multiple clocks in a module
	// leda DFT_006 on 2 clocks in a block
	// leda W389 on 2 clocks in the module
	// leda B_1202 on 2 clocks in this unit detected
	assign rd_data = 
	// synopsys translate_off
	(r_rd_addr >= 8) ? ~(1'b0) :
	// synopsys translate_on
	data[r_rd_addr];
endmodule

// macexp ADDSUB 6
// macexp $size 6
// macexp $instance
// macexp i0
// macexp i1
// macexp s
// macexp sub

module addsub_6 ( i0, i1, s, sub );
	input [5:0] i0;
	input [5:0] i1;
	output [5:0] s;
	input sub;
	wire [7:0] cig_s;
	reg  [7:0] cig_si;
	reg  [7:0] cig_di;
	wire [7:0] cig_co;
	wire [5:0] si;
	wire [1:0] ci;
	wire [1:0] cyinit;
	assign si = i0 ^ (sub ? ~i1 : i1);
	always @ (si or i0) begin
	cig_si = 8'h0;
	cig_di = 8'h0;
	cig_si[5:0] = si;
	cig_di[5:0] = i0;
	end
	assign ci[0] = 1'b0;
	assign cyinit[0] = sub;
	CARRY4 cry0 (
	// Outputs
	.O(cig_s[3:0]),
	.CO(cig_co[3:0]),
	// Inputs
	.S(cig_si[3:0]),
	.DI(cig_di[3:0]),
	.CI(ci[0]),
	.CYINIT(cyinit[0])
	);
	assign ci[1] = cig_co[3];
	assign cyinit[1] = 1'b0;
	CARRY4 cry1 (
	// Outputs
	.O(cig_s[7:4]),
	.CO(cig_co[7:4]),
	// Inputs
	.S(cig_si[7:4]),
	.DI(cig_di[7:4]),
	.CI(ci[1]),
	.CYINIT(cyinit[1])
	);
	assign s = cig_s[5:0];
endmodule

// macexp ADDER 5
// macexp $size 6
// macexp $instance
// macexp i0
// macexp i1
// macexp s

module adder_6 ( i0, i1, s );
	input [5:0] i0;
	input [5:0] i1;
	output [5:0] s;
	wire [7:0] cig_s;
	reg  [7:0] cig_si;
	reg  [7:0] cig_di;
	wire [7:0] cig_co;
	wire [5:0] si;
	wire [1:0] ci;
	assign si = i0 ^ i1;
	always @ (si or i0) begin
	cig_si = 8'h0;
	cig_di = 8'h0;
	cig_si[5:0] = si;
	cig_di[5:0] = i0;
	end
	assign ci[0] = 1'b0;
	CARRY4 cry0 (
	// Outputs
	.O(cig_s[3:0]),
	.CO(cig_co[3:0]),
	// Inputs
	.S(cig_si[3:0]),
	.DI(cig_di[3:0]),
	.CI(ci[0]),
	.CYINIT(1'b0)
	);
	assign ci[1] = cig_co[3];
	CARRY4 cry1 (
	// Outputs
	.O(cig_s[7:4]),
	.CO(cig_co[7:4]),
	// Inputs
	.S(cig_si[7:4]),
	.DI(cig_di[7:4]),
	.CI(ci[1]),
	.CYINIT(1'b0)
	);
	assign s = cig_s[5:0];
endmodule

// macexp DFFL 6
// macexp $size 17
// macexp $instance
// macexp clk
// macexp ld
// macexp d
// macexp q

module dffl_17 ( clk, ld, d, q );
	// synthesis attribute keep_hierarchy dffl_17 "true";
	input clk;
	input ld;
	input [16:0] d;
	output [16:0] q;
	reg [16:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	// leda XV2P_1006 off Multiple synchronous resets detected
	// leda XV2P_1007 off Multiple synchronous resets detected
	// leda G_551_1_K off Multiple synchronous resets detected
	if (ld)
	q <= d;
	// leda XV2P_1006 on Multiple synchronous resets detected
	// leda XV2P_1007 on Multiple synchronous resets detected
	// leda G_551_1_K on Multiple synchronous resets detected
	end
endmodule

// macexp MUX16 20
// macexp $size 1
// macexp $instance
// macexp s
// macexp i0
// macexp i1
// macexp i2
// macexp i3
// macexp i4
// macexp i5
// macexp i6
// macexp i7
// macexp i8
// macexp i9
// macexp i10
// macexp i11
// macexp i12
// macexp i13
// macexp i14
// macexp i15
// macexp o

module mux16_1 ( s, i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, o );
	// synthesis attribute keep_hierarchy mux16_1 "true";
	input [3:0] s;
	input i0, i1, i2, i3, i4, i5, i6, i7;
	input i8, i9, i10, i11, i12, i13, i14, i15;
	output o;
	wire [7:0] m0i;
	wire [7:0] m1i;
	wire m0o;
	wire m1o;
	assign m0i = {i7, i6, i5, i4, i3, i2, i1, i0};
	assign m1i = {i15, i14, i13, i12, i11, i10, i9, i8};
	assign m0o = m0i[s[2:0]];
	assign m1o = m1i[s[2:0]];
	MUXF8 m0 (.S(s[3]), .I0(m0o), .I1(m1o), .O(o));
endmodule

// macexp MUX8 12
// macexp $size 1
// macexp $instance
// macexp s
// macexp i0
// macexp i1
// macexp i2
// macexp i3
// macexp i4
// macexp i5
// macexp i6
// macexp i7
// macexp o

module mux8_1 ( s, i0, i1, i2, i3, i4, i5, i6, i7, o );
	// synthesis attribute keep_hierarchy mux8_1 "true";
	input [2:0] s;
	input i0, i1, i2, i3, i4, i5, i6, i7;
	output o;
	wire [3:0] m0i;
	wire [3:0] m1i;
	wire m0o;
	wire m1o;
	assign m0i = {i3, i2, i1, i0};
	assign m1i = {i7, i6, i5, i4};
	assign m0o = m0i[s[1:0]];
	assign m1o = m1i[s[1:0]];
	MUXF7 m0 (.S(s[2]), .I0(m0o), .I1(m1o), .O(o));
endmodule

// macexp SYNC2 5
// macexp $size 2
// macexp $instance
// macexp clk
// macexp d
// macexp q

module sync2_2 ( clk, d, q );
	// synthesis attribute keep_hierarchy sync2_2 "true";
	// synthesis attribute equivalent_register_removal sync2_2 "no";
	// synthesis attribute register_duplication sync2_2 "no";
	// synthesis attribute shift_extract sync2_2 "no";
	// synthesis attribute shreg_extract sync2_2 "no";
	input clk;
	input [1:0] d;
	output [1:0] q;
	// the simulation model has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles
	// synthesis attribute keep q "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg [1:0] /* synthesis syn_preserve = 1 */ q;
	reg [1:0] c_q;
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	// synthesis attribute keep meta1 "true";
	reg [1:0] /* synthesis syn_preserve = 1 */ meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [1:0] c_meta2;
	reg [1:0] meta2;
`endif
	// synopsys translate_on
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta2
`endif
	// synopsys translate_on
	) begin
	c_q = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	c_meta2 = (d ^ meta1) & $random(seed);
	c_q = c_meta2 | ((meta1 ^ meta2) & $random(seed)) |
	(d & meta1 & meta2);
	c_meta2 = c_meta2 | (d & meta1);
`endif
	// synopsys translate_on
	end
	always @(posedge clk) begin
	meta1 <= d;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta2 <= c_meta2;
`endif
	// synopsys translate_on
	q <= c_q;
	end
endmodule

// macexp SYNC2 5
// macexp $size 7
// macexp $instance
// macexp clk
// macexp d
// macexp q

module sync2_7 ( clk, d, q );
	// synthesis attribute keep_hierarchy sync2_7 "true";
	// synthesis attribute equivalent_register_removal sync2_7 "no";
	// synthesis attribute register_duplication sync2_7 "no";
	// synthesis attribute shift_extract sync2_7 "no";
	// synthesis attribute shreg_extract sync2_7 "no";
	input clk;
	input [6:0] d;
	output [6:0] q;
	// the simulation model has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles
	// synthesis attribute keep q "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg [6:0] /* synthesis syn_preserve = 1 */ q;
	reg [6:0] c_q;
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	// synthesis attribute keep meta1 "true";
	reg [6:0] /* synthesis syn_preserve = 1 */ meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [6:0] c_meta2;
	reg [6:0] meta2;
`endif
	// synopsys translate_on
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta2
`endif
	// synopsys translate_on
	) begin
	c_q = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	c_meta2 = (d ^ meta1) & $random(seed);
	c_q = c_meta2 | ((meta1 ^ meta2) & $random(seed)) |
	(d & meta1 & meta2);
	c_meta2 = c_meta2 | (d & meta1);
`endif
	// synopsys translate_on
	end
	always @(posedge clk) begin
	meta1 <= d;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta2 <= c_meta2;
`endif
	// synopsys translate_on
	q <= c_q;
	end
endmodule

// macexp SYNC2 5
// macexp $size 4
// macexp $instance
// macexp clk
// macexp d
// macexp q

module sync2_4 ( clk, d, q );
	// synthesis attribute keep_hierarchy sync2_4 "true";
	// synthesis attribute equivalent_register_removal sync2_4 "no";
	// synthesis attribute register_duplication sync2_4 "no";
	// synthesis attribute shift_extract sync2_4 "no";
	// synthesis attribute shreg_extract sync2_4 "no";
	input clk;
	input [3:0] d;
	output [3:0] q;
	// the simulation model has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles
	// synthesis attribute keep q "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg [3:0] /* synthesis syn_preserve = 1 */ q;
	reg [3:0] c_q;
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	// synthesis attribute keep meta1 "true";
	reg [3:0] /* synthesis syn_preserve = 1 */ meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [3:0] c_meta2;
	reg [3:0] meta2;
`endif
	// synopsys translate_on
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta2
`endif
	// synopsys translate_on
	) begin
	c_q = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	c_meta2 = (d ^ meta1) & $random(seed);
	c_q = c_meta2 | ((meta1 ^ meta2) & $random(seed)) |
	(d & meta1 & meta2);
	c_meta2 = c_meta2 | (d & meta1);
`endif
	// synopsys translate_on
	end
	always @(posedge clk) begin
	meta1 <= d;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta2 <= c_meta2;
`endif
	// synopsys translate_on
	q <= c_q;
	end
endmodule

// macexp DFF 5
// macexp $size 3
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_3 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_3 "true";
	input clk;
	input [2:0] d;
	output [2:0] q;
	reg [2:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 1
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_1 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_1 "true";
	input clk;
	input d;
	output q;
	reg q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFFR 6
// macexp $size 3
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffr_3 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffr_3 "true";
	input clk;
	input reset;
	input [2:0] d;
	output [2:0] q;
	reg [2:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk or posedge reset) begin
	if (reset)
	q <= 3'b0;
	else
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 64
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_64 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_64 "true";
	input clk;
	input [63:0] d;
	output [63:0] q;
	reg [63:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 45
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_45 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_45 "true";
	input clk;
	input [44:0] d;
	output [44:0] q;
	reg [44:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFFS_KEEP 6
// macexp $size 1
// macexp $instance
// macexp clk
// macexp set
// macexp d
// macexp q

module dffs_keep_1 ( clk, set, d, q );
	// synthesis attribute keep_hierarchy dffs_keep_1 "true";
	// synthesis attribute equivalent_register_removal dffs_keep_1 "no";
	// synthesis attribute shift_extract dffs_keep_1 "no";
	// synthesis attribute shreg_extract dffs_keep_1 "no";
	input clk;
	input set;
	input d;
	// synthesis attribute keep q "true";
	output q;
	// synopsys translate_off
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: set still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(set),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	(* S = "TRUE" *)
	FDS q0 (
	.Q(q),
	.C(clk),
	.S(set),
	.D(d)
	);
endmodule

// macexp MUX8 12
// macexp $size 110
// macexp $instance
// macexp s
// macexp i0
// macexp i1
// macexp i2
// macexp i3
// macexp i4
// macexp i5
// macexp i6
// macexp i7
// macexp o

module mux8_110 ( s, i0, i1, i2, i3, i4, i5, i6, i7, o );
	// synthesis attribute keep_hierarchy mux8_110 "true";
	input  [2:0] s;
	input  [109:0] i0, i1, i2, i3, i4, i5, i6, i7;
	output [109:0] o;
	wire [7:0] in0;
	wire [7:0] in1;
	wire [7:0] in2;
	wire [7:0] in3;
	wire [7:0] in4;
	wire [7:0] in5;
	wire [7:0] in6;
	wire [7:0] in7;
	wire [7:0] in8;
	wire [7:0] in9;
	wire [7:0] in10;
	wire [7:0] in11;
	wire [7:0] in12;
	wire [7:0] in13;
	wire [7:0] in14;
	wire [7:0] in15;
	wire [7:0] in16;
	wire [7:0] in17;
	wire [7:0] in18;
	wire [7:0] in19;
	wire [7:0] in20;
	wire [7:0] in21;
	wire [7:0] in22;
	wire [7:0] in23;
	wire [7:0] in24;
	wire [7:0] in25;
	wire [7:0] in26;
	wire [7:0] in27;
	wire [7:0] in28;
	wire [7:0] in29;
	wire [7:0] in30;
	wire [7:0] in31;
	wire [7:0] in32;
	wire [7:0] in33;
	wire [7:0] in34;
	wire [7:0] in35;
	wire [7:0] in36;
	wire [7:0] in37;
	wire [7:0] in38;
	wire [7:0] in39;
	wire [7:0] in40;
	wire [7:0] in41;
	wire [7:0] in42;
	wire [7:0] in43;
	wire [7:0] in44;
	wire [7:0] in45;
	wire [7:0] in46;
	wire [7:0] in47;
	wire [7:0] in48;
	wire [7:0] in49;
	wire [7:0] in50;
	wire [7:0] in51;
	wire [7:0] in52;
	wire [7:0] in53;
	wire [7:0] in54;
	wire [7:0] in55;
	wire [7:0] in56;
	wire [7:0] in57;
	wire [7:0] in58;
	wire [7:0] in59;
	wire [7:0] in60;
	wire [7:0] in61;
	wire [7:0] in62;
	wire [7:0] in63;
	wire [7:0] in64;
	wire [7:0] in65;
	wire [7:0] in66;
	wire [7:0] in67;
	wire [7:0] in68;
	wire [7:0] in69;
	wire [7:0] in70;
	wire [7:0] in71;
	wire [7:0] in72;
	wire [7:0] in73;
	wire [7:0] in74;
	wire [7:0] in75;
	wire [7:0] in76;
	wire [7:0] in77;
	wire [7:0] in78;
	wire [7:0] in79;
	wire [7:0] in80;
	wire [7:0] in81;
	wire [7:0] in82;
	wire [7:0] in83;
	wire [7:0] in84;
	wire [7:0] in85;
	wire [7:0] in86;
	wire [7:0] in87;
	wire [7:0] in88;
	wire [7:0] in89;
	wire [7:0] in90;
	wire [7:0] in91;
	wire [7:0] in92;
	wire [7:0] in93;
	wire [7:0] in94;
	wire [7:0] in95;
	wire [7:0] in96;
	wire [7:0] in97;
	wire [7:0] in98;
	wire [7:0] in99;
	wire [7:0] in100;
	wire [7:0] in101;
	wire [7:0] in102;
	wire [7:0] in103;
	wire [7:0] in104;
	wire [7:0] in105;
	wire [7:0] in106;
	wire [7:0] in107;
	wire [7:0] in108;
	wire [7:0] in109;
	assign in0[3:0] = {i3[0], i2[0], i1[0], i0[0]};
	assign in0[7:4] = {i7[0], i6[0], i5[0], i4[0]};
	assign in1[3:0] = {i3[1], i2[1], i1[1], i0[1]};
	assign in1[7:4] = {i7[1], i6[1], i5[1], i4[1]};
	mux8to1x2 m0 (.in0(in0), .sel0(s), .in1(in1), .sel1(s), .out(o[1:0]));
	assign in2[3:0] = {i3[2], i2[2], i1[2], i0[2]};
	assign in2[7:4] = {i7[2], i6[2], i5[2], i4[2]};
	assign in3[3:0] = {i3[3], i2[3], i1[3], i0[3]};
	assign in3[7:4] = {i7[3], i6[3], i5[3], i4[3]};
	mux8to1x2 m2 (.in0(in2), .sel0(s), .in1(in3), .sel1(s), .out(o[3:2]));
	assign in4[3:0] = {i3[4], i2[4], i1[4], i0[4]};
	assign in4[7:4] = {i7[4], i6[4], i5[4], i4[4]};
	assign in5[3:0] = {i3[5], i2[5], i1[5], i0[5]};
	assign in5[7:4] = {i7[5], i6[5], i5[5], i4[5]};
	mux8to1x2 m4 (.in0(in4), .sel0(s), .in1(in5), .sel1(s), .out(o[5:4]));
	assign in6[3:0] = {i3[6], i2[6], i1[6], i0[6]};
	assign in6[7:4] = {i7[6], i6[6], i5[6], i4[6]};
	assign in7[3:0] = {i3[7], i2[7], i1[7], i0[7]};
	assign in7[7:4] = {i7[7], i6[7], i5[7], i4[7]};
	mux8to1x2 m6 (.in0(in6), .sel0(s), .in1(in7), .sel1(s), .out(o[7:6]));
	assign in8[3:0] = {i3[8], i2[8], i1[8], i0[8]};
	assign in8[7:4] = {i7[8], i6[8], i5[8], i4[8]};
	assign in9[3:0] = {i3[9], i2[9], i1[9], i0[9]};
	assign in9[7:4] = {i7[9], i6[9], i5[9], i4[9]};
	mux8to1x2 m8 (.in0(in8), .sel0(s), .in1(in9), .sel1(s), .out(o[9:8]));
	assign in10[3:0] = {i3[10], i2[10], i1[10], i0[10]};
	assign in10[7:4] = {i7[10], i6[10], i5[10], i4[10]};
	assign in11[3:0] = {i3[11], i2[11], i1[11], i0[11]};
	assign in11[7:4] = {i7[11], i6[11], i5[11], i4[11]};
	mux8to1x2 m10 (.in0(in10), .sel0(s), .in1(in11), .sel1(s), .out(o[11:10]));
	assign in12[3:0] = {i3[12], i2[12], i1[12], i0[12]};
	assign in12[7:4] = {i7[12], i6[12], i5[12], i4[12]};
	assign in13[3:0] = {i3[13], i2[13], i1[13], i0[13]};
	assign in13[7:4] = {i7[13], i6[13], i5[13], i4[13]};
	mux8to1x2 m12 (.in0(in12), .sel0(s), .in1(in13), .sel1(s), .out(o[13:12]));
	assign in14[3:0] = {i3[14], i2[14], i1[14], i0[14]};
	assign in14[7:4] = {i7[14], i6[14], i5[14], i4[14]};
	assign in15[3:0] = {i3[15], i2[15], i1[15], i0[15]};
	assign in15[7:4] = {i7[15], i6[15], i5[15], i4[15]};
	mux8to1x2 m14 (.in0(in14), .sel0(s), .in1(in15), .sel1(s), .out(o[15:14]));
	assign in16[3:0] = {i3[16], i2[16], i1[16], i0[16]};
	assign in16[7:4] = {i7[16], i6[16], i5[16], i4[16]};
	assign in17[3:0] = {i3[17], i2[17], i1[17], i0[17]};
	assign in17[7:4] = {i7[17], i6[17], i5[17], i4[17]};
	mux8to1x2 m16 (.in0(in16), .sel0(s), .in1(in17), .sel1(s), .out(o[17:16]));
	assign in18[3:0] = {i3[18], i2[18], i1[18], i0[18]};
	assign in18[7:4] = {i7[18], i6[18], i5[18], i4[18]};
	assign in19[3:0] = {i3[19], i2[19], i1[19], i0[19]};
	assign in19[7:4] = {i7[19], i6[19], i5[19], i4[19]};
	mux8to1x2 m18 (.in0(in18), .sel0(s), .in1(in19), .sel1(s), .out(o[19:18]));
	assign in20[3:0] = {i3[20], i2[20], i1[20], i0[20]};
	assign in20[7:4] = {i7[20], i6[20], i5[20], i4[20]};
	assign in21[3:0] = {i3[21], i2[21], i1[21], i0[21]};
	assign in21[7:4] = {i7[21], i6[21], i5[21], i4[21]};
	mux8to1x2 m20 (.in0(in20), .sel0(s), .in1(in21), .sel1(s), .out(o[21:20]));
	assign in22[3:0] = {i3[22], i2[22], i1[22], i0[22]};
	assign in22[7:4] = {i7[22], i6[22], i5[22], i4[22]};
	assign in23[3:0] = {i3[23], i2[23], i1[23], i0[23]};
	assign in23[7:4] = {i7[23], i6[23], i5[23], i4[23]};
	mux8to1x2 m22 (.in0(in22), .sel0(s), .in1(in23), .sel1(s), .out(o[23:22]));
	assign in24[3:0] = {i3[24], i2[24], i1[24], i0[24]};
	assign in24[7:4] = {i7[24], i6[24], i5[24], i4[24]};
	assign in25[3:0] = {i3[25], i2[25], i1[25], i0[25]};
	assign in25[7:4] = {i7[25], i6[25], i5[25], i4[25]};
	mux8to1x2 m24 (.in0(in24), .sel0(s), .in1(in25), .sel1(s), .out(o[25:24]));
	assign in26[3:0] = {i3[26], i2[26], i1[26], i0[26]};
	assign in26[7:4] = {i7[26], i6[26], i5[26], i4[26]};
	assign in27[3:0] = {i3[27], i2[27], i1[27], i0[27]};
	assign in27[7:4] = {i7[27], i6[27], i5[27], i4[27]};
	mux8to1x2 m26 (.in0(in26), .sel0(s), .in1(in27), .sel1(s), .out(o[27:26]));
	assign in28[3:0] = {i3[28], i2[28], i1[28], i0[28]};
	assign in28[7:4] = {i7[28], i6[28], i5[28], i4[28]};
	assign in29[3:0] = {i3[29], i2[29], i1[29], i0[29]};
	assign in29[7:4] = {i7[29], i6[29], i5[29], i4[29]};
	mux8to1x2 m28 (.in0(in28), .sel0(s), .in1(in29), .sel1(s), .out(o[29:28]));
	assign in30[3:0] = {i3[30], i2[30], i1[30], i0[30]};
	assign in30[7:4] = {i7[30], i6[30], i5[30], i4[30]};
	assign in31[3:0] = {i3[31], i2[31], i1[31], i0[31]};
	assign in31[7:4] = {i7[31], i6[31], i5[31], i4[31]};
	mux8to1x2 m30 (.in0(in30), .sel0(s), .in1(in31), .sel1(s), .out(o[31:30]));
	assign in32[3:0] = {i3[32], i2[32], i1[32], i0[32]};
	assign in32[7:4] = {i7[32], i6[32], i5[32], i4[32]};
	assign in33[3:0] = {i3[33], i2[33], i1[33], i0[33]};
	assign in33[7:4] = {i7[33], i6[33], i5[33], i4[33]};
	mux8to1x2 m32 (.in0(in32), .sel0(s), .in1(in33), .sel1(s), .out(o[33:32]));
	assign in34[3:0] = {i3[34], i2[34], i1[34], i0[34]};
	assign in34[7:4] = {i7[34], i6[34], i5[34], i4[34]};
	assign in35[3:0] = {i3[35], i2[35], i1[35], i0[35]};
	assign in35[7:4] = {i7[35], i6[35], i5[35], i4[35]};
	mux8to1x2 m34 (.in0(in34), .sel0(s), .in1(in35), .sel1(s), .out(o[35:34]));
	assign in36[3:0] = {i3[36], i2[36], i1[36], i0[36]};
	assign in36[7:4] = {i7[36], i6[36], i5[36], i4[36]};
	assign in37[3:0] = {i3[37], i2[37], i1[37], i0[37]};
	assign in37[7:4] = {i7[37], i6[37], i5[37], i4[37]};
	mux8to1x2 m36 (.in0(in36), .sel0(s), .in1(in37), .sel1(s), .out(o[37:36]));
	assign in38[3:0] = {i3[38], i2[38], i1[38], i0[38]};
	assign in38[7:4] = {i7[38], i6[38], i5[38], i4[38]};
	assign in39[3:0] = {i3[39], i2[39], i1[39], i0[39]};
	assign in39[7:4] = {i7[39], i6[39], i5[39], i4[39]};
	mux8to1x2 m38 (.in0(in38), .sel0(s), .in1(in39), .sel1(s), .out(o[39:38]));
	assign in40[3:0] = {i3[40], i2[40], i1[40], i0[40]};
	assign in40[7:4] = {i7[40], i6[40], i5[40], i4[40]};
	assign in41[3:0] = {i3[41], i2[41], i1[41], i0[41]};
	assign in41[7:4] = {i7[41], i6[41], i5[41], i4[41]};
	mux8to1x2 m40 (.in0(in40), .sel0(s), .in1(in41), .sel1(s), .out(o[41:40]));
	assign in42[3:0] = {i3[42], i2[42], i1[42], i0[42]};
	assign in42[7:4] = {i7[42], i6[42], i5[42], i4[42]};
	assign in43[3:0] = {i3[43], i2[43], i1[43], i0[43]};
	assign in43[7:4] = {i7[43], i6[43], i5[43], i4[43]};
	mux8to1x2 m42 (.in0(in42), .sel0(s), .in1(in43), .sel1(s), .out(o[43:42]));
	assign in44[3:0] = {i3[44], i2[44], i1[44], i0[44]};
	assign in44[7:4] = {i7[44], i6[44], i5[44], i4[44]};
	assign in45[3:0] = {i3[45], i2[45], i1[45], i0[45]};
	assign in45[7:4] = {i7[45], i6[45], i5[45], i4[45]};
	mux8to1x2 m44 (.in0(in44), .sel0(s), .in1(in45), .sel1(s), .out(o[45:44]));
	assign in46[3:0] = {i3[46], i2[46], i1[46], i0[46]};
	assign in46[7:4] = {i7[46], i6[46], i5[46], i4[46]};
	assign in47[3:0] = {i3[47], i2[47], i1[47], i0[47]};
	assign in47[7:4] = {i7[47], i6[47], i5[47], i4[47]};
	mux8to1x2 m46 (.in0(in46), .sel0(s), .in1(in47), .sel1(s), .out(o[47:46]));
	assign in48[3:0] = {i3[48], i2[48], i1[48], i0[48]};
	assign in48[7:4] = {i7[48], i6[48], i5[48], i4[48]};
	assign in49[3:0] = {i3[49], i2[49], i1[49], i0[49]};
	assign in49[7:4] = {i7[49], i6[49], i5[49], i4[49]};
	mux8to1x2 m48 (.in0(in48), .sel0(s), .in1(in49), .sel1(s), .out(o[49:48]));
	assign in50[3:0] = {i3[50], i2[50], i1[50], i0[50]};
	assign in50[7:4] = {i7[50], i6[50], i5[50], i4[50]};
	assign in51[3:0] = {i3[51], i2[51], i1[51], i0[51]};
	assign in51[7:4] = {i7[51], i6[51], i5[51], i4[51]};
	mux8to1x2 m50 (.in0(in50), .sel0(s), .in1(in51), .sel1(s), .out(o[51:50]));
	assign in52[3:0] = {i3[52], i2[52], i1[52], i0[52]};
	assign in52[7:4] = {i7[52], i6[52], i5[52], i4[52]};
	assign in53[3:0] = {i3[53], i2[53], i1[53], i0[53]};
	assign in53[7:4] = {i7[53], i6[53], i5[53], i4[53]};
	mux8to1x2 m52 (.in0(in52), .sel0(s), .in1(in53), .sel1(s), .out(o[53:52]));
	assign in54[3:0] = {i3[54], i2[54], i1[54], i0[54]};
	assign in54[7:4] = {i7[54], i6[54], i5[54], i4[54]};
	assign in55[3:0] = {i3[55], i2[55], i1[55], i0[55]};
	assign in55[7:4] = {i7[55], i6[55], i5[55], i4[55]};
	mux8to1x2 m54 (.in0(in54), .sel0(s), .in1(in55), .sel1(s), .out(o[55:54]));
	assign in56[3:0] = {i3[56], i2[56], i1[56], i0[56]};
	assign in56[7:4] = {i7[56], i6[56], i5[56], i4[56]};
	assign in57[3:0] = {i3[57], i2[57], i1[57], i0[57]};
	assign in57[7:4] = {i7[57], i6[57], i5[57], i4[57]};
	mux8to1x2 m56 (.in0(in56), .sel0(s), .in1(in57), .sel1(s), .out(o[57:56]));
	assign in58[3:0] = {i3[58], i2[58], i1[58], i0[58]};
	assign in58[7:4] = {i7[58], i6[58], i5[58], i4[58]};
	assign in59[3:0] = {i3[59], i2[59], i1[59], i0[59]};
	assign in59[7:4] = {i7[59], i6[59], i5[59], i4[59]};
	mux8to1x2 m58 (.in0(in58), .sel0(s), .in1(in59), .sel1(s), .out(o[59:58]));
	assign in60[3:0] = {i3[60], i2[60], i1[60], i0[60]};
	assign in60[7:4] = {i7[60], i6[60], i5[60], i4[60]};
	assign in61[3:0] = {i3[61], i2[61], i1[61], i0[61]};
	assign in61[7:4] = {i7[61], i6[61], i5[61], i4[61]};
	mux8to1x2 m60 (.in0(in60), .sel0(s), .in1(in61), .sel1(s), .out(o[61:60]));
	assign in62[3:0] = {i3[62], i2[62], i1[62], i0[62]};
	assign in62[7:4] = {i7[62], i6[62], i5[62], i4[62]};
	assign in63[3:0] = {i3[63], i2[63], i1[63], i0[63]};
	assign in63[7:4] = {i7[63], i6[63], i5[63], i4[63]};
	mux8to1x2 m62 (.in0(in62), .sel0(s), .in1(in63), .sel1(s), .out(o[63:62]));
	assign in64[3:0] = {i3[64], i2[64], i1[64], i0[64]};
	assign in64[7:4] = {i7[64], i6[64], i5[64], i4[64]};
	assign in65[3:0] = {i3[65], i2[65], i1[65], i0[65]};
	assign in65[7:4] = {i7[65], i6[65], i5[65], i4[65]};
	mux8to1x2 m64 (.in0(in64), .sel0(s), .in1(in65), .sel1(s), .out(o[65:64]));
	assign in66[3:0] = {i3[66], i2[66], i1[66], i0[66]};
	assign in66[7:4] = {i7[66], i6[66], i5[66], i4[66]};
	assign in67[3:0] = {i3[67], i2[67], i1[67], i0[67]};
	assign in67[7:4] = {i7[67], i6[67], i5[67], i4[67]};
	mux8to1x2 m66 (.in0(in66), .sel0(s), .in1(in67), .sel1(s), .out(o[67:66]));
	assign in68[3:0] = {i3[68], i2[68], i1[68], i0[68]};
	assign in68[7:4] = {i7[68], i6[68], i5[68], i4[68]};
	assign in69[3:0] = {i3[69], i2[69], i1[69], i0[69]};
	assign in69[7:4] = {i7[69], i6[69], i5[69], i4[69]};
	mux8to1x2 m68 (.in0(in68), .sel0(s), .in1(in69), .sel1(s), .out(o[69:68]));
	assign in70[3:0] = {i3[70], i2[70], i1[70], i0[70]};
	assign in70[7:4] = {i7[70], i6[70], i5[70], i4[70]};
	assign in71[3:0] = {i3[71], i2[71], i1[71], i0[71]};
	assign in71[7:4] = {i7[71], i6[71], i5[71], i4[71]};
	mux8to1x2 m70 (.in0(in70), .sel0(s), .in1(in71), .sel1(s), .out(o[71:70]));
	assign in72[3:0] = {i3[72], i2[72], i1[72], i0[72]};
	assign in72[7:4] = {i7[72], i6[72], i5[72], i4[72]};
	assign in73[3:0] = {i3[73], i2[73], i1[73], i0[73]};
	assign in73[7:4] = {i7[73], i6[73], i5[73], i4[73]};
	mux8to1x2 m72 (.in0(in72), .sel0(s), .in1(in73), .sel1(s), .out(o[73:72]));
	assign in74[3:0] = {i3[74], i2[74], i1[74], i0[74]};
	assign in74[7:4] = {i7[74], i6[74], i5[74], i4[74]};
	assign in75[3:0] = {i3[75], i2[75], i1[75], i0[75]};
	assign in75[7:4] = {i7[75], i6[75], i5[75], i4[75]};
	mux8to1x2 m74 (.in0(in74), .sel0(s), .in1(in75), .sel1(s), .out(o[75:74]));
	assign in76[3:0] = {i3[76], i2[76], i1[76], i0[76]};
	assign in76[7:4] = {i7[76], i6[76], i5[76], i4[76]};
	assign in77[3:0] = {i3[77], i2[77], i1[77], i0[77]};
	assign in77[7:4] = {i7[77], i6[77], i5[77], i4[77]};
	mux8to1x2 m76 (.in0(in76), .sel0(s), .in1(in77), .sel1(s), .out(o[77:76]));
	assign in78[3:0] = {i3[78], i2[78], i1[78], i0[78]};
	assign in78[7:4] = {i7[78], i6[78], i5[78], i4[78]};
	assign in79[3:0] = {i3[79], i2[79], i1[79], i0[79]};
	assign in79[7:4] = {i7[79], i6[79], i5[79], i4[79]};
	mux8to1x2 m78 (.in0(in78), .sel0(s), .in1(in79), .sel1(s), .out(o[79:78]));
	assign in80[3:0] = {i3[80], i2[80], i1[80], i0[80]};
	assign in80[7:4] = {i7[80], i6[80], i5[80], i4[80]};
	assign in81[3:0] = {i3[81], i2[81], i1[81], i0[81]};
	assign in81[7:4] = {i7[81], i6[81], i5[81], i4[81]};
	mux8to1x2 m80 (.in0(in80), .sel0(s), .in1(in81), .sel1(s), .out(o[81:80]));
	assign in82[3:0] = {i3[82], i2[82], i1[82], i0[82]};
	assign in82[7:4] = {i7[82], i6[82], i5[82], i4[82]};
	assign in83[3:0] = {i3[83], i2[83], i1[83], i0[83]};
	assign in83[7:4] = {i7[83], i6[83], i5[83], i4[83]};
	mux8to1x2 m82 (.in0(in82), .sel0(s), .in1(in83), .sel1(s), .out(o[83:82]));
	assign in84[3:0] = {i3[84], i2[84], i1[84], i0[84]};
	assign in84[7:4] = {i7[84], i6[84], i5[84], i4[84]};
	assign in85[3:0] = {i3[85], i2[85], i1[85], i0[85]};
	assign in85[7:4] = {i7[85], i6[85], i5[85], i4[85]};
	mux8to1x2 m84 (.in0(in84), .sel0(s), .in1(in85), .sel1(s), .out(o[85:84]));
	assign in86[3:0] = {i3[86], i2[86], i1[86], i0[86]};
	assign in86[7:4] = {i7[86], i6[86], i5[86], i4[86]};
	assign in87[3:0] = {i3[87], i2[87], i1[87], i0[87]};
	assign in87[7:4] = {i7[87], i6[87], i5[87], i4[87]};
	mux8to1x2 m86 (.in0(in86), .sel0(s), .in1(in87), .sel1(s), .out(o[87:86]));
	assign in88[3:0] = {i3[88], i2[88], i1[88], i0[88]};
	assign in88[7:4] = {i7[88], i6[88], i5[88], i4[88]};
	assign in89[3:0] = {i3[89], i2[89], i1[89], i0[89]};
	assign in89[7:4] = {i7[89], i6[89], i5[89], i4[89]};
	mux8to1x2 m88 (.in0(in88), .sel0(s), .in1(in89), .sel1(s), .out(o[89:88]));
	assign in90[3:0] = {i3[90], i2[90], i1[90], i0[90]};
	assign in90[7:4] = {i7[90], i6[90], i5[90], i4[90]};
	assign in91[3:0] = {i3[91], i2[91], i1[91], i0[91]};
	assign in91[7:4] = {i7[91], i6[91], i5[91], i4[91]};
	mux8to1x2 m90 (.in0(in90), .sel0(s), .in1(in91), .sel1(s), .out(o[91:90]));
	assign in92[3:0] = {i3[92], i2[92], i1[92], i0[92]};
	assign in92[7:4] = {i7[92], i6[92], i5[92], i4[92]};
	assign in93[3:0] = {i3[93], i2[93], i1[93], i0[93]};
	assign in93[7:4] = {i7[93], i6[93], i5[93], i4[93]};
	mux8to1x2 m92 (.in0(in92), .sel0(s), .in1(in93), .sel1(s), .out(o[93:92]));
	assign in94[3:0] = {i3[94], i2[94], i1[94], i0[94]};
	assign in94[7:4] = {i7[94], i6[94], i5[94], i4[94]};
	assign in95[3:0] = {i3[95], i2[95], i1[95], i0[95]};
	assign in95[7:4] = {i7[95], i6[95], i5[95], i4[95]};
	mux8to1x2 m94 (.in0(in94), .sel0(s), .in1(in95), .sel1(s), .out(o[95:94]));
	assign in96[3:0] = {i3[96], i2[96], i1[96], i0[96]};
	assign in96[7:4] = {i7[96], i6[96], i5[96], i4[96]};
	assign in97[3:0] = {i3[97], i2[97], i1[97], i0[97]};
	assign in97[7:4] = {i7[97], i6[97], i5[97], i4[97]};
	mux8to1x2 m96 (.in0(in96), .sel0(s), .in1(in97), .sel1(s), .out(o[97:96]));
	assign in98[3:0] = {i3[98], i2[98], i1[98], i0[98]};
	assign in98[7:4] = {i7[98], i6[98], i5[98], i4[98]};
	assign in99[3:0] = {i3[99], i2[99], i1[99], i0[99]};
	assign in99[7:4] = {i7[99], i6[99], i5[99], i4[99]};
	mux8to1x2 m98 (.in0(in98), .sel0(s), .in1(in99), .sel1(s), .out(o[99:98]));
	assign in100[3:0] = {i3[100], i2[100], i1[100], i0[100]};
	assign in100[7:4] = {i7[100], i6[100], i5[100], i4[100]};
	assign in101[3:0] = {i3[101], i2[101], i1[101], i0[101]};
	assign in101[7:4] = {i7[101], i6[101], i5[101], i4[101]};
	mux8to1x2 m100 (.in0(in100), .sel0(s), .in1(in101), .sel1(s), .out(o[101:100]));
	assign in102[3:0] = {i3[102], i2[102], i1[102], i0[102]};
	assign in102[7:4] = {i7[102], i6[102], i5[102], i4[102]};
	assign in103[3:0] = {i3[103], i2[103], i1[103], i0[103]};
	assign in103[7:4] = {i7[103], i6[103], i5[103], i4[103]};
	mux8to1x2 m102 (.in0(in102), .sel0(s), .in1(in103), .sel1(s), .out(o[103:102]));
	assign in104[3:0] = {i3[104], i2[104], i1[104], i0[104]};
	assign in104[7:4] = {i7[104], i6[104], i5[104], i4[104]};
	assign in105[3:0] = {i3[105], i2[105], i1[105], i0[105]};
	assign in105[7:4] = {i7[105], i6[105], i5[105], i4[105]};
	mux8to1x2 m104 (.in0(in104), .sel0(s), .in1(in105), .sel1(s), .out(o[105:104]));
	assign in106[3:0] = {i3[106], i2[106], i1[106], i0[106]};
	assign in106[7:4] = {i7[106], i6[106], i5[106], i4[106]};
	assign in107[3:0] = {i3[107], i2[107], i1[107], i0[107]};
	assign in107[7:4] = {i7[107], i6[107], i5[107], i4[107]};
	mux8to1x2 m106 (.in0(in106), .sel0(s), .in1(in107), .sel1(s), .out(o[107:106]));
	assign in108[3:0] = {i3[108], i2[108], i1[108], i0[108]};
	assign in108[7:4] = {i7[108], i6[108], i5[108], i4[108]};
	assign in109[3:0] = {i3[109], i2[109], i1[109], i0[109]};
	assign in109[7:4] = {i7[109], i6[109], i5[109], i4[109]};
	mux8to1x2 m108 (.in0(in108), .sel0(s), .in1(in109), .sel1(s), .out(o[109:108]));
endmodule

// macexp MUX8 12
// macexp $size 96
// macexp $instance
// macexp s
// macexp i0
// macexp i1
// macexp i2
// macexp i3
// macexp i4
// macexp i5
// macexp i6
// macexp i7
// macexp o

module mux8_96 ( s, i0, i1, i2, i3, i4, i5, i6, i7, o );
	// synthesis attribute keep_hierarchy mux8_96 "true";
	input  [2:0] s;
	input  [95:0] i0, i1, i2, i3, i4, i5, i6, i7;
	output [95:0] o;
	wire [7:0] in0;
	wire [7:0] in1;
	wire [7:0] in2;
	wire [7:0] in3;
	wire [7:0] in4;
	wire [7:0] in5;
	wire [7:0] in6;
	wire [7:0] in7;
	wire [7:0] in8;
	wire [7:0] in9;
	wire [7:0] in10;
	wire [7:0] in11;
	wire [7:0] in12;
	wire [7:0] in13;
	wire [7:0] in14;
	wire [7:0] in15;
	wire [7:0] in16;
	wire [7:0] in17;
	wire [7:0] in18;
	wire [7:0] in19;
	wire [7:0] in20;
	wire [7:0] in21;
	wire [7:0] in22;
	wire [7:0] in23;
	wire [7:0] in24;
	wire [7:0] in25;
	wire [7:0] in26;
	wire [7:0] in27;
	wire [7:0] in28;
	wire [7:0] in29;
	wire [7:0] in30;
	wire [7:0] in31;
	wire [7:0] in32;
	wire [7:0] in33;
	wire [7:0] in34;
	wire [7:0] in35;
	wire [7:0] in36;
	wire [7:0] in37;
	wire [7:0] in38;
	wire [7:0] in39;
	wire [7:0] in40;
	wire [7:0] in41;
	wire [7:0] in42;
	wire [7:0] in43;
	wire [7:0] in44;
	wire [7:0] in45;
	wire [7:0] in46;
	wire [7:0] in47;
	wire [7:0] in48;
	wire [7:0] in49;
	wire [7:0] in50;
	wire [7:0] in51;
	wire [7:0] in52;
	wire [7:0] in53;
	wire [7:0] in54;
	wire [7:0] in55;
	wire [7:0] in56;
	wire [7:0] in57;
	wire [7:0] in58;
	wire [7:0] in59;
	wire [7:0] in60;
	wire [7:0] in61;
	wire [7:0] in62;
	wire [7:0] in63;
	wire [7:0] in64;
	wire [7:0] in65;
	wire [7:0] in66;
	wire [7:0] in67;
	wire [7:0] in68;
	wire [7:0] in69;
	wire [7:0] in70;
	wire [7:0] in71;
	wire [7:0] in72;
	wire [7:0] in73;
	wire [7:0] in74;
	wire [7:0] in75;
	wire [7:0] in76;
	wire [7:0] in77;
	wire [7:0] in78;
	wire [7:0] in79;
	wire [7:0] in80;
	wire [7:0] in81;
	wire [7:0] in82;
	wire [7:0] in83;
	wire [7:0] in84;
	wire [7:0] in85;
	wire [7:0] in86;
	wire [7:0] in87;
	wire [7:0] in88;
	wire [7:0] in89;
	wire [7:0] in90;
	wire [7:0] in91;
	wire [7:0] in92;
	wire [7:0] in93;
	wire [7:0] in94;
	wire [7:0] in95;
	assign in0[3:0] = {i3[0], i2[0], i1[0], i0[0]};
	assign in0[7:4] = {i7[0], i6[0], i5[0], i4[0]};
	assign in1[3:0] = {i3[1], i2[1], i1[1], i0[1]};
	assign in1[7:4] = {i7[1], i6[1], i5[1], i4[1]};
	mux8to1x2 m0 (.in0(in0), .sel0(s), .in1(in1), .sel1(s), .out(o[1:0]));
	assign in2[3:0] = {i3[2], i2[2], i1[2], i0[2]};
	assign in2[7:4] = {i7[2], i6[2], i5[2], i4[2]};
	assign in3[3:0] = {i3[3], i2[3], i1[3], i0[3]};
	assign in3[7:4] = {i7[3], i6[3], i5[3], i4[3]};
	mux8to1x2 m2 (.in0(in2), .sel0(s), .in1(in3), .sel1(s), .out(o[3:2]));
	assign in4[3:0] = {i3[4], i2[4], i1[4], i0[4]};
	assign in4[7:4] = {i7[4], i6[4], i5[4], i4[4]};
	assign in5[3:0] = {i3[5], i2[5], i1[5], i0[5]};
	assign in5[7:4] = {i7[5], i6[5], i5[5], i4[5]};
	mux8to1x2 m4 (.in0(in4), .sel0(s), .in1(in5), .sel1(s), .out(o[5:4]));
	assign in6[3:0] = {i3[6], i2[6], i1[6], i0[6]};
	assign in6[7:4] = {i7[6], i6[6], i5[6], i4[6]};
	assign in7[3:0] = {i3[7], i2[7], i1[7], i0[7]};
	assign in7[7:4] = {i7[7], i6[7], i5[7], i4[7]};
	mux8to1x2 m6 (.in0(in6), .sel0(s), .in1(in7), .sel1(s), .out(o[7:6]));
	assign in8[3:0] = {i3[8], i2[8], i1[8], i0[8]};
	assign in8[7:4] = {i7[8], i6[8], i5[8], i4[8]};
	assign in9[3:0] = {i3[9], i2[9], i1[9], i0[9]};
	assign in9[7:4] = {i7[9], i6[9], i5[9], i4[9]};
	mux8to1x2 m8 (.in0(in8), .sel0(s), .in1(in9), .sel1(s), .out(o[9:8]));
	assign in10[3:0] = {i3[10], i2[10], i1[10], i0[10]};
	assign in10[7:4] = {i7[10], i6[10], i5[10], i4[10]};
	assign in11[3:0] = {i3[11], i2[11], i1[11], i0[11]};
	assign in11[7:4] = {i7[11], i6[11], i5[11], i4[11]};
	mux8to1x2 m10 (.in0(in10), .sel0(s), .in1(in11), .sel1(s), .out(o[11:10]));
	assign in12[3:0] = {i3[12], i2[12], i1[12], i0[12]};
	assign in12[7:4] = {i7[12], i6[12], i5[12], i4[12]};
	assign in13[3:0] = {i3[13], i2[13], i1[13], i0[13]};
	assign in13[7:4] = {i7[13], i6[13], i5[13], i4[13]};
	mux8to1x2 m12 (.in0(in12), .sel0(s), .in1(in13), .sel1(s), .out(o[13:12]));
	assign in14[3:0] = {i3[14], i2[14], i1[14], i0[14]};
	assign in14[7:4] = {i7[14], i6[14], i5[14], i4[14]};
	assign in15[3:0] = {i3[15], i2[15], i1[15], i0[15]};
	assign in15[7:4] = {i7[15], i6[15], i5[15], i4[15]};
	mux8to1x2 m14 (.in0(in14), .sel0(s), .in1(in15), .sel1(s), .out(o[15:14]));
	assign in16[3:0] = {i3[16], i2[16], i1[16], i0[16]};
	assign in16[7:4] = {i7[16], i6[16], i5[16], i4[16]};
	assign in17[3:0] = {i3[17], i2[17], i1[17], i0[17]};
	assign in17[7:4] = {i7[17], i6[17], i5[17], i4[17]};
	mux8to1x2 m16 (.in0(in16), .sel0(s), .in1(in17), .sel1(s), .out(o[17:16]));
	assign in18[3:0] = {i3[18], i2[18], i1[18], i0[18]};
	assign in18[7:4] = {i7[18], i6[18], i5[18], i4[18]};
	assign in19[3:0] = {i3[19], i2[19], i1[19], i0[19]};
	assign in19[7:4] = {i7[19], i6[19], i5[19], i4[19]};
	mux8to1x2 m18 (.in0(in18), .sel0(s), .in1(in19), .sel1(s), .out(o[19:18]));
	assign in20[3:0] = {i3[20], i2[20], i1[20], i0[20]};
	assign in20[7:4] = {i7[20], i6[20], i5[20], i4[20]};
	assign in21[3:0] = {i3[21], i2[21], i1[21], i0[21]};
	assign in21[7:4] = {i7[21], i6[21], i5[21], i4[21]};
	mux8to1x2 m20 (.in0(in20), .sel0(s), .in1(in21), .sel1(s), .out(o[21:20]));
	assign in22[3:0] = {i3[22], i2[22], i1[22], i0[22]};
	assign in22[7:4] = {i7[22], i6[22], i5[22], i4[22]};
	assign in23[3:0] = {i3[23], i2[23], i1[23], i0[23]};
	assign in23[7:4] = {i7[23], i6[23], i5[23], i4[23]};
	mux8to1x2 m22 (.in0(in22), .sel0(s), .in1(in23), .sel1(s), .out(o[23:22]));
	assign in24[3:0] = {i3[24], i2[24], i1[24], i0[24]};
	assign in24[7:4] = {i7[24], i6[24], i5[24], i4[24]};
	assign in25[3:0] = {i3[25], i2[25], i1[25], i0[25]};
	assign in25[7:4] = {i7[25], i6[25], i5[25], i4[25]};
	mux8to1x2 m24 (.in0(in24), .sel0(s), .in1(in25), .sel1(s), .out(o[25:24]));
	assign in26[3:0] = {i3[26], i2[26], i1[26], i0[26]};
	assign in26[7:4] = {i7[26], i6[26], i5[26], i4[26]};
	assign in27[3:0] = {i3[27], i2[27], i1[27], i0[27]};
	assign in27[7:4] = {i7[27], i6[27], i5[27], i4[27]};
	mux8to1x2 m26 (.in0(in26), .sel0(s), .in1(in27), .sel1(s), .out(o[27:26]));
	assign in28[3:0] = {i3[28], i2[28], i1[28], i0[28]};
	assign in28[7:4] = {i7[28], i6[28], i5[28], i4[28]};
	assign in29[3:0] = {i3[29], i2[29], i1[29], i0[29]};
	assign in29[7:4] = {i7[29], i6[29], i5[29], i4[29]};
	mux8to1x2 m28 (.in0(in28), .sel0(s), .in1(in29), .sel1(s), .out(o[29:28]));
	assign in30[3:0] = {i3[30], i2[30], i1[30], i0[30]};
	assign in30[7:4] = {i7[30], i6[30], i5[30], i4[30]};
	assign in31[3:0] = {i3[31], i2[31], i1[31], i0[31]};
	assign in31[7:4] = {i7[31], i6[31], i5[31], i4[31]};
	mux8to1x2 m30 (.in0(in30), .sel0(s), .in1(in31), .sel1(s), .out(o[31:30]));
	assign in32[3:0] = {i3[32], i2[32], i1[32], i0[32]};
	assign in32[7:4] = {i7[32], i6[32], i5[32], i4[32]};
	assign in33[3:0] = {i3[33], i2[33], i1[33], i0[33]};
	assign in33[7:4] = {i7[33], i6[33], i5[33], i4[33]};
	mux8to1x2 m32 (.in0(in32), .sel0(s), .in1(in33), .sel1(s), .out(o[33:32]));
	assign in34[3:0] = {i3[34], i2[34], i1[34], i0[34]};
	assign in34[7:4] = {i7[34], i6[34], i5[34], i4[34]};
	assign in35[3:0] = {i3[35], i2[35], i1[35], i0[35]};
	assign in35[7:4] = {i7[35], i6[35], i5[35], i4[35]};
	mux8to1x2 m34 (.in0(in34), .sel0(s), .in1(in35), .sel1(s), .out(o[35:34]));
	assign in36[3:0] = {i3[36], i2[36], i1[36], i0[36]};
	assign in36[7:4] = {i7[36], i6[36], i5[36], i4[36]};
	assign in37[3:0] = {i3[37], i2[37], i1[37], i0[37]};
	assign in37[7:4] = {i7[37], i6[37], i5[37], i4[37]};
	mux8to1x2 m36 (.in0(in36), .sel0(s), .in1(in37), .sel1(s), .out(o[37:36]));
	assign in38[3:0] = {i3[38], i2[38], i1[38], i0[38]};
	assign in38[7:4] = {i7[38], i6[38], i5[38], i4[38]};
	assign in39[3:0] = {i3[39], i2[39], i1[39], i0[39]};
	assign in39[7:4] = {i7[39], i6[39], i5[39], i4[39]};
	mux8to1x2 m38 (.in0(in38), .sel0(s), .in1(in39), .sel1(s), .out(o[39:38]));
	assign in40[3:0] = {i3[40], i2[40], i1[40], i0[40]};
	assign in40[7:4] = {i7[40], i6[40], i5[40], i4[40]};
	assign in41[3:0] = {i3[41], i2[41], i1[41], i0[41]};
	assign in41[7:4] = {i7[41], i6[41], i5[41], i4[41]};
	mux8to1x2 m40 (.in0(in40), .sel0(s), .in1(in41), .sel1(s), .out(o[41:40]));
	assign in42[3:0] = {i3[42], i2[42], i1[42], i0[42]};
	assign in42[7:4] = {i7[42], i6[42], i5[42], i4[42]};
	assign in43[3:0] = {i3[43], i2[43], i1[43], i0[43]};
	assign in43[7:4] = {i7[43], i6[43], i5[43], i4[43]};
	mux8to1x2 m42 (.in0(in42), .sel0(s), .in1(in43), .sel1(s), .out(o[43:42]));
	assign in44[3:0] = {i3[44], i2[44], i1[44], i0[44]};
	assign in44[7:4] = {i7[44], i6[44], i5[44], i4[44]};
	assign in45[3:0] = {i3[45], i2[45], i1[45], i0[45]};
	assign in45[7:4] = {i7[45], i6[45], i5[45], i4[45]};
	mux8to1x2 m44 (.in0(in44), .sel0(s), .in1(in45), .sel1(s), .out(o[45:44]));
	assign in46[3:0] = {i3[46], i2[46], i1[46], i0[46]};
	assign in46[7:4] = {i7[46], i6[46], i5[46], i4[46]};
	assign in47[3:0] = {i3[47], i2[47], i1[47], i0[47]};
	assign in47[7:4] = {i7[47], i6[47], i5[47], i4[47]};
	mux8to1x2 m46 (.in0(in46), .sel0(s), .in1(in47), .sel1(s), .out(o[47:46]));
	assign in48[3:0] = {i3[48], i2[48], i1[48], i0[48]};
	assign in48[7:4] = {i7[48], i6[48], i5[48], i4[48]};
	assign in49[3:0] = {i3[49], i2[49], i1[49], i0[49]};
	assign in49[7:4] = {i7[49], i6[49], i5[49], i4[49]};
	mux8to1x2 m48 (.in0(in48), .sel0(s), .in1(in49), .sel1(s), .out(o[49:48]));
	assign in50[3:0] = {i3[50], i2[50], i1[50], i0[50]};
	assign in50[7:4] = {i7[50], i6[50], i5[50], i4[50]};
	assign in51[3:0] = {i3[51], i2[51], i1[51], i0[51]};
	assign in51[7:4] = {i7[51], i6[51], i5[51], i4[51]};
	mux8to1x2 m50 (.in0(in50), .sel0(s), .in1(in51), .sel1(s), .out(o[51:50]));
	assign in52[3:0] = {i3[52], i2[52], i1[52], i0[52]};
	assign in52[7:4] = {i7[52], i6[52], i5[52], i4[52]};
	assign in53[3:0] = {i3[53], i2[53], i1[53], i0[53]};
	assign in53[7:4] = {i7[53], i6[53], i5[53], i4[53]};
	mux8to1x2 m52 (.in0(in52), .sel0(s), .in1(in53), .sel1(s), .out(o[53:52]));
	assign in54[3:0] = {i3[54], i2[54], i1[54], i0[54]};
	assign in54[7:4] = {i7[54], i6[54], i5[54], i4[54]};
	assign in55[3:0] = {i3[55], i2[55], i1[55], i0[55]};
	assign in55[7:4] = {i7[55], i6[55], i5[55], i4[55]};
	mux8to1x2 m54 (.in0(in54), .sel0(s), .in1(in55), .sel1(s), .out(o[55:54]));
	assign in56[3:0] = {i3[56], i2[56], i1[56], i0[56]};
	assign in56[7:4] = {i7[56], i6[56], i5[56], i4[56]};
	assign in57[3:0] = {i3[57], i2[57], i1[57], i0[57]};
	assign in57[7:4] = {i7[57], i6[57], i5[57], i4[57]};
	mux8to1x2 m56 (.in0(in56), .sel0(s), .in1(in57), .sel1(s), .out(o[57:56]));
	assign in58[3:0] = {i3[58], i2[58], i1[58], i0[58]};
	assign in58[7:4] = {i7[58], i6[58], i5[58], i4[58]};
	assign in59[3:0] = {i3[59], i2[59], i1[59], i0[59]};
	assign in59[7:4] = {i7[59], i6[59], i5[59], i4[59]};
	mux8to1x2 m58 (.in0(in58), .sel0(s), .in1(in59), .sel1(s), .out(o[59:58]));
	assign in60[3:0] = {i3[60], i2[60], i1[60], i0[60]};
	assign in60[7:4] = {i7[60], i6[60], i5[60], i4[60]};
	assign in61[3:0] = {i3[61], i2[61], i1[61], i0[61]};
	assign in61[7:4] = {i7[61], i6[61], i5[61], i4[61]};
	mux8to1x2 m60 (.in0(in60), .sel0(s), .in1(in61), .sel1(s), .out(o[61:60]));
	assign in62[3:0] = {i3[62], i2[62], i1[62], i0[62]};
	assign in62[7:4] = {i7[62], i6[62], i5[62], i4[62]};
	assign in63[3:0] = {i3[63], i2[63], i1[63], i0[63]};
	assign in63[7:4] = {i7[63], i6[63], i5[63], i4[63]};
	mux8to1x2 m62 (.in0(in62), .sel0(s), .in1(in63), .sel1(s), .out(o[63:62]));
	assign in64[3:0] = {i3[64], i2[64], i1[64], i0[64]};
	assign in64[7:4] = {i7[64], i6[64], i5[64], i4[64]};
	assign in65[3:0] = {i3[65], i2[65], i1[65], i0[65]};
	assign in65[7:4] = {i7[65], i6[65], i5[65], i4[65]};
	mux8to1x2 m64 (.in0(in64), .sel0(s), .in1(in65), .sel1(s), .out(o[65:64]));
	assign in66[3:0] = {i3[66], i2[66], i1[66], i0[66]};
	assign in66[7:4] = {i7[66], i6[66], i5[66], i4[66]};
	assign in67[3:0] = {i3[67], i2[67], i1[67], i0[67]};
	assign in67[7:4] = {i7[67], i6[67], i5[67], i4[67]};
	mux8to1x2 m66 (.in0(in66), .sel0(s), .in1(in67), .sel1(s), .out(o[67:66]));
	assign in68[3:0] = {i3[68], i2[68], i1[68], i0[68]};
	assign in68[7:4] = {i7[68], i6[68], i5[68], i4[68]};
	assign in69[3:0] = {i3[69], i2[69], i1[69], i0[69]};
	assign in69[7:4] = {i7[69], i6[69], i5[69], i4[69]};
	mux8to1x2 m68 (.in0(in68), .sel0(s), .in1(in69), .sel1(s), .out(o[69:68]));
	assign in70[3:0] = {i3[70], i2[70], i1[70], i0[70]};
	assign in70[7:4] = {i7[70], i6[70], i5[70], i4[70]};
	assign in71[3:0] = {i3[71], i2[71], i1[71], i0[71]};
	assign in71[7:4] = {i7[71], i6[71], i5[71], i4[71]};
	mux8to1x2 m70 (.in0(in70), .sel0(s), .in1(in71), .sel1(s), .out(o[71:70]));
	assign in72[3:0] = {i3[72], i2[72], i1[72], i0[72]};
	assign in72[7:4] = {i7[72], i6[72], i5[72], i4[72]};
	assign in73[3:0] = {i3[73], i2[73], i1[73], i0[73]};
	assign in73[7:4] = {i7[73], i6[73], i5[73], i4[73]};
	mux8to1x2 m72 (.in0(in72), .sel0(s), .in1(in73), .sel1(s), .out(o[73:72]));
	assign in74[3:0] = {i3[74], i2[74], i1[74], i0[74]};
	assign in74[7:4] = {i7[74], i6[74], i5[74], i4[74]};
	assign in75[3:0] = {i3[75], i2[75], i1[75], i0[75]};
	assign in75[7:4] = {i7[75], i6[75], i5[75], i4[75]};
	mux8to1x2 m74 (.in0(in74), .sel0(s), .in1(in75), .sel1(s), .out(o[75:74]));
	assign in76[3:0] = {i3[76], i2[76], i1[76], i0[76]};
	assign in76[7:4] = {i7[76], i6[76], i5[76], i4[76]};
	assign in77[3:0] = {i3[77], i2[77], i1[77], i0[77]};
	assign in77[7:4] = {i7[77], i6[77], i5[77], i4[77]};
	mux8to1x2 m76 (.in0(in76), .sel0(s), .in1(in77), .sel1(s), .out(o[77:76]));
	assign in78[3:0] = {i3[78], i2[78], i1[78], i0[78]};
	assign in78[7:4] = {i7[78], i6[78], i5[78], i4[78]};
	assign in79[3:0] = {i3[79], i2[79], i1[79], i0[79]};
	assign in79[7:4] = {i7[79], i6[79], i5[79], i4[79]};
	mux8to1x2 m78 (.in0(in78), .sel0(s), .in1(in79), .sel1(s), .out(o[79:78]));
	assign in80[3:0] = {i3[80], i2[80], i1[80], i0[80]};
	assign in80[7:4] = {i7[80], i6[80], i5[80], i4[80]};
	assign in81[3:0] = {i3[81], i2[81], i1[81], i0[81]};
	assign in81[7:4] = {i7[81], i6[81], i5[81], i4[81]};
	mux8to1x2 m80 (.in0(in80), .sel0(s), .in1(in81), .sel1(s), .out(o[81:80]));
	assign in82[3:0] = {i3[82], i2[82], i1[82], i0[82]};
	assign in82[7:4] = {i7[82], i6[82], i5[82], i4[82]};
	assign in83[3:0] = {i3[83], i2[83], i1[83], i0[83]};
	assign in83[7:4] = {i7[83], i6[83], i5[83], i4[83]};
	mux8to1x2 m82 (.in0(in82), .sel0(s), .in1(in83), .sel1(s), .out(o[83:82]));
	assign in84[3:0] = {i3[84], i2[84], i1[84], i0[84]};
	assign in84[7:4] = {i7[84], i6[84], i5[84], i4[84]};
	assign in85[3:0] = {i3[85], i2[85], i1[85], i0[85]};
	assign in85[7:4] = {i7[85], i6[85], i5[85], i4[85]};
	mux8to1x2 m84 (.in0(in84), .sel0(s), .in1(in85), .sel1(s), .out(o[85:84]));
	assign in86[3:0] = {i3[86], i2[86], i1[86], i0[86]};
	assign in86[7:4] = {i7[86], i6[86], i5[86], i4[86]};
	assign in87[3:0] = {i3[87], i2[87], i1[87], i0[87]};
	assign in87[7:4] = {i7[87], i6[87], i5[87], i4[87]};
	mux8to1x2 m86 (.in0(in86), .sel0(s), .in1(in87), .sel1(s), .out(o[87:86]));
	assign in88[3:0] = {i3[88], i2[88], i1[88], i0[88]};
	assign in88[7:4] = {i7[88], i6[88], i5[88], i4[88]};
	assign in89[3:0] = {i3[89], i2[89], i1[89], i0[89]};
	assign in89[7:4] = {i7[89], i6[89], i5[89], i4[89]};
	mux8to1x2 m88 (.in0(in88), .sel0(s), .in1(in89), .sel1(s), .out(o[89:88]));
	assign in90[3:0] = {i3[90], i2[90], i1[90], i0[90]};
	assign in90[7:4] = {i7[90], i6[90], i5[90], i4[90]};
	assign in91[3:0] = {i3[91], i2[91], i1[91], i0[91]};
	assign in91[7:4] = {i7[91], i6[91], i5[91], i4[91]};
	mux8to1x2 m90 (.in0(in90), .sel0(s), .in1(in91), .sel1(s), .out(o[91:90]));
	assign in92[3:0] = {i3[92], i2[92], i1[92], i0[92]};
	assign in92[7:4] = {i7[92], i6[92], i5[92], i4[92]};
	assign in93[3:0] = {i3[93], i2[93], i1[93], i0[93]};
	assign in93[7:4] = {i7[93], i6[93], i5[93], i4[93]};
	mux8to1x2 m92 (.in0(in92), .sel0(s), .in1(in93), .sel1(s), .out(o[93:92]));
	assign in94[3:0] = {i3[94], i2[94], i1[94], i0[94]};
	assign in94[7:4] = {i7[94], i6[94], i5[94], i4[94]};
	assign in95[3:0] = {i3[95], i2[95], i1[95], i0[95]};
	assign in95[7:4] = {i7[95], i6[95], i5[95], i4[95]};
	mux8to1x2 m94 (.in0(in94), .sel0(s), .in1(in95), .sel1(s), .out(o[95:94]));
endmodule

// macexp DFF 5
// macexp $size 32
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_32 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_32 "true";
	input clk;
	input [31:0] d;
	output [31:0] q;
	reg [31:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFFS 6
// macexp $size 1
// macexp $instance
// macexp clk
// macexp set
// macexp d
// macexp q

module dffs_1 ( clk, set, d, q );
	// synthesis attribute keep_hierarchy dffs_1 "true";
	input clk;
	input set;
	input d;
	output q;
	reg q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: set still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(set),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (set)
	q <= ~(1'b0);
	else
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 8
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_8 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_8 "true";
	input clk;
	input reset;
	input [7:0] d;
	output [7:0] q;
	reg [7:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 8'b0;
	else
	q <= d;
	end
endmodule

// macexp DFFSI 7
// macexp $size 9
// macexp $instance
// macexp clk
// macexp reset
// macexp init
// macexp d
// macexp q

module dffsi_9 ( clk, reset, init, d, q );
	// synthesis attribute keep_hierarchy dffsi_9 "true";
	input clk;
	input reset;
	input [8:0] init;
	input [8:0] d;
	output [8:0] q;
	reg [8:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= init;
	else
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 256
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_256 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_256 "true";
	input clk;
	input reset;
	input [255:0] d;
	output [255:0] q;
	reg [255:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 256'b0;
	else
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 3
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_3 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_3 "true";
	input clk;
	input reset;
	input [2:0] d;
	output [2:0] q;
	reg [2:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 3'b0;
	else
	q <= d;
	end
endmodule

`endcelldefine

