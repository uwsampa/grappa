// WARNING!  This file was automatically generated by macexp.
//           Do not edit this file, any changes made will be lost.

`celldefine

// macexp SYNC2 5
// macexp $size 4
// macexp $instance
// macexp clk
// macexp d
// macexp q

module sync2_4 ( clk, d, q );
	// synthesis attribute keep_hierarchy sync2_4 "true";
	// synthesis attribute equivalent_register_removal sync2_4 "no";
	// synthesis attribute register_duplication sync2_4 "no";
	// synthesis attribute shift_extract sync2_4 "no";
	// synthesis attribute shreg_extract sync2_4 "no";
	input clk;
	input [3:0] d;
	output [3:0] q;
	// the simulation model has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles
	// synthesis attribute keep q "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg [3:0] /* synthesis syn_preserve = 1 */ q;
	reg [3:0] c_q;
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	// synthesis attribute keep meta1 "true";
	reg [3:0] /* synthesis syn_preserve = 1 */ meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [3:0] c_meta2;
	reg [3:0] meta2;
`endif
	// synopsys translate_on
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta2
`endif
	// synopsys translate_on
	) begin
	c_q = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	c_meta2 = (d ^ meta1) & $random(seed);
	c_q = c_meta2 | ((meta1 ^ meta2) & $random(seed)) |
	(d & meta1 & meta2);
	c_meta2 = c_meta2 | (d & meta1);
`endif
	// synopsys translate_on
	end
	always @(posedge clk) begin
	meta1 <= d;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta2 <= c_meta2;
`endif
	// synopsys translate_on
	q <= c_q;
	end
endmodule

// macexp SYNC2 5
// macexp $size 7
// macexp $instance
// macexp clk
// macexp d
// macexp q

module sync2_7 ( clk, d, q );
	// synthesis attribute keep_hierarchy sync2_7 "true";
	// synthesis attribute equivalent_register_removal sync2_7 "no";
	// synthesis attribute register_duplication sync2_7 "no";
	// synthesis attribute shift_extract sync2_7 "no";
	// synthesis attribute shreg_extract sync2_7 "no";
	input clk;
	input [6:0] d;
	output [6:0] q;
	// the simulation model has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles
	// synthesis attribute keep q "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg [6:0] /* synthesis syn_preserve = 1 */ q;
	reg [6:0] c_q;
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	// synthesis attribute keep meta1 "true";
	reg [6:0] /* synthesis syn_preserve = 1 */ meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [6:0] c_meta2;
	reg [6:0] meta2;
`endif
	// synopsys translate_on
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta2
`endif
	// synopsys translate_on
	) begin
	c_q = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	c_meta2 = (d ^ meta1) & $random(seed);
	c_q = c_meta2 | ((meta1 ^ meta2) & $random(seed)) |
	(d & meta1 & meta2);
	c_meta2 = c_meta2 | (d & meta1);
`endif
	// synopsys translate_on
	end
	always @(posedge clk) begin
	meta1 <= d;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta2 <= c_meta2;
`endif
	// synopsys translate_on
	q <= c_q;
	end
endmodule

// macexp SYNC2 5
// macexp $size 2
// macexp $instance
// macexp clk
// macexp d
// macexp q

module sync2_2 ( clk, d, q );
	// synthesis attribute keep_hierarchy sync2_2 "true";
	// synthesis attribute equivalent_register_removal sync2_2 "no";
	// synthesis attribute register_duplication sync2_2 "no";
	// synthesis attribute shift_extract sync2_2 "no";
	// synthesis attribute shreg_extract sync2_2 "no";
	input clk;
	input [1:0] d;
	output [1:0] q;
	// the simulation model has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles
	// synthesis attribute keep q "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg [1:0] /* synthesis syn_preserve = 1 */ q;
	reg [1:0] c_q;
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	// synthesis attribute keep meta1 "true";
	reg [1:0] /* synthesis syn_preserve = 1 */ meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [1:0] c_meta2;
	reg [1:0] meta2;
`endif
	// synopsys translate_on
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta2
`endif
	// synopsys translate_on
	) begin
	c_q = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	c_meta2 = (d ^ meta1) & $random(seed);
	c_q = c_meta2 | ((meta1 ^ meta2) & $random(seed)) |
	(d & meta1 & meta2);
	c_meta2 = c_meta2 | (d & meta1);
`endif
	// synopsys translate_on
	end
	always @(posedge clk) begin
	meta1 <= d;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta2 <= c_meta2;
`endif
	// synopsys translate_on
	q <= c_q;
	end
endmodule

// macexp MUX8 12
// macexp $size 1
// macexp $instance
// macexp s
// macexp i0
// macexp i1
// macexp i2
// macexp i3
// macexp i4
// macexp i5
// macexp i6
// macexp i7
// macexp o

module mux8_1 ( s, i0, i1, i2, i3, i4, i5, i6, i7, o );
	// synthesis attribute keep_hierarchy mux8_1 "true";
	input [2:0] s;
	input i0, i1, i2, i3, i4, i5, i6, i7;
	output o;
	wire [3:0] m0i;
	wire [3:0] m1i;
	wire m0o;
	wire m1o;
	assign m0i = {i3, i2, i1, i0};
	assign m1i = {i7, i6, i5, i4};
	assign m0o = m0i[s[1:0]];
	assign m1o = m1i[s[1:0]];
	MUXF7 m0 (.S(s[2]), .I0(m0o), .I1(m1o), .O(o));
endmodule

// macexp MUX16 20
// macexp $size 1
// macexp $instance
// macexp s
// macexp i0
// macexp i1
// macexp i2
// macexp i3
// macexp i4
// macexp i5
// macexp i6
// macexp i7
// macexp i8
// macexp i9
// macexp i10
// macexp i11
// macexp i12
// macexp i13
// macexp i14
// macexp i15
// macexp o

module mux16_1 ( s, i0, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12, i13, i14, i15, o );
	// synthesis attribute keep_hierarchy mux16_1 "true";
	input [3:0] s;
	input i0, i1, i2, i3, i4, i5, i6, i7;
	input i8, i9, i10, i11, i12, i13, i14, i15;
	output o;
	wire [7:0] m0i;
	wire [7:0] m1i;
	wire m0o;
	wire m1o;
	assign m0i = {i7, i6, i5, i4, i3, i2, i1, i0};
	assign m1i = {i15, i14, i13, i12, i11, i10, i9, i8};
	assign m0o = m0i[s[2:0]];
	assign m1o = m1i[s[2:0]];
	MUXF8 m0 (.S(s[3]), .I0(m0o), .I1(m1o), .O(o));
endmodule

// macexp DFFL 6
// macexp $size 17
// macexp $instance
// macexp clk
// macexp ld
// macexp d
// macexp q

module dffl_17 ( clk, ld, d, q );
	// synthesis attribute keep_hierarchy dffl_17 "true";
	input clk;
	input ld;
	input [16:0] d;
	output [16:0] q;
	reg [16:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	// leda XV2P_1006 off Multiple synchronous resets detected
	// leda XV2P_1007 off Multiple synchronous resets detected
	// leda G_551_1_K off Multiple synchronous resets detected
	if (ld)
	q <= d;
	// leda XV2P_1006 on Multiple synchronous resets detected
	// leda XV2P_1007 on Multiple synchronous resets detected
	// leda G_551_1_K on Multiple synchronous resets detected
	end
endmodule

// macexp ADDER 5
// macexp $size 6
// macexp $instance
// macexp i0
// macexp i1
// macexp s

module adder_6 ( i0, i1, s );
	input [5:0] i0;
	input [5:0] i1;
	output [5:0] s;
	wire [7:0] cig_s;
	reg  [7:0] cig_si;
	reg  [7:0] cig_di;
	wire [7:0] cig_co;
	wire [5:0] si;
	wire [1:0] ci;
	assign si = i0 ^ i1;
	always @ (si or i0) begin
	cig_si = 8'h0;
	cig_di = 8'h0;
	cig_si[5:0] = si;
	cig_di[5:0] = i0;
	end
	assign ci[0] = 1'b0;
	CARRY4 cry0 (
	// Outputs
	.O(cig_s[3:0]),
	.CO(cig_co[3:0]),
	// Inputs
	.S(cig_si[3:0]),
	.DI(cig_di[3:0]),
	.CI(ci[0]),
	.CYINIT(1'b0)
	);
	assign ci[1] = cig_co[3];
	CARRY4 cry1 (
	// Outputs
	.O(cig_s[7:4]),
	.CO(cig_co[7:4]),
	// Inputs
	.S(cig_si[7:4]),
	.DI(cig_di[7:4]),
	.CI(ci[1]),
	.CYINIT(1'b0)
	);
	assign s = cig_s[5:0];
endmodule

// macexp ADDSUB 6
// macexp $size 6
// macexp $instance
// macexp i0
// macexp i1
// macexp s
// macexp sub

module addsub_6 ( i0, i1, s, sub );
	input [5:0] i0;
	input [5:0] i1;
	output [5:0] s;
	input sub;
	wire [7:0] cig_s;
	reg  [7:0] cig_si;
	reg  [7:0] cig_di;
	wire [7:0] cig_co;
	wire [5:0] si;
	wire [1:0] ci;
	wire [1:0] cyinit;
	assign si = i0 ^ (sub ? ~i1 : i1);
	always @ (si or i0) begin
	cig_si = 8'h0;
	cig_di = 8'h0;
	cig_si[5:0] = si;
	cig_di[5:0] = i0;
	end
	assign ci[0] = 1'b0;
	assign cyinit[0] = sub;
	CARRY4 cry0 (
	// Outputs
	.O(cig_s[3:0]),
	.CO(cig_co[3:0]),
	// Inputs
	.S(cig_si[3:0]),
	.DI(cig_di[3:0]),
	.CI(ci[0]),
	.CYINIT(cyinit[0])
	);
	assign ci[1] = cig_co[3];
	assign cyinit[1] = 1'b0;
	CARRY4 cry1 (
	// Outputs
	.O(cig_s[7:4]),
	.CO(cig_co[7:4]),
	// Inputs
	.S(cig_si[7:4]),
	.DI(cig_di[7:4]),
	.CI(ci[1]),
	.CYINIT(cyinit[1])
	);
	assign s = cig_s[5:0];
endmodule

// macexp REGFILE 10
// macexp $depth 8
// macexp $size 1
// macexp $instance
// macexp clk_wr
// macexp wr_en
// macexp wr_addr
// macexp wr_data
// macexp clk_rd
// macexp rd_addr
// macexp rd_data

module regfile_8x1 ( clk_wr, wr_en, wr_addr, wr_data, clk_rd, rd_addr, rd_data );
	// synthesis attribute keep_hierarchy regfile_8x1 "true";
	input clk_wr, clk_rd;
	input wr_en;
	input  [2:0] wr_addr;
	input                    wr_data;
	input  [2:0] rd_addr;
	output                   rd_data;
	// leda XV2P_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg			     data [8 - 1:0];
	// leda XV2P_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg	[2:0]    r_rd_addr;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	begin
	$random_init("r_rd_addr", "data");
	end
`endif
	// synopsys translate_on
	always @(posedge clk_wr)
	begin
	if (wr_en) begin
	// synopsys translate_off
	if (wr_addr >= 8) begin
	data[7] <= ~(1'b0);
	data[6] <= ~(1'b0);
	data[5] <= ~(1'b0);
	data[4] <= ~(1'b0);
	data[3] <= ~(1'b0);
	data[2] <= ~(1'b0);
	data[1] <= ~(1'b0);
	data[0] <= ~(1'b0);
	end
	else
	// synopsys translate_on
	data[wr_addr] <= wr_data;
	end
	end
	// leda VER_1_4_4_1 off Do not use multiple clocks in a module
	// leda DFT_006 off 2 clocks in a block
	// leda W389 off 2 clocks in the module
	// leda B_1202 off 2 clocks in this unit detected
	always @(posedge clk_rd)
	r_rd_addr <= rd_addr;
	// leda VER_1_4_4_1 on Do not use multiple clocks in a module
	// leda DFT_006 on 2 clocks in a block
	// leda W389 on 2 clocks in the module
	// leda B_1202 on 2 clocks in this unit detected
	assign rd_data = 
	// synopsys translate_off
	(r_rd_addr >= 8) ? ~(1'b0) :
	// synopsys translate_on
	data[r_rd_addr];
endmodule

// macexp DFF 5
// macexp $size 32
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_32 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_32 "true";
	input clk;
	input [31:0] d;
	output [31:0] q;
	reg [31:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp SYNC2 5
// macexp $size 1
// macexp $instance
// macexp clk
// macexp d
// macexp q

module sync2_1 ( clk, d, q );
	// synthesis attribute keep_hierarchy sync2_1 "true";
	// synthesis attribute equivalent_register_removal sync2_1 "no";
	// synthesis attribute register_duplication sync2_1 "no";
	// synthesis attribute shift_extract sync2_1 "no";
	// synthesis attribute shreg_extract sync2_1 "no";
	input clk;
	input d;
	output q;
	// the simulation model has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles
	// synthesis attribute keep q "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ q;
	reg c_q;
	// synthesis attribute keep meta1 "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg c_meta2;
	reg meta2;
`endif
	// synopsys translate_on
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta2
`endif
	// synopsys translate_on
	) begin
	c_q = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	c_meta2 = (d ^ meta1) & $random(seed);
	c_q = c_meta2 | ((meta1 ^ meta2) & $random(seed)) |
	(d & meta1 & meta2);
	c_meta2 = c_meta2 | (d & meta1);
`endif
	// synopsys translate_on
	end
	always @(posedge clk) begin
	meta1 <= d;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta2 <= c_meta2;
`endif
	// synopsys translate_on
	q <= c_q;
	end
endmodule

// macexp DFF 5
// macexp $size 2
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_2 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_2 "true";
	input clk;
	input [1:0] d;
	output [1:0] q;
	reg [1:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF_KEEP 5
// macexp $size 1
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_1 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_1 "true";
	// synthesis attribute equivalent_register_removal dff_keep_1 "no";
	// synthesis attribute shift_extract dff_keep_1 "no";
	// synthesis attribute shreg_extract dff_keep_1 "no";
	input clk;
	input d;
	// synthesis attribute keep q "true";
	output q;
	(* S = "TRUE" *)
	FD q0 (
	.Q(q),
	.C(clk),
	.D(d)
	);
endmodule

// macexp DFF_KEEP 5
// macexp $size 2
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_2 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_2 "true";
	// synthesis attribute equivalent_register_removal dff_keep_2 "no";
	// synthesis attribute shift_extract dff_keep_2 "no";
	// synthesis attribute shreg_extract dff_keep_2 "no";
	input clk;
	input [1:0] d;
	// synthesis attribute keep q "true";
	output [1:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
endmodule

// macexp DFF 5
// macexp $size 6
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_6 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_6 "true";
	input clk;
	input [5:0] d;
	output [5:0] q;
	reg [5:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFFC_KEEP 6
// macexp $size 3
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_keep_3 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_keep_3 "true";
	// synthesis attribute equivalent_register_removal dffc_keep_3 "no";
	// synthesis attribute shift_extract dffc_keep_3 "no";
	// synthesis attribute shreg_extract dffc_keep_3 "no";
	input clk;
	input reset;
	input [2:0] d;
	// synthesis attribute keep q "true";
	output [2:0] q;
	// synopsys translate_off
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	(* S = "TRUE" *)
	FDR q_0 (
	.Q(q[0]),
	.C(clk),
	.R(reset),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FDR q_1 (
	.Q(q[1]),
	.C(clk),
	.R(reset),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FDR q_2 (
	.Q(q[2]),
	.C(clk),
	.R(reset),
	.D(d[2])
	);
endmodule

// macexp DFFS_KEEP 6
// macexp $size 1
// macexp $instance
// macexp clk
// macexp set
// macexp d
// macexp q

module dffs_keep_1 ( clk, set, d, q );
	// synthesis attribute keep_hierarchy dffs_keep_1 "true";
	// synthesis attribute equivalent_register_removal dffs_keep_1 "no";
	// synthesis attribute shift_extract dffs_keep_1 "no";
	// synthesis attribute shreg_extract dffs_keep_1 "no";
	input clk;
	input set;
	input d;
	// synthesis attribute keep q "true";
	output q;
	// synopsys translate_off
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: set still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(set),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	(* S = "TRUE" *)
	FDS q0 (
	.Q(q),
	.C(clk),
	.S(set),
	.D(d)
	);
endmodule

// macexp SYNC_PEDGE 5
// macexp $size 1
// macexp $instance
// macexp clk
// macexp d
// macexp pulse

module sync_pedge_1 ( clk, d, pulse );
	// synthesis attribute keep_hierarchy sync_pedge_1 "true";
	// synthesis attribute equivalent_register_removal sync_pedge_1 "no";
	// synthesis attribute register_duplication sync_pedge_1 "no";
	// synthesis attribute shift_extract sync_pedge_1 "no";
	// synthesis attribute shreg_extract sync_pedge_1 "no";
	input clk;
	input d;
	output pulse;
	reg pulse;
	reg q;
	reg c_q;
	// synthesis attribute keep meta1 "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ meta1;
	// synthesis attribute keep meta2 "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg /* synthesis syn_preserve = 1 */ meta2;
	reg c_meta2;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg meta3;
	reg c_meta3;
	reg rnd1, rnd2, in_change;
`endif
	// synopsys translate_on
	// the simulation mode has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles.
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2", "meta3");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 or meta2 or q
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta3
`endif
	// synopsys translate_on
	) begin
	pulse = ~q & meta2;
	c_q = meta2;
	c_meta2 = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	// the logic in front of the flops attempts to be careful not to
	// generate multiple edges into the pulse generator from a single
	// input edge while delaying the output edge by 1, 2 or 3 cycles.
	pulse = ~q & meta3;
	in_change = (d & ~(meta1 | meta2 | meta3)) |
	(~d & (meta1 & meta2 & meta3));
	c_meta2 = meta1;
	c_meta3 = meta2;
	c_q = meta3;
	if (in_change)
	begin
	rnd1 = $random(seed);
	rnd2 = $random(seed);
	c_meta3 = (~in_change & meta2) | (in_change & (d ^ (rnd1 | rnd2)
	));
	c_meta2 = (~in_change & meta1) | (in_change & (d ^ rnd1));
	end
`endif
	// synopsys translate_on
	end
	always @(posedge clk) begin
	meta1 <= d;
	meta2 <= c_meta2;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta3 <= c_meta3;
`endif
	// synopsys translate_on
	q <= c_q;
	end
endmodule

// macexp DFF 5
// macexp $size 1
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_1 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_1 "true";
	input clk;
	input d;
	output q;
	reg q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 4
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_4 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_4 "true";
	input clk;
	input [3:0] d;
	output [3:0] q;
	reg [3:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 16
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_16 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_16 "true";
	input clk;
	input [15:0] d;
	output [15:0] q;
	reg [15:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 64
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_64 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_64 "true";
	input clk;
	input [63:0] d;
	output [63:0] q;
	reg [63:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 3
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_3 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_3 "true";
	input clk;
	input [2:0] d;
	output [2:0] q;
	reg [2:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 8
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_8 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_8 "true";
	input clk;
	input [7:0] d;
	output [7:0] q;
	reg [7:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp DFF_KEEP 5
// macexp $size 9
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_keep_9 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_keep_9 "true";
	// synthesis attribute equivalent_register_removal dff_keep_9 "no";
	// synthesis attribute shift_extract dff_keep_9 "no";
	// synthesis attribute shreg_extract dff_keep_9 "no";
	input clk;
	input [8:0] d;
	// synthesis attribute keep q "true";
	output [8:0] q;
	(* S = "TRUE" *)
	FD q_0 (
	.Q(q[0]),
	.C(clk),
	.D(d[0])
	);
	(* S = "TRUE" *)
	FD q_1 (
	.Q(q[1]),
	.C(clk),
	.D(d[1])
	);
	(* S = "TRUE" *)
	FD q_2 (
	.Q(q[2]),
	.C(clk),
	.D(d[2])
	);
	(* S = "TRUE" *)
	FD q_3 (
	.Q(q[3]),
	.C(clk),
	.D(d[3])
	);
	(* S = "TRUE" *)
	FD q_4 (
	.Q(q[4]),
	.C(clk),
	.D(d[4])
	);
	(* S = "TRUE" *)
	FD q_5 (
	.Q(q[5]),
	.C(clk),
	.D(d[5])
	);
	(* S = "TRUE" *)
	FD q_6 (
	.Q(q[6]),
	.C(clk),
	.D(d[6])
	);
	(* S = "TRUE" *)
	FD q_7 (
	.Q(q[7]),
	.C(clk),
	.D(d[7])
	);
	(* S = "TRUE" *)
	FD q_8 (
	.Q(q[8]),
	.C(clk),
	.D(d[8])
	);
endmodule

// macexp REGFILE 10
// macexp $depth 8
// macexp $size 11
// macexp $instance
// macexp clk_wr
// macexp wr_en
// macexp wr_addr
// macexp wr_data
// macexp clk_rd
// macexp rd_addr
// macexp rd_data

module regfile_8x11 ( clk_wr, wr_en, wr_addr, wr_data, clk_rd, rd_addr, rd_data );
	// synthesis attribute keep_hierarchy regfile_8x11 "true";
	input clk_wr, clk_rd;
	input wr_en;
	input  [2:0] wr_addr;
	input  [10:0] wr_data;
	input  [2:0] rd_addr;
	output [10:0] rd_data;
	// leda XV2P_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV2_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg    [10:0] data [8 - 1:0];
	// leda XV2P_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV2_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg	[2:0]    r_rd_addr;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	begin
	$random_init("r_rd_addr", "data");
	end
`endif
	// synopsys translate_on
	always @(posedge clk_wr)
	begin
	if (wr_en) begin
	// synopsys translate_off
	if (wr_addr >= 8) begin
	data[7] <= ~(11'b0);
	data[6] <= ~(11'b0);
	data[5] <= ~(11'b0);
	data[4] <= ~(11'b0);
	data[3] <= ~(11'b0);
	data[2] <= ~(11'b0);
	data[1] <= ~(11'b0);
	data[0] <= ~(11'b0);
	end
	else
	// synopsys translate_on
	data[wr_addr] <= wr_data;
	end
	end
	// leda VER_1_4_4_1 off Do not use multiple clocks in a module
	// leda DFT_006 off 2 clocks in a block
	// leda W389 off 2 clocks in the module
	// leda B_1202 off 2 clocks in this unit detected
	always @(posedge clk_rd)
	r_rd_addr <= rd_addr;
	// leda VER_1_4_4_1 on Do not use multiple clocks in a module
	// leda DFT_006 on 2 clocks in a block
	// leda W389 on 2 clocks in the module
	// leda B_1202 on 2 clocks in this unit detected
	assign rd_data = 
	// synopsys translate_off
	(r_rd_addr >= 8) ? ~(11'b0) :
	// synopsys translate_on
	data[r_rd_addr];
endmodule

// macexp REGFILE 10
// macexp $depth 8
// macexp $size 12
// macexp $instance
// macexp clk_wr
// macexp wr_en
// macexp wr_addr
// macexp wr_data
// macexp clk_rd
// macexp rd_addr
// macexp rd_data

module regfile_8x12 ( clk_wr, wr_en, wr_addr, wr_data, clk_rd, rd_addr, rd_data );
	// synthesis attribute keep_hierarchy regfile_8x12 "true";
	input clk_wr, clk_rd;
	input wr_en;
	input  [2:0] wr_addr;
	input  [11:0] wr_data;
	input  [2:0] rd_addr;
	output [11:0] rd_data;
	// leda XV2P_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV2_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 off [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg    [11:0] data [8 - 1:0];
	// leda XV2P_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV2_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	// leda XV4_1610 on [STRONG WARNING] Detected two-dimensional array opportunity for RAM inference
	reg	[2:0]    r_rd_addr;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	begin
	$random_init("r_rd_addr", "data");
	end
`endif
	// synopsys translate_on
	always @(posedge clk_wr)
	begin
	if (wr_en) begin
	// synopsys translate_off
	if (wr_addr >= 8) begin
	data[7] <= ~(12'b0);
	data[6] <= ~(12'b0);
	data[5] <= ~(12'b0);
	data[4] <= ~(12'b0);
	data[3] <= ~(12'b0);
	data[2] <= ~(12'b0);
	data[1] <= ~(12'b0);
	data[0] <= ~(12'b0);
	end
	else
	// synopsys translate_on
	data[wr_addr] <= wr_data;
	end
	end
	// leda VER_1_4_4_1 off Do not use multiple clocks in a module
	// leda DFT_006 off 2 clocks in a block
	// leda W389 off 2 clocks in the module
	// leda B_1202 off 2 clocks in this unit detected
	always @(posedge clk_rd)
	r_rd_addr <= rd_addr;
	// leda VER_1_4_4_1 on Do not use multiple clocks in a module
	// leda DFT_006 on 2 clocks in a block
	// leda W389 on 2 clocks in the module
	// leda B_1202 on 2 clocks in this unit detected
	assign rd_data = 
	// synopsys translate_off
	(r_rd_addr >= 8) ? ~(12'b0) :
	// synopsys translate_on
	data[r_rd_addr];
endmodule

// macexp DFF 5
// macexp $size 5
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_5 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_5 "true";
	input clk;
	input [4:0] d;
	output [4:0] q;
	reg [4:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

// macexp PHASEGEN 7
// macexp $size 1
// macexp $instance
// macexp clk
// macexp clk_2x
// macexp set
// macexp phase
// macexp reset

module phasegen_1 ( clk, clk_2x, set, phase, reset );
	// synthesis attribute keep_hierarchy phasegen_1 "true";
	// synthesis attribute equivalent_register_removal phasegen_1 "no";
	// synthesis attribute shift_extract phasegen_1 "no";
	// synthesis attribute shreg_extract phasegen_1 "no";
	input clk;
	input clk_2x;
	input set;
	output phase;
	output reset;
	// synopsys translate_off
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: set still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(set),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	wire my_zero, set_ls;
	assign reset = set_ls;
	LUT1_L #(
	.INIT(2'h0)
	) rset_ls_lut (
	.LO(my_zero),
	.I0(set_ls)
	);
	FDS rset_ls (
	.Q(set_ls), 
	.C(clk), 
	.D(my_zero), 
	.S(set)
	);
	FDS rphase (
	.Q(phase), 
	.C(clk_2x), 
	.D(~phase), 
	.S(set_ls)
	);
endmodule

// macexp DFFL 6
// macexp $size 34
// macexp $instance
// macexp clk
// macexp ld
// macexp d
// macexp q

module dffl_34 ( clk, ld, d, q );
	// synthesis attribute keep_hierarchy dffl_34 "true";
	input clk;
	input ld;
	input [33:0] d;
	output [33:0] q;
	reg [33:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	// leda XV2P_1006 off Multiple synchronous resets detected
	// leda XV2P_1007 off Multiple synchronous resets detected
	// leda G_551_1_K off Multiple synchronous resets detected
	if (ld)
	q <= d;
	// leda XV2P_1006 on Multiple synchronous resets detected
	// leda XV2P_1007 on Multiple synchronous resets detected
	// leda G_551_1_K on Multiple synchronous resets detected
	end
endmodule

// macexp MUX2 6
// macexp $size 1
// macexp $instance
// macexp s
// macexp i0
// macexp i1
// macexp o

module mux2_1 ( s, i0, i1, o );
	// synthesis attribute keep_hierarchy mux2_1 "no";
	input s;
	input i0, i1;
	output o;
	wire [1:0] mi;
	assign mi = {i1, i0};
	assign o = mi[s];
endmodule

// macexp SYNC2 5
// macexp $size 6
// macexp $instance
// macexp clk
// macexp d
// macexp q

module sync2_6 ( clk, d, q );
	// synthesis attribute keep_hierarchy sync2_6 "true";
	// synthesis attribute equivalent_register_removal sync2_6 "no";
	// synthesis attribute register_duplication sync2_6 "no";
	// synthesis attribute shift_extract sync2_6 "no";
	// synthesis attribute shreg_extract sync2_6 "no";
	input clk;
	input [5:0] d;
	output [5:0] q;
	// the simulation model has an extra register compared to the
	//   real 2 stage synchronizer in order to delay the input change
	//   by 1, 2 or 3 cycles
	// synthesis attribute keep q "true";
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	reg [5:0] /* synthesis syn_preserve = 1 */ q;
	reg [5:0] c_q;
	(* register_duplication = "no" *)
	(* shreg_extract = "no" *)
	(* equivalent_register_removal = "no" *)
	(* S = "TRUE" *)
	(* KEEP = "TRUE" *)
	// synthesis attribute keep meta1 "true";
	reg [5:0] /* synthesis syn_preserve = 1 */ meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [5:0] c_meta2;
	reg [5:0] meta2;
`endif
	// synopsys translate_on
	// synopsys translate_off
`ifdef RANDOM_INIT
	reg [31:0] seed;
	initial
	begin
	$random_init("q", "meta1", "meta2");
	$random_value("seed");
	end
`endif
	// synopsys translate_on
	always @ (meta1 
	// synopsys translate_off
`ifdef RANDOM_INIT
	or d or meta2
`endif
	// synopsys translate_on
	) begin
	c_q = meta1;
	// synopsys translate_off
`ifdef RANDOM_INIT
	c_meta2 = (d ^ meta1) & $random(seed);
	c_q = c_meta2 | ((meta1 ^ meta2) & $random(seed)) |
	(d & meta1 & meta2);
	c_meta2 = c_meta2 | (d & meta1);
`endif
	// synopsys translate_on
	end
	always @(posedge clk) begin
	meta1 <= d;
	// synopsys translate_off
`ifdef RANDOM_INIT
	meta2 <= c_meta2;
`endif
	// synopsys translate_on
	q <= c_q;
	end
endmodule

// macexp DFFC 6
// macexp $size 9
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_9 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_9 "true";
	input clk;
	input reset;
	input [8:0] d;
	output [8:0] q;
	reg [8:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 9'b0;
	else
	q <= d;
	end
endmodule

// macexp DFFC 6
// macexp $size 1
// macexp $instance
// macexp clk
// macexp reset
// macexp d
// macexp q

module dffc_1 ( clk, reset, d, q );
	// synthesis attribute keep_hierarchy dffc_1 "true";
	input clk;
	input reset;
	input d;
	output q;
	reg q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: reset still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(reset),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (reset)
	q <= 1'b0;
	else
	q <= d;
	end
endmodule

// macexp DFFS 6
// macexp $size 1
// macexp $instance
// macexp clk
// macexp set
// macexp d
// macexp q

module dffs_1 ( clk, set, d, q );
	// synthesis attribute keep_hierarchy dffs_1 "true";
	input clk;
	input set;
	input d;
	output q;
	reg q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
`ifdef CHK_RESET_EOS
	assert_quiescent_state #(0,1,0, 
	"***ERROR ASSERT: set still asserted at end of simulation")
	a0(.clk(clk),.reset_n(1'b1), .state_expr(set),
	.check_value(1'b0), .sample_event(1'b0));
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	if (set)
	q <= ~(1'b0);
	else
	q <= d;
	end
endmodule

// macexp DFF 5
// macexp $size 9
// macexp $instance
// macexp clk
// macexp d
// macexp q

module dff_9 ( clk, d, q );
	// synthesis attribute keep_hierarchy dff_9 "true";
	input clk;
	input [8:0] d;
	output [8:0] q;
	reg [8:0] q;
	// synopsys translate_off
`ifdef RANDOM_INIT
	initial
	$random_init("q");
`endif
	// synopsys translate_on
	always @(posedge clk) begin
	q <= d;
	end
endmodule

`endcelldefine

