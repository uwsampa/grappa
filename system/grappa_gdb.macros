
# Copyright 2010-2012 University of Washington. All Rights Reserved.
# LICENSE_PLACEHOLDER
# This software was created with Government support under DE
# AC05-76RL01830 awarded by the United States Department of
# Energy. The Government has certain rights in the software.

#
# Grappa gdb macros
#
# load by telling GDB "source grappa_gdb.macros"
#

set print pretty on
set print address on
set print object on
set print static-members on
set print vtbl on
set print demangle on
set print asm-demangle on

echo Loading Grappa GDB Macros package.  Type "help grappa" for more info.\n

define grappa
printf ""
echo  These are the gdb macros for Grappa debugging.  Type "help grappa" for more info.\n
end

document grappa
These are the Grappa gdb macros.

  queues                               print both task and worker queues

  tasks                                print public and private task queues
  public_tasks
  private_tasks

  workers                           print all workers
  current_worker
  periodic_queue
  ready_queue
  unassigned_queue
  suspended_workers

  backtrace_worker <worker pointer>   backtrace for specific worker
  btc <worker pointer>                   backtrace for specific worker

  backtrace_worker_full <worker pointer> backtrace for specific worker with locals
  btcf <worker pointer>                  backtrace for specific worker with locals

  switch_to_worker <worker pointer>   change $rip and $rsp to worker's. 
                                            DO NOT CONTINUE UNTIL RESTORE
  grappa_save_state                         save real $rip and $rsp
  grappa_restore_state                      restore real $rip and $rsp

  dumpstack <worker pointer>             dump the stack (as raw int64_t's)

Type "help <macro>" for more specific help on a particular macro.
Type "show user <macro>" to see what the macro is really doing.
end


set $grappa_stack_offset = 0x40
#set $grappa_stack_offset = 0x48

set $grappa_saved_rip = 0
set $grappa_saved_rsp = 0

define grappa_save_state
  if $grappa_saved_rip != 0 
    grappa_restore_state
  end
  set $grappa_saved_rip = $rip
  set $grappa_saved_rsp = $rsp
end
document grappa_save_state
Save current worker $rip and $rsp for later.
Syntax:
   (gdb) grappa_save_state
end

define grappa_restore_state
  if $grappa_saved_rip != 0
    set $rip = $grappa_saved_rip
    set $rsp = $grappa_saved_rsp
#    select-frame $grappa_saved_rsp
    set $grappa_saved_rip = 0
  end
end
document grappa_restore_state
Restore saved worker $rip and $rsp.
p $Syntax:
   (gdb) grappa_restore_state
end






define grappa_worker_print
  set $grappa_worker_print_elem = (Worker*) $arg0
  printf "  Worker %p running=%d suspended=%d IP ", $grappa_worker_print_elem, $grappa_worker_print_elem->running, $grappa_worker_print_elem->suspended
  output/a *(int*)($grappa_worker_print_elem->stack + $grappa_stack_offset) 
  printf "\n"
end
document grappa_worker_print
Prints worker data
Syntax:
   (gdb) grappa_worker_print <worker pointer>
end

define grappa_workers
  set $grappa_workers_elem = all_coros
  while $grappa_workers_elem != 0
    grappa_worker_print $grappa_workers_elem
    set $grappa_workers_elem = $grappa_workers_elem->next
  end
end
document grappa_workers
Prints simple state of all workers
Syntax:
   (gdb) grappa_workers
end

define grappa_queue_print
  set $grappa_queue = $arg1
  if $grappa_queue->queues->head
    set $grappa_queue_length = 0
  else
    set $grappa_queue_length = $grappa_queue->queues->len
  end
  printf "%s queue has length %d:\n", $arg0, $grappa_queue->queues->len
  set $grappa_queue_print_elem = $grappa_queue->queues->head
  while $grappa_queue_print_elem != 0
    grappa_worker_print $grappa_queue_print_elem
    set $grappa_queue_print_elem = $grappa_queue_print_elem->next
  end
end
document grappa_queue_print
Prints contents of queue.
Syntax:
   (gdb) grappa_queue_print <queue name> <queue pointer>
end

define grappa_queue_length
  set $grappa_queue = $arg1
  if $grappa_queue->queues->head
    set $grappa_queue_length = 0
  else
    set $grappa_queue_length = $grappa_queue->queues->len
  end
  printf "%s queue has length %d. (Contents not shown.)\n", $arg0, $grappa_queue->len
end
document grappa_queue_length
Prints length of queue.
Syntax:
   (gdb) grappa_queue_length <queue name> <queue pointer>
end




define periodic_queue
  grappa_queue_print "Periodic" &Grappa::impl::global_scheduler.periodicQ
end
document periodic_queue
Prints contents of Grappa periodic queue.
Syntax:
   (gdb) periodic_queue
end

define ready_queue
  grappa_queue_print "Ready" &Grappa::impl::global_scheduler.readyQ
end
document ready_queue
Prints contents of Grappa ready queue.
Syntax:
   (gdb) ready_queue
end

define unassigned_queue
  grappa_queue_print "Unassigned" &Grappa::impl::global_scheduler.unassignedQ
end
document unassigned_queue
Prints contents of Grappa unassigned queue.
Syntax:
   (gdb) unassigned_queue
end

define unassigned_queue_length
  grappa_queue_length "Unassigned" &Grappa::impl::global_scheduler.unassignedQ
end
document unassigned_queue_length
Prints length of Grappa unassigned queue.
Syntax:
   (gdb) unassigned_queue_length
end

define suspended_workers
  printf "Suspended non-idle workers:\n"
  set $grappa_suspended_coros_elem = all_coros
  while $grappa_suspended_coros_elem != 0
    if $grappa_suspended_coros_elem->suspended
      if !($grappa_suspended_coros_elem->idle)
        grappa_worker_print $grappa_suspended_coros_elem
      end
    end
    set $grappa_suspended_coros_elem = $grappa_suspended_coros_elem->next
  end
end
document suspended_workers
Prints all suspended workers
Syntax:
   (gdb) suspended_workers
end

define current_worker
  printf "Current worker:\n"
  grappa_worker_print Grappa::impl::global_scheduler.current_thread
end
document current_worker
Prints currently scheduled Grappa worker.
Syntax:
   (gdb) current_worker
end

define workers
  current_worker
  periodic_queue
  ready_queue
  unassigned_queue_length
  suspended_workers
end
document workers
Prints contents of Grappa worker queues.
Syntax:
   (gdb) workers
end




define private_tasks
  printf "Private tasks (newest at top): "
  output/a Grappa::impl::global_scheduler.task_manager->privateQ
  printf "\n"
end
document private_tasks
Prints contents of Grappa private task queue.
Syntax:
   (gdb) private_tasks
end

define public_tasks
  set $grappa_publicQ = Grappa::impl::global_scheduler.task_manager->publicQ
  set $grappa_shared_tasks = $grappa_publicQ->top - $grappa_publicQ->bottom
  printf "Shared public tasks (newest at bottom) (%d shared):\n", $grappa_shared_tasks
  set $grappa_task_index = $grappa_publicQ->bottom
  while $grappa_task_index != $grappa_publicQ->top
    printf "  Task function: "
    output $grappa_publicQ->stack[ $grappa_task_index ].fn_p 
    printf "   args: "
    output $grappa_publicQ->stack[ $grappa_task_index ].arg0
    printf ", "
    output $grappa_publicQ->stack[ $grappa_task_index ].arg1
    printf ", "
    output $grappa_publicQ->stack[ $grappa_task_index ].arg2
    printf "\n"
    set $grappa_task_index++
  end
end
document public_tasks
  Prints contents of Grappa public task queue.
  Syntax:
  (gdb) public_tasks
end

define tasks
  private_tasks
  public_tasks
end
document tasks
Prints contents of Grappa task queues.
Syntax:
   (gdb) tasks
end

define queues
  workers
  tasks
end
document queues
Prints contents of Grappa worker/task queues.
Syntax:
   (gdb) queues
end







define switch_to_worker
  grappa_save_state
  set $grappa_coro = (Worker*) $arg0
  set $rsp = $grappa_coro->stack + $grappa_stack_offset
#  select-frame ($grappa_coro->stack + $grappa_stack_offset)
  set $rip = *(int*)$rsp
#  set $rip = *(int*)($grappa_coro->stack + $grappa_stack_offset)
end
document switch_to_worker
Switch to a Grappa worker for backtracing. Do not continue or bad things will happen.
Use grappa_restore_state to switch back to the original context.
Syntax:
   (gdb) switch_to_worker <worker pointer>
end

define backtrace_worker
  switch_to_worker $arg0
  backtrace
  grappa_restore_state
end
document backtrace_worker
Print backtrace of Grappa worker.
Syntax:
   (gdb) backtrace_worker <worker pointer>
end

define backtrace_worker_full
  switch_to_worker $arg0
  backtrace full
  grappa_restore_state
end
document backtrace_worker_full
Print backtrace of Grappa worker with locals.
Syntax:
   (gdb) backtrace_worker_full <worker pointer>
end

define btc
  switch_to_worker $arg0
  backtrace
  grappa_restore_state
end
document btc
Print backtrace of Grappa worker.
Syntax:
   (gdb) btc <worker pointer>
end

define btcf
  switch_to_worker $arg0
  backtrace full
  grappa_restore_state
end
document btcf
Print backtrace of Grappa worker with locals.
Syntax:
   (gdb) btcf <worker pointer>
end

define dumpstack
  p ((int64_t*)((Worker*)$arg0)->stack) @ (((Worker*)$arg0)->base+((Worker*)$arg0)->ssize+4096-((Worker*)$arg0)->stack)/sizeof(int64_t)
end
document dumpstack
Dump stack (as int64_t's).
Syntax:
   (gdb) dumpstack <worker pointer>
end

