########################################################################
## This file is part of Grappa, a system for scaling irregular
## applications on commodity clusters. 

## Copyright (C) 2010-2014 University of Washington and Battelle
## Memorial Institute. University of Washington authorizes use of this
## Grappa software.

## Grappa is free software: you can redistribute it and/or modify it
## under the terms of the Affero General Public License as published
## by Affero, Inc., either version 1 of the License, or (at your
## option) any later version.

## Grappa is distributed in the hope that it will be useful, but
## WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## Affero General Public License for more details.

## You should have received a copy of the Affero General Public
## License along with this program. If not, you may obtain one from
## http://www.affero.org/oagpl.html.
########################################################################

#
# Grappa gdb macros
#
# load by telling GDB "source grappa_gdb.macros"
#

set print pretty on
set print address on
set print object on
set print static-members on
set print vtbl on
set print demangle on
set print asm-demangle on

echo Loading Grappa GDB Macros package.  Type "help grappa" for more info.\n

define grappa
printf ""
echo  These are the gdb macros for Grappa debugging.  Type "help grappa" for more info.\n
end

document grappa
These are the Grappa gdb macros.

  queues                               print both task and coroutine queues

  tasks                                print public and private task queues
  public_tasks
  private_tasks

  coroutines                           print all coroutines
  current_coroutine
  periodic_queue
  ready_queue
  unassigned_queue
  suspended_coroutines

  backtrace_coroutine <coroutine pointer>   backtrace for specific coroutine
  btc <coroutine pointer>                   backtrace for specific coroutine

  backtrace_coroutine_full <coroutine pointer> backtrace for specific coroutine with locals
  btcf <coroutine pointer>                  backtrace for specific coroutine with locals

  switch_to_coroutine <coroutine pointer>   change $rip and $rsp to coroutine's. 
                                            DO NOT CONTINUE UNTIL RESTORE
  grappa_save_state                         save real $rip and $rsp
  grappa_restore_state                      restore real $rip and $rsp

  dumpstack <coroutine pointer>             dump the stack (as raw int64_t's)

Type "help <macro>" for more specific help on a particular macro.
Type "show user <macro>" to see what the macro is really doing.
end


set $grappa_stack_offset = 0x40
#set $grappa_stack_offset = 0x48

set $grappa_saved_rip = 0
set $grappa_saved_rsp = 0

define grappa_save_state
  if $grappa_saved_rip != 0 
    grappa_restore_state
  end
  set $grappa_saved_rip = $rip
  set $grappa_saved_rsp = $rsp
end
document grappa_save_state
Save current coroutine $rip and $rsp for later.
Syntax:
   (gdb) grappa_save_state
end

define grappa_restore_state
  if $grappa_saved_rip != 0
    set $rip = $grappa_saved_rip
    set $rsp = $grappa_saved_rsp
#    select-frame $grappa_saved_rsp
    set $grappa_saved_rip = 0
  end
end
document grappa_restore_state
Restore saved coroutine $rip and $rsp.
p $Syntax:
   (gdb) grappa_restore_state
end






define grappa_coroutine_print
  set $grappa_coroutine_print_elem = (Worker*) $arg0
  printf "  Coroutine %p running=%d suspended=%d IP ", $grappa_coroutine_print_elem, $grappa_coroutine_print_elem->running, $grappa_coroutine_print_elem->suspended
  output/a *(int*)($grappa_coroutine_print_elem->stack + $grappa_stack_offset) 
  printf "\n"
end
document grappa_coroutine_print
Prints coroutine data
Syntax:
   (gdb) grappa_coroutine_print <coroutine pointer>
end

define grappa_coroutines
  set $grappa_coroutines_elem = all_coros
  while $grappa_coroutines_elem != 0
    grappa_coroutine_print $grappa_coroutines_elem
    set $grappa_coroutines_elem = $grappa_coroutines_elem->next
  end
end
document grappa_coroutines
Prints simple state of all coroutines
Syntax:
   (gdb) grappa_coroutines
end


define grappa_thread_print
  set $grappa_thread_print_elem = (Thread*)($arg0)
  grappa_coroutine_print *$grappa_thread_print_elem
end
document grappa_thread_print
Prints coroutine data from thread.
Syntax:
   (gdb) grappa_thread_print <thread pointer>
end

define grappa_queue_print
  set $grappa_queue = $arg1
  if $grappa_queue->head
    set $grappa_queue_length = 0
  else
    set $grappa_queue_length = $grappa_queue->len
  end
  printf "%s queue has length %d:\n", $arg0, $grappa_queue->len
  set $grappa_queue_print_elem = $grappa_queue->head
  while $grappa_queue_print_elem != 0
    grappa_coroutine_print *$grappa_queue_print_elem
    set $grappa_queue_print_elem = $grappa_queue_print_elem->next
  end
end
document grappa_queue_print
Prints contents of queue.
Syntax:
   (gdb) grappa_queue_print <queue name> <queue pointer>
end

define grappa_queue_length
  set $grappa_queue = $arg1
  if $grappa_queue->head
    set $grappa_queue_length = 0
  else
    set $grappa_queue_length = $grappa_queue->len
  end
  printf "%s queue has length %d. (Contents not shown.)\n", $arg0, $grappa_queue->len
end
document grappa_queue_length
Prints length of queue.
Syntax:
   (gdb) grappa_queue_length <queue name> <queue pointer>
end




define periodic_queue
  grappa_queue_print "Periodic" &Grappa::impl::global_scheduler.periodicQ
end
document periodic_queue
Prints contents of Grappa periodic queue.
Syntax:
   (gdb) periodic_queue
end

define ready_queue
  grappa_queue_print "Ready" &Grappa::impl::global_scheduler.readyQ
end
document ready_queue
Prints contents of Grappa ready queue.
Syntax:
   (gdb) ready_queue
end

define unassigned_queue
  grappa_queue_print "Unassigned" &Grappa::impl::global_scheduler.unassignedQ
end
document unassigned_queue
Prints contents of Grappa unassigned queue.
Syntax:
   (gdb) unassigned_queue
end

define unassigned_queue_length
  grappa_queue_length "Unassigned" &Grappa::impl::global_scheduler.unassignedQ
end
document unassigned_queue_length
Prints length of Grappa unassigned queue.
Syntax:
   (gdb) unassigned_queue_length
end

define suspended_coroutines
  printf "Suspended non-idle coroutines:\n"
  set $grappa_suspended_coros_elem = all_coros
  while $grappa_suspended_coros_elem != 0
    if $grappa_suspended_coros_elem->suspended
      if !($grappa_suspended_coros_elem->idle)
        grappa_coroutine_print $grappa_suspended_coros_elem
      end
    end
    set $grappa_suspended_coros_elem = $grappa_suspended_coros_elem->next
  end
end
document suspended_coroutines
Prints all suspended coroutines
Syntax:
   (gdb) suspended_coroutines
end

define current_coroutine
  printf "Current coroutine:\n"
  grappa_coroutine_print *Grappa::impl::global_scheduler.current_thread
end
document current_coroutine
Prints currently scheduled Grappa coroutine.
Syntax:
   (gdb) current_coroutine
end

define coroutines
  current_coroutine
  periodic_queue
  ready_queue
  unassigned_queue_length
  suspended_coroutines
end
document coroutines
Prints contents of Grappa coroutine queues.
Syntax:
   (gdb) coroutines
end




define private_tasks
  printf "Private tasks (newest at top): "
  output/a Grappa::impl::global_scheduler.task_manager->privateQ
  printf "\n"
end
document private_tasks
Prints contents of Grappa private task queue.
Syntax:
   (gdb) private_tasks
end

define public_tasks
  set $grappa_publicQ = Grappa::impl::global_scheduler.task_manager->publicQ
  set $grappa_shared_tasks = $grappa_publicQ->top - $grappa_publicQ->bottom
  printf "Shared public tasks (newest at bottom) (%d shared):\n", $grappa_shared_tasks
  set $grappa_task_index = $grappa_publicQ->bottom
  while $grappa_task_index != $grappa_publicQ->top
    printf "  Task function: "
    output $grappa_publicQ->stack[ $grappa_task_index ].fn_p 
    printf "   args: "
    output $grappa_publicQ->stack[ $grappa_task_index ].arg0
    printf ", "
    output $grappa_publicQ->stack[ $grappa_task_index ].arg1
    printf ", "
    output $grappa_publicQ->stack[ $grappa_task_index ].arg2
    printf "\n"
    set $grappa_task_index++
  end
end
document public_tasks
  Prints contents of Grappa public task queue.
  Syntax:
  (gdb) public_tasks
end

define tasks
  private_tasks
  public_tasks
end
document tasks
Prints contents of Grappa task queues.
Syntax:
   (gdb) tasks
end

define queues
  coroutines
  tasks
  ready_queue
  unassigned_queue
  suspended_coroutines
end
document queues
Prints contents of Grappa coroutine/task queues.
Syntax:
   (gdb) queues
end







define switch_to_coroutine
  grappa_save_state
  set $grappa_coro = (Worker*) $arg0
  set $rsp = $grappa_coro->stack + $grappa_stack_offset
#  select-frame ($grappa_coro->stack + $grappa_stack_offset)
  set $rip = *(int*)$rsp
#  set $rip = *(int*)($grappa_coro->stack + $grappa_stack_offset)
end
document switch_to_coroutine
Switch to a Grappa coroutine for backtracing. Do not continue or bad things will happen.
Use grappa_restore_state to switch back to the original context.
Syntax:
   (gdb) switch_to_coroutine <coroutine pointer>
end

define backtrace_coroutine
  switch_to_coroutine $arg0
  backtrace
  grappa_restore_state
end
document backtrace_coroutine
Print backtrace of Grappa coroutine.
Syntax:
   (gdb) backtrace_coroutine <coroutine pointer>
end

define backtrace_coroutine_full
  switch_to_coroutine $arg0
  backtrace full
  grappa_restore_state
end
document backtrace_coroutine_full
Print backtrace of Grappa coroutine with locals.
Syntax:
   (gdb) backtrace_coroutine_full <coroutine pointer>
end

define btc
  switch_to_coroutine $arg0
  backtrace
  grappa_restore_state
end
document btc
Print backtrace of Grappa coroutine.
Syntax:
   (gdb) btc <coroutine pointer>
end

define btcf
  switch_to_coroutine $arg0
  backtrace full
  grappa_restore_state
end
document btcf
Print backtrace of Grappa coroutine with locals.
Syntax:
   (gdb) btcf <coroutine pointer>
end

define dumpstack
  p ((int64_t*)((Worker*)$arg0)->stack) @ (((Worker*)$arg0)->base+((Worker*)$arg0)->ssize+4096-((Worker*)$arg0)->stack)/sizeof(int64_t)
end
document dumpstack
Dump stack (as int64_t's).
Syntax:
   (gdb) dumpstack <coroutine pointer>
end

