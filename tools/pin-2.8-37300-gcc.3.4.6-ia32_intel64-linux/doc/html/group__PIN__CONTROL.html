<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: Controlling and Initializing</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Controlling and Initializing</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gbe792b6e32e9bbb19d51a1f352743a82">LEVEL_PINCLIENT::FORK_PROBE_MODE_CALLBACK</a> )(UINT32 childPid, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef <a class="el" href="group__PIN__CONTROL.html#g884814f02a548395107079cf3a4ff552">EXCEPT_HANDLING_RESULT</a>(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gb3550c0044899834614bc73245f90743">LEVEL_PINCLIENT::INTERNAL_EXCEPTION_CALLBACK</a> )(<a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, <a class="el" href="group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f">EXCEPTION_INFO</a> *pExceptInfo, <a class="el" href="group__PHYSICAL__CONTEXT__API.html#g5041f3f7591f9ee249b986d2bc2f7d6e">PHYSICAL_CONTEXT</a> *pPhysCtxt, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g53cea46aaf83cb4d14f5e485eac688df">LEVEL_PINCLIENT::REMOVE_INSTRUMENTATION_CALLBACK</a> )(VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gbf9966c96960a9de9bccd39a6b6d6fd7">LEVEL_PINCLIENT::DETACH_CALLBACK</a> )(VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gc0db898ddefe4b25ed1737176ce7c1ef">LEVEL_PINCLIENT::DETACH_PROBED_CALLBACK</a> )(VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g7d76d5f60f83d8564bb7d75198055059">LEVEL_PINCLIENT::ATTACH_PROBED_CALLBACK</a> )(VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g0f271c9545b0d1b159827e718d1b7f74">LEVEL_PINCLIENT::APPLICATION_START_CALLBACK</a> )(VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gcc77dcacc144b3894f5f0fc13360cdec">LEVEL_PINCLIENT::FINI_CALLBACK</a> )(INT32 code, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef size_t(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gf26c93895c15754aa02c56d41f81f5f4">LEVEL_PINCLIENT::FETCH_CALLBACK</a> )(void *buf, ADDRINT addr, size_t size, <a class="el" href="group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gde47352f7f71df0632aa847aae16a274">LEVEL_PINCLIENT::OUT_OF_MEMORY_CALLBACK</a> )(size_t size, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g81f4a1b953b4806f7db51c881f71e80f">LEVEL_PINCLIENT::FORK_CALLBACK</a> )(<a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid, const <a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g299a24d8e05412410b32b75b51564081">LEVEL_PINCLIENT::THREAD_START_CALLBACK</a> )(<a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadIndex, <a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, INT32 flags, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gc1b5679826895fc2627fe4fef50820bf">LEVEL_PINCLIENT::THREAD_ATTACH_PROBED_CALLBACK</a> )(VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gaf37c586368c5230ff7fba6c2bfebd01">LEVEL_PINCLIENT::THREAD_FINI_CALLBACK</a> )(<a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadIndex, const <a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, INT32 code, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g78a7c9eeb76f7c94dbfc382ba6a213d1">LEVEL_PINCLIENT::CONTEXT_CHANGE_CALLBACK</a> )(<a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadIndex, <a class="el" href="group__PIN__CONTROL.html#gfa1b03e06c6ab0f86fc2abc1693ce688">CONTEXT_CHANGE_REASON</a> reason, const <a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *from, <a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *to, INT32 info, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef BOOL(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g2f00e98cd79f80c871f8ac193f9c1ba8">LEVEL_PINCLIENT::INTERCEPT_SIGNAL_CALLBACK</a> )(<a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, INT32 sig, <a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, BOOL hasHandler, const <a class="el" href="group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef VOID(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g8d5ecf0344c6faa23c1ee38437538f6c">LEVEL_PINCLIENT::PROBES_INSERTED_CALLBACK</a> )(IMG img, VOID *v)</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga8378cf542c080182b597101ee265983">LEVEL_PINCLIENT::SYMBOL_INFO_MODE</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gga8378cf542c080182b597101ee265983f2d53b280bf156a6e95c5f7448f52831">LEVEL_PINCLIENT::NO_SYMBOLS</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gga8378cf542c080182b597101ee265983e0d6a139760597f64a0800449d5f8dbc">LEVEL_PINCLIENT::EXPORT_SYMBOLS</a> =  (1&lt;&lt;0), 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gga8378cf542c080182b597101ee2659834b60203d748803ef3af28de8d2900666">LEVEL_PINCLIENT::DEBUG_SYMBOLS</a> =  (1&lt;&lt;1), 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gga8378cf542c080182b597101ee2659835ac095606383aa2df08020d95b4f8009">LEVEL_PINCLIENT::DEBUG_OR_EXPORT_SYMBOLS</a> =  (DEBUG_SYMBOLS | EXPORT_SYMBOLS)
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gb6974c15e664605870435c05a1bf33bd">LEVEL_PINCLIENT::FPOINT</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#ggb6974c15e664605870435c05a1bf33bd1bf77c6f3a5ac150cf7fb1c10f0429cf">LEVEL_PINCLIENT::FPOINT_BEFORE</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#ggb6974c15e664605870435c05a1bf33bdcba5c8d0ce036ae68ab51e180e5f7d35">LEVEL_PINCLIENT::FPOINT_AFTER_IN_PARENT</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#ggb6974c15e664605870435c05a1bf33bd35c7c8f0fae3a1a1cbe29d6d79045c88">LEVEL_PINCLIENT::FPOINT_AFTER_IN_CHILD</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gfa1b03e06c6ab0f86fc2abc1693ce688">CONTEXT_CHANGE_REASON</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#ggfa1b03e06c6ab0f86fc2abc1693ce68837cb8074065ada5ef8d27e6aebf05ae4">CONTEXT_CHANGE_REASON_FATALSIGNAL</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#ggfa1b03e06c6ab0f86fc2abc1693ce688b776a0903743c7459e82d82103c27bfd">CONTEXT_CHANGE_REASON_SIGNAL</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#ggfa1b03e06c6ab0f86fc2abc1693ce688b17b32450e56cfeef5f9d6bfb237ddab">CONTEXT_CHANGE_REASON_SIGRETURN</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#ggfa1b03e06c6ab0f86fc2abc1693ce6885bd4b5a9a1bda52c8c99e3013fe39faa">CONTEXT_CHANGE_REASON_APC</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#ggfa1b03e06c6ab0f86fc2abc1693ce688e0a543355fe07b05302490d88c6a61a8">CONTEXT_CHANGE_REASON_EXCEPTION</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#ggfa1b03e06c6ab0f86fc2abc1693ce68892f2dd18a4194b3af64683e9b1d0c5f8">CONTEXT_CHANGE_REASON_CALLBACK</a>
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g884814f02a548395107079cf3a4ff552">EXCEPT_HANDLING_RESULT</a> { <br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg884814f02a548395107079cf3a4ff552632cdc08da9d43ae549e41b7275db92e">EHR_HANDLED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg884814f02a548395107079cf3a4ff552e430b2bdb725b8236f81b1ce55569146">EHR_UNHANDLED</a>, 
<br>
&nbsp;&nbsp;<a class="el" href="group__PIN__CONTROL.html#gg884814f02a548395107079cf3a4ff552cb7efbae4aa313cf065b2e783a0da677">EHR_CONTINUE_SEARCH</a>
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g03f417057aac38bb39103bcaabef6f72">LEVEL_PINCLIENT::PIN_AddForkFunctionProbed</a> (<a class="el" href="group__PIN__CONTROL.html#gb6974c15e664605870435c05a1bf33bd">FPOINT</a> point, <a class="el" href="group__PIN__CONTROL.html#gbe792b6e32e9bbb19d51a1f352743a82">FORK_PROBE_MODE_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">LEVEL_PINCLIENT::PIN_InitSymbols</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g6a86d823a691298dbe8b9ca73f328761">LEVEL_PINCLIENT::PIN_InitSymbolsAlt</a> (<a class="el" href="group__PIN__CONTROL.html#ga8378cf542c080182b597101ee265983">SYMBOL_INFO_MODE</a> mode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g7e45677714ab29a8d249f772de89f170">LEVEL_PINCLIENT::PIN_AddFollowChildProcessFunction</a> (<a class="el" href="group__CHILD__PROCESS__API.html#gcb01db8476fb5a6b4d86f09a336fe15f">FOLLOW_CHILD_PROCESS_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g02803b27d4a5c1ea27d07abeff4b7116">LEVEL_PINCLIENT::PIN_AddInternalExceptionHandler</a> (<a class="el" href="group__PIN__CONTROL.html#gb3550c0044899834614bc73245f90743">INTERNAL_EXCEPTION_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g22e1f539c7159c1bc9a2aac8f8803e81">LEVEL_PINCLIENT::PIN_TryStart</a> (<a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, <a class="el" href="group__PIN__CONTROL.html#gb3550c0044899834614bc73245f90743">INTERNAL_EXCEPTION_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g865588e1c8ec27149ab627aecabfd4c1">LEVEL_PINCLIENT::PIN_TryEnd</a> (<a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g4eaf8017949dc10cb62476e6d0bceda5">LEVEL_PINCLIENT::PIN_IsProbeMode</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g761d2835019d91668430baa4323e5234">LEVEL_PINCLIENT::PIN_IsSafeForProbedInsertion</a> (ADDRINT addr)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g51f4fcede5894981b70f3d73cbdb39f4">LEVEL_PINCLIENT::PIN_InsertCallProbed</a> (ADDRINT addr, AFUNPTR funptr,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gc5d4cd777e5c34bb760ea6768e054f20">LEVEL_PINCLIENT::PIN_LockClient</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#ga4d21b5ab38ba60932969d0d37e4f5de">LEVEL_PINCLIENT::PIN_UnlockClient</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g8fa128a4393b96cc7f292d17d2ef0ba4">LEVEL_PINCLIENT::PIN_CallApplicationFunction</a> (<a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, <a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, <a class="el" href="group__PROTO__API.html#g54651b96181be964a6a914420a4e021c">CALLINGSTD_TYPE</a> cstype, AFUNPTR origFunPtr,...)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">LEVEL_PINCLIENT::PIN_AddFiniFunction</a> (<a class="el" href="group__PIN__CONTROL.html#gcc77dcacc144b3894f5f0fc13360cdec">FINI_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g6b3bfbcdcbf17e0b48c9fb1e38acfd04">LEVEL_PINCLIENT::PIN_AddFiniUnlockedFunction</a> (<a class="el" href="group__PIN__CONTROL.html#gcc77dcacc144b3894f5f0fc13360cdec">FINI_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g5ae6f03e5b5cd137cceee6d735aa7b04">LEVEL_PINCLIENT::PIN_AddFetchFunction</a> (<a class="el" href="group__PIN__CONTROL.html#gf26c93895c15754aa02c56d41f81f5f4">FETCH_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gcae8a563efbe6d5f2eff743d718e5ce0">LEVEL_PINCLIENT::PIN_AddOutOfMemoryFunction</a> (<a class="el" href="group__PIN__CONTROL.html#gde47352f7f71df0632aa847aae16a274">OUT_OF_MEMORY_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g451060f5e998243df750ac16720cadcf">LEVEL_PINCLIENT::PIN_AddDetachFunction</a> (<a class="el" href="group__PIN__CONTROL.html#gbf9966c96960a9de9bccd39a6b6d6fd7">DETACH_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gdb1a5f5589efab9dd67bafe7cf5c37a3">LEVEL_PINCLIENT::PIN_AddDetachFunctionProbed</a> (<a class="el" href="group__PIN__CONTROL.html#gc0db898ddefe4b25ed1737176ce7c1ef">DETACH_PROBED_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gd990464123111fae4a3e575039b11af7">LEVEL_PINCLIENT::PIN_AddThreadStartFunction</a> (<a class="el" href="group__PIN__CONTROL.html#g299a24d8e05412410b32b75b51564081">THREAD_START_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gf2a8bb20cd2e70ca10e4b9a4471e171e">LEVEL_PINCLIENT::PIN_AddThreadAttachProbedFunction</a> (<a class="el" href="group__PIN__CONTROL.html#gc1b5679826895fc2627fe4fef50820bf">THREAD_ATTACH_PROBED_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g3017af7e44f9c1926bd903a186064472">LEVEL_PINCLIENT::PIN_AddApplicationStartFunction</a> (<a class="el" href="group__PIN__CONTROL.html#g0f271c9545b0d1b159827e718d1b7f74">APPLICATION_START_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g2d6c3eea4ebe3e76baed4481b079e3b1">LEVEL_PINCLIENT::PIN_AddThreadFiniFunction</a> (<a class="el" href="group__PIN__CONTROL.html#gaf37c586368c5230ff7fba6c2bfebd01">THREAD_FINI_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gdb70938ef31309447fe65a653667334a">LEVEL_PINCLIENT::PIN_AddContextChangeFunction</a> (<a class="el" href="group__PIN__CONTROL.html#g78a7c9eeb76f7c94dbfc382ba6a213d1">CONTEXT_CHANGE_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g6a0c20f386b88de45925e3434c52e4ff">LEVEL_PINCLIENT::PIN_InterceptSignal</a> (INT32 sig, <a class="el" href="group__PIN__CONTROL.html#g2f00e98cd79f80c871f8ac193f9c1ba8">INTERCEPT_SIGNAL_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g048709607373930698fb578b7150815d">LEVEL_PINCLIENT::PIN_UnblockSignal</a> (INT32 sig, BOOL enable)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g34db6607a35ac556c2342c7352a47435">LEVEL_PINCLIENT::PIN_AddProbesInsertedFunction</a> (<a class="el" href="group__PIN__CONTROL.html#g8d5ecf0344c6faa23c1ee38437538f6c">PROBES_INSERTED_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gd7da7a3f8249e8708524ee4b35f6e9ce">LEVEL_PINCLIENT::PIN_AddForkFunction</a> (<a class="el" href="group__PIN__CONTROL.html#gb6974c15e664605870435c05a1bf33bd">FPOINT</a> point, <a class="el" href="group__PIN__CONTROL.html#g81f4a1b953b4806f7db51c881f71e80f">FORK_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gaee2fe5932a3cc759d9968820be6e15d">LEVEL_PINCLIENT::PIN_RemoveInstrumentation</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g80c35ab4c9835fa66947ecd50f09fd59">LEVEL_PINCLIENT::PIN_RemoveFiniFunctions</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g0f3537980bb5ab3b0411a83426a32370">LEVEL_PINCLIENT::PIN_Detach</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g12d2f1c80491b151ce004ba459c5695e">LEVEL_PINCLIENT::PIN_DetachProbed</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gcfca774907868814fc1b1fbe3f16e265">LEVEL_PINCLIENT::PIN_AttachProbed</a> (<a class="el" href="group__PIN__CONTROL.html#g7d76d5f60f83d8564bb7d75198055059">ATTACH_PROBED_CALLBACK</a> fun, VOID *val)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">LEVEL_PINCLIENT::PIN_StartProgram</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g7de96e728655962e8ecb4cfe49bd6c2c">LEVEL_PINCLIENT::PIN_StartProgramProbed</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">LEVEL_PINCLIENT::PIN_Init</a> (INT32 argc, CHAR **argv)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">CHAR *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gf54dbae6665a47abdc2f7054f2cd6b6e">LEVEL_PINCLIENT::PIN_VmFullPath</a> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g1e6d08632dccfcd10aec3fbdd2562899">LEVEL_PINCLIENT::PIN_SafeCopy</a> (VOID *dst, const VOID *src, size_t size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#g5f752650fe59150f3ba7afd2af936c2a">LEVEL_PINCLIENT::PIN_SafeCopyEx</a> (VOID *dst, const VOID *src, size_t size, <a class="el" href="group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f">EXCEPTION_INFO</a> *pExceptInfo)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">BOOL&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__PIN__CONTROL.html#gc738674dfc1a59b17f6af2da7ae083f4">LEVEL_PINCLIENT::PIN_IsActionPending</a> (<a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This group of functions is used to initialize Pin, start the application, and a call backs for events like application exit. <hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g0f271c9545b0d1b159827e718d1b7f74"></a><!-- doxytag: member="LEVEL_PINCLIENT::APPLICATION_START_CALLBACK" ref="g0f271c9545b0d1b159827e718d1b7f74" args=")(VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef VOID(* <a class="el" href="group__PIN__CONTROL.html#g0f271c9545b0d1b159827e718d1b7f74">LEVEL_PINCLIENT::APPLICATION_START_CALLBACK</a>)(VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call back function when pin initialization is finished.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g7d76d5f60f83d8564bb7d75198055059"></a><!-- doxytag: member="LEVEL_PINCLIENT::ATTACH_PROBED_CALLBACK" ref="g7d76d5f60f83d8564bb7d75198055059" args=")(VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef VOID(* <a class="el" href="group__PIN__CONTROL.html#g7d76d5f60f83d8564bb7d75198055059">LEVEL_PINCLIENT::ATTACH_PROBED_CALLBACK</a>)(VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call back function when Pin attaches to application in Probe mode<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g78a7c9eeb76f7c94dbfc382ba6a213d1"></a><!-- doxytag: member="LEVEL_PINCLIENT::CONTEXT_CHANGE_CALLBACK" ref="g78a7c9eeb76f7c94dbfc382ba6a213d1" args=")(THREADID threadIndex, CONTEXT_CHANGE_REASON reason, const CONTEXT *from, CONTEXT *to, INT32 info, VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef VOID(* <a class="el" href="group__PIN__CONTROL.html#g78a7c9eeb76f7c94dbfc382ba6a213d1">LEVEL_PINCLIENT::CONTEXT_CHANGE_CALLBACK</a>)(<a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadIndex, <a class="el" href="group__PIN__CONTROL.html#gfa1b03e06c6ab0f86fc2abc1693ce688">CONTEXT_CHANGE_REASON</a> reason, const <a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *from, <a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *to, INT32 info, VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call-back function when application changes context.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadIndex</em>&nbsp;</td><td>The Pin thread ID of the thread that changes contexts. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reason</em>&nbsp;</td><td>Cause of the context change. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>from</em>&nbsp;</td><td>Application's register state prior to the context change (NULL if <em>reason</em> is CONTEXT_CHANGE_REASON_CALLBACK). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>to</em>&nbsp;</td><td>Application's register state after context change (NULL if <em>reason</em> is CONTEXT_CHANGE_REASON_FATALSIGNAL). The tool may change this and affect the new register state. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>info</em>&nbsp;</td><td>Additional information (depends on <em>reason</em>): <ul>
<li>CONTEXT_CHANGE_REASON_FATALSIGNAL: The Unix signal number. </li>
<li>CONTEXT_CHANGE_REASON_SIGNAL: The Unix signal number. </li>
<li>CONTEXT_CHANGE_REASON_EXCEPTION: The Windows exception code. </li>
</ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gbf9966c96960a9de9bccd39a6b6d6fd7"></a><!-- doxytag: member="LEVEL_PINCLIENT::DETACH_CALLBACK" ref="gbf9966c96960a9de9bccd39a6b6d6fd7" args=")(VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef VOID(* <a class="el" href="group__PIN__CONTROL.html#gbf9966c96960a9de9bccd39a6b6d6fd7">LEVEL_PINCLIENT::DETACH_CALLBACK</a>)(VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call back function when Pin detaches from application in JIT mode<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gc0db898ddefe4b25ed1737176ce7c1ef"></a><!-- doxytag: member="LEVEL_PINCLIENT::DETACH_PROBED_CALLBACK" ref="gc0db898ddefe4b25ed1737176ce7c1ef" args=")(VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef VOID(* <a class="el" href="group__PIN__CONTROL.html#gc0db898ddefe4b25ed1737176ce7c1ef">LEVEL_PINCLIENT::DETACH_PROBED_CALLBACK</a>)(VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call back function when Pin detaches from application in Probe mode<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gf26c93895c15754aa02c56d41f81f5f4"></a><!-- doxytag: member="LEVEL_PINCLIENT::FETCH_CALLBACK" ref="gf26c93895c15754aa02c56d41f81f5f4" args=")(void *buf, ADDRINT addr, size_t size, EXCEPTION_INFO *pExceptInfo, VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef size_t(* <a class="el" href="group__PIN__CONTROL.html#gf26c93895c15754aa02c56d41f81f5f4">LEVEL_PINCLIENT::FETCH_CALLBACK</a>)(void *buf, ADDRINT addr, size_t size, <a class="el" href="group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call back function that Pin will use to fetch code bytes to be jitted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>buf</em>&nbsp;</td><td>A buffer which receives the fetched instruction bytes. This buffer is at least <em>size</em> bytes long. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>addr</em>&nbsp;</td><td>Starting address from which instruction bytes should be fetched. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>The number of bytes that should be fetched. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pExceptInfo</em>&nbsp;</td><td>If less than <em>size</em> bytes are fetched, <em>pExceptInfo</em> receives an exception that describes why more bytes could not be fetched. If Pin needs more bytes to decode the next instruction, this exception will be delivered to the application. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>The number of bytes sucessfully fetched into <em>buf</em>. This may be less than <em>size</em> (or even zero) if Pin attempts to fetch instructions from an invalid address. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gcc77dcacc144b3894f5f0fc13360cdec"></a><!-- doxytag: member="LEVEL_PINCLIENT::FINI_CALLBACK" ref="gcc77dcacc144b3894f5f0fc13360cdec" args=")(INT32 code, VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef VOID(* <a class="el" href="group__PIN__CONTROL.html#gcc77dcacc144b3894f5f0fc13360cdec">LEVEL_PINCLIENT::FINI_CALLBACK</a>)(INT32 code, VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call back function when application exits<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>code</em>&nbsp;</td><td>O/S specific termination code for the application. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g81f4a1b953b4806f7db51c881f71e80f"></a><!-- doxytag: member="LEVEL_PINCLIENT::FORK_CALLBACK" ref="g81f4a1b953b4806f7db51c881f71e80f" args=")(THREADID threadid, const CONTEXT *ctxt, VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef VOID(* <a class="el" href="group__PIN__CONTROL.html#g81f4a1b953b4806f7db51c881f71e80f">LEVEL_PINCLIENT::FORK_CALLBACK</a>)(<a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid, const <a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call-back function when the application forks.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadId</em>&nbsp;</td><td>Thread index </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctxt</em>&nbsp;</td><td>Register state immediately before/after the fork. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gbe792b6e32e9bbb19d51a1f352743a82"></a><!-- doxytag: member="LEVEL_PINCLIENT::FORK_PROBE_MODE_CALLBACK" ref="gbe792b6e32e9bbb19d51a1f352743a82" args=")(UINT32 childPid, VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef VOID(* <a class="el" href="group__PIN__CONTROL.html#gbe792b6e32e9bbb19d51a1f352743a82">LEVEL_PINCLIENT::FORK_PROBE_MODE_CALLBACK</a>)(UINT32 childPid, VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call-back function in probe mode for fork notification.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>childPid</em>&nbsp;</td><td>Process id of the child process, available after fork in parent </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g2f00e98cd79f80c871f8ac193f9c1ba8"></a><!-- doxytag: member="LEVEL_PINCLIENT::INTERCEPT_SIGNAL_CALLBACK" ref="g2f00e98cd79f80c871f8ac193f9c1ba8" args=")(THREADID tid, INT32 sig, CONTEXT *ctxt, BOOL hasHandler, const EXCEPTION_INFO *pExceptInfo, VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef BOOL(* <a class="el" href="group__PIN__CONTROL.html#g2f00e98cd79f80c871f8ac193f9c1ba8">LEVEL_PINCLIENT::INTERCEPT_SIGNAL_CALLBACK</a>)(<a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, INT32 sig, <a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, BOOL hasHandler, const <a class="el" href="group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f">EXCEPTION_INFO</a> *pExceptInfo, VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call back function when the tool intercepts a signal with <a class="el" href="group__PIN__CONTROL.html#g6a0c20f386b88de45925e3434c52e4ff">PIN_InterceptSignal()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>The Pin thread ID of the thread that handled the signal. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sig</em>&nbsp;</td><td>The signal number. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>ctxt</em>&nbsp;</td><td>The application's register state when it was interrupted by the signal. The tool may change this context if desired. If so, the application continues at the modified context. Or, if the application's signal handler is invoked, the handler is passed the modified context for its return context. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hasHandler</em>&nbsp;</td><td>TRUE if the application has a handler registered for this signal. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pExceptInfo</em>&nbsp;</td><td>If the signal represents an exception, <em>pExceptInfo</em> points to a description of the exception. If the signal is not an exception, <em>pExceptInfo</em> is NULL. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Returning TRUE tells Pin to pass the signal on to the application. Returning FALSE tells Pin to squash the signal and execution resumes at <em>ctxt</em>. </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gb3550c0044899834614bc73245f90743"></a><!-- doxytag: member="LEVEL_PINCLIENT::INTERNAL_EXCEPTION_CALLBACK" ref="gb3550c0044899834614bc73245f90743" args=")(THREADID tid, EXCEPTION_INFO *pExceptInfo, PHYSICAL_CONTEXT *pPhysCtxt, VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef <a class="el" href="group__PIN__CONTROL.html#g884814f02a548395107079cf3a4ff552">EXCEPT_HANDLING_RESULT</a>(* <a class="el" href="group__PIN__CONTROL.html#gb3550c0044899834614bc73245f90743">LEVEL_PINCLIENT::INTERNAL_EXCEPTION_CALLBACK</a>)(<a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, <a class="el" href="group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f">EXCEPTION_INFO</a> *pExceptInfo, <a class="el" href="group__PHYSICAL__CONTEXT__API.html#g5041f3f7591f9ee249b986d2bc2f7d6e">PHYSICAL_CONTEXT</a> *pPhysCtxt, VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Handler (call-back) function when pin/tool generates internal exception. This function can be registered via <a class="el" href="group__PIN__CONTROL.html#g02803b27d4a5c1ea27d07abeff4b7116">PIN_AddInternalExceptionHandler()</a> or <a class="el" href="group__PIN__CONTROL.html#g22e1f539c7159c1bc9a2aac8f8803e81">PIN_TryStart()</a>. This function becomes active only after APPLICATION_START_CALLBACK notification is delivered. Any internal exception prior to this event can't be handled.<p>
If the exception occurred while analysis routine is executed, it is legal to modify the execution control path using functions such as <a class="el" href="group__EXCEPTION__API.html#g40302a79ed756094abf1af155b6d3a0b">PIN_RaiseException()</a> or <a class="el" href="group__CONTEXT__API.html#gc12dbb3ebd227f71a9644733f6faa116">PIN_ExecuteAt()</a>. In this case, any per-thread INTERNAL_EXCEPTION_CALLBACK function registered via <a class="el" href="group__PIN__CONTROL.html#g22e1f539c7159c1bc9a2aac8f8803e81">PIN_TryStart()</a> will be unregistered automatically (similar semantics to <a class="el" href="group__PIN__CONTROL.html#g865588e1c8ec27149ab627aecabfd4c1">PIN_TryEnd()</a> for all registered notifications)<p>
<dl compact><dt><b>Note:</b></dt><dd>It is unsupported to call <a class="el" href="group__PIN__CONTROL.html#g8fa128a4393b96cc7f292d17d2ef0ba4">PIN_CallApplicationFunction()</a> in the scope of this callback</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>The Pin thread ID of the thread that generated the exception. </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>pExceptInfo</em>&nbsp;</td><td>Pointer to the EXCEPTION_INFO structure that describes the exception. If the exception should be raised in the context of the application (using <a class="el" href="group__EXCEPTION__API.html#g40302a79ed756094abf1af155b6d3a0b">PIN_RaiseException()</a>), The tool should update the exception info to match the OS logic (e.g. update exception address using <a class="el" href="group__EXCEPTION__API.html#g0e088a9cbc9053d19dc7e1c755eae000">PIN_SetExceptionAddress()</a>). </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>pPhysCtxt</em>&nbsp;</td><td>Physical register state when the exception was generated. The tool can change <em>pPhysCtxt</em> (make sure that if <a class="el" href="group__PIN__CONTROL.html#g22e1f539c7159c1bc9a2aac8f8803e81">PIN_TryStart()</a> was called, matching <a class="el" href="group__PIN__CONTROL.html#g865588e1c8ec27149ab627aecabfd4c1">PIN_TryEnd()</a> will be called) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>an <em>EXCEPT_HANDLING_RESULT</em> value </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gde47352f7f71df0632aa847aae16a274"></a><!-- doxytag: member="LEVEL_PINCLIENT::OUT_OF_MEMORY_CALLBACK" ref="gde47352f7f71df0632aa847aae16a274" args=")(size_t size, VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef VOID(* <a class="el" href="group__PIN__CONTROL.html#gde47352f7f71df0632aa847aae16a274">LEVEL_PINCLIENT::OUT_OF_MEMORY_CALLBACK</a>)(size_t size, VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call back function when pin/tool is out of memory. This function can be registered via <a class="el" href="group__PIN__CONTROL.html#gcae8a563efbe6d5f2eff743d718e5ce0">PIN_AddOutOfMemoryFunction()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the failed allocation </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g8d5ecf0344c6faa23c1ee38437538f6c"></a><!-- doxytag: member="LEVEL_PINCLIENT::PROBES_INSERTED_CALLBACK" ref="g8d5ecf0344c6faa23c1ee38437538f6c" args=")(IMG img, VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef VOID(* <a class="el" href="group__PIN__CONTROL.html#g8d5ecf0344c6faa23c1ee38437538f6c">LEVEL_PINCLIENT::PROBES_INSERTED_CALLBACK</a>)(IMG img, VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Callback function when probe insertion is complete.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>img</em>&nbsp;</td><td>Image. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g53cea46aaf83cb4d14f5e485eac688df"></a><!-- doxytag: member="LEVEL_PINCLIENT::REMOVE_INSTRUMENTATION_CALLBACK" ref="g53cea46aaf83cb4d14f5e485eac688df" args=")(VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef VOID(* <a class="el" href="group__PIN__CONTROL.html#g53cea46aaf83cb4d14f5e485eac688df">LEVEL_PINCLIENT::REMOVE_INSTRUMENTATION_CALLBACK</a>)(VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call back function when Pin removes all old instrumented code from its cache<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gc1b5679826895fc2627fe4fef50820bf"></a><!-- doxytag: member="LEVEL_PINCLIENT::THREAD_ATTACH_PROBED_CALLBACK" ref="gc1b5679826895fc2627fe4fef50820bf" args=")(VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef VOID(* <a class="el" href="group__PIN__CONTROL.html#gc1b5679826895fc2627fe4fef50820bf">LEVEL_PINCLIENT::THREAD_ATTACH_PROBED_CALLBACK</a>)(VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call-back function when an attached thread starts to run under Pin in probe mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gaf37c586368c5230ff7fba6c2bfebd01"></a><!-- doxytag: member="LEVEL_PINCLIENT::THREAD_FINI_CALLBACK" ref="gaf37c586368c5230ff7fba6c2bfebd01" args=")(THREADID threadIndex, const CONTEXT *ctxt, INT32 code, VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef VOID(* <a class="el" href="group__PIN__CONTROL.html#gaf37c586368c5230ff7fba6c2bfebd01">LEVEL_PINCLIENT::THREAD_FINI_CALLBACK</a>)(<a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadIndex, const <a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, INT32 code, VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call-back function when thread ends.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadIndex</em>&nbsp;</td><td>The Pin thread ID of the terminating thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctxt</em>&nbsp;</td><td>Register state of the thread immediately before it terminates. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>code</em>&nbsp;</td><td>O/S specific termination code for the thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g299a24d8e05412410b32b75b51564081"></a><!-- doxytag: member="LEVEL_PINCLIENT::THREAD_START_CALLBACK" ref="g299a24d8e05412410b32b75b51564081" args=")(THREADID threadIndex, CONTEXT *ctxt, INT32 flags, VOID *v)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">typedef VOID(* <a class="el" href="group__PIN__CONTROL.html#g299a24d8e05412410b32b75b51564081">LEVEL_PINCLIENT::THREAD_START_CALLBACK</a>)(<a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadIndex, <a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, INT32 flags, VOID *v)          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call-back function when thread begins.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadIndex</em>&nbsp;</td><td>The Pin thread ID of the new thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ctxt</em>&nbsp;</td><td>Initial register state for the new thread. The tool may change this. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>flags</em>&nbsp;</td><td>O/S specific flags for the new thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>The tool's call-back value. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="gfa1b03e06c6ab0f86fc2abc1693ce688"></a><!-- doxytag: member="types_vmapi.H::CONTEXT_CHANGE_REASON" ref="gfa1b03e06c6ab0f86fc2abc1693ce688" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group__PIN__CONTROL.html#gfa1b03e06c6ab0f86fc2abc1693ce688">CONTEXT_CHANGE_REASON</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Possible reasons for an application context change. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ggfa1b03e06c6ab0f86fc2abc1693ce68837cb8074065ada5ef8d27e6aebf05ae4"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_FATALSIGNAL" ref="ggfa1b03e06c6ab0f86fc2abc1693ce68837cb8074065ada5ef8d27e6aebf05ae4" args="" -->CONTEXT_CHANGE_REASON_FATALSIGNAL</em>&nbsp;</td><td>
Receipt of fatal Unix signal. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggfa1b03e06c6ab0f86fc2abc1693ce688b776a0903743c7459e82d82103c27bfd"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_SIGNAL" ref="ggfa1b03e06c6ab0f86fc2abc1693ce688b776a0903743c7459e82d82103c27bfd" args="" -->CONTEXT_CHANGE_REASON_SIGNAL</em>&nbsp;</td><td>
Receipt of handled Unix signal. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggfa1b03e06c6ab0f86fc2abc1693ce688b17b32450e56cfeef5f9d6bfb237ddab"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_SIGRETURN" ref="ggfa1b03e06c6ab0f86fc2abc1693ce688b17b32450e56cfeef5f9d6bfb237ddab" args="" -->CONTEXT_CHANGE_REASON_SIGRETURN</em>&nbsp;</td><td>
Return from Unix signal handler. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggfa1b03e06c6ab0f86fc2abc1693ce6885bd4b5a9a1bda52c8c99e3013fe39faa"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_APC" ref="ggfa1b03e06c6ab0f86fc2abc1693ce6885bd4b5a9a1bda52c8c99e3013fe39faa" args="" -->CONTEXT_CHANGE_REASON_APC</em>&nbsp;</td><td>
Receipt of Windows APC. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggfa1b03e06c6ab0f86fc2abc1693ce688e0a543355fe07b05302490d88c6a61a8"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_EXCEPTION" ref="ggfa1b03e06c6ab0f86fc2abc1693ce688e0a543355fe07b05302490d88c6a61a8" args="" -->CONTEXT_CHANGE_REASON_EXCEPTION</em>&nbsp;</td><td>
Receipt of Windows exception. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggfa1b03e06c6ab0f86fc2abc1693ce68892f2dd18a4194b3af64683e9b1d0c5f8"></a><!-- doxytag: member="CONTEXT_CHANGE_REASON_CALLBACK" ref="ggfa1b03e06c6ab0f86fc2abc1693ce68892f2dd18a4194b3af64683e9b1d0c5f8" args="" -->CONTEXT_CHANGE_REASON_CALLBACK</em>&nbsp;</td><td>
Receipt of Windows call-back. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g884814f02a548395107079cf3a4ff552"></a><!-- doxytag: member="types_vmapi.H::EXCEPT_HANDLING_RESULT" ref="g884814f02a548395107079cf3a4ff552" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group__PIN__CONTROL.html#g884814f02a548395107079cf3a4ff552">EXCEPT_HANDLING_RESULT</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Possible return values of the <a class="el" href="group__PIN__CONTROL.html#gb3550c0044899834614bc73245f90743">INTERNAL_EXCEPTION_CALLBACK</a> exception filter function <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gg884814f02a548395107079cf3a4ff552632cdc08da9d43ae549e41b7275db92e"></a><!-- doxytag: member="EHR_HANDLED" ref="gg884814f02a548395107079cf3a4ff552632cdc08da9d43ae549e41b7275db92e" args="" -->EHR_HANDLED</em>&nbsp;</td><td>
Exception is handled. Continue execution with the internal physical context. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg884814f02a548395107079cf3a4ff552e430b2bdb725b8236f81b1ce55569146"></a><!-- doxytag: member="EHR_UNHANDLED" ref="gg884814f02a548395107079cf3a4ff552e430b2bdb725b8236f81b1ce55569146" args="" -->EHR_UNHANDLED</em>&nbsp;</td><td>
Exception is not handled. Execute default system procedure for unhandled exceptions (Windows) or abort the process (Unix) </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gg884814f02a548395107079cf3a4ff552cb7efbae4aa313cf065b2e783a0da677"></a><!-- doxytag: member="EHR_CONTINUE_SEARCH" ref="gg884814f02a548395107079cf3a4ff552cb7efbae4aa313cf065b2e783a0da677" args="" -->EHR_CONTINUE_SEARCH</em>&nbsp;</td><td>
Execute next (upper level) exception filter function, if any. For the uppermost filter, this is the same as EHR_UNHANDLED semantics </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gb6974c15e664605870435c05a1bf33bd"></a><!-- doxytag: member="LEVEL_PINCLIENT::FPOINT" ref="gb6974c15e664605870435c05a1bf33bd" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group__PIN__CONTROL.html#gb6974c15e664605870435c05a1bf33bd">LEVEL_PINCLIENT::FPOINT</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
time of callback notification <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="ggb6974c15e664605870435c05a1bf33bd1bf77c6f3a5ac150cf7fb1c10f0429cf"></a><!-- doxytag: member="FPOINT_BEFORE" ref="ggb6974c15e664605870435c05a1bf33bd1bf77c6f3a5ac150cf7fb1c10f0429cf" args="" -->FPOINT_BEFORE</em>&nbsp;</td><td>
Call-back in parent, just before fork. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggb6974c15e664605870435c05a1bf33bdcba5c8d0ce036ae68ab51e180e5f7d35"></a><!-- doxytag: member="FPOINT_AFTER_IN_PARENT" ref="ggb6974c15e664605870435c05a1bf33bdcba5c8d0ce036ae68ab51e180e5f7d35" args="" -->FPOINT_AFTER_IN_PARENT</em>&nbsp;</td><td>
Call-back in parent, immediately after fork. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="ggb6974c15e664605870435c05a1bf33bd35c7c8f0fae3a1a1cbe29d6d79045c88"></a><!-- doxytag: member="FPOINT_AFTER_IN_CHILD" ref="ggb6974c15e664605870435c05a1bf33bd35c7c8f0fae3a1a1cbe29d6d79045c88" args="" -->FPOINT_AFTER_IN_CHILD</em>&nbsp;</td><td>
Call-back in child, immediately after fork. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga8378cf542c080182b597101ee265983"></a><!-- doxytag: member="LEVEL_PINCLIENT::SYMBOL_INFO_MODE" ref="ga8378cf542c080182b597101ee265983" args="" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="group__PIN__CONTROL.html#ga8378cf542c080182b597101ee265983">LEVEL_PINCLIENT::SYMBOL_INFO_MODE</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
List of supported modes of symbolic information delivery. Used in <a class="el" href="group__PIN__CONTROL.html#g6a86d823a691298dbe8b9ca73f328761">PIN_InitSymbolsAlt()</a>. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="gga8378cf542c080182b597101ee265983f2d53b280bf156a6e95c5f7448f52831"></a><!-- doxytag: member="NO_SYMBOLS" ref="gga8378cf542c080182b597101ee265983f2d53b280bf156a6e95c5f7448f52831" args="" -->NO_SYMBOLS</em>&nbsp;</td><td>
No symbols required. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga8378cf542c080182b597101ee265983e0d6a139760597f64a0800449d5f8dbc"></a><!-- doxytag: member="EXPORT_SYMBOLS" ref="gga8378cf542c080182b597101ee265983e0d6a139760597f64a0800449d5f8dbc" args="" -->EXPORT_SYMBOLS</em>&nbsp;</td><td>
Only symbols taken from export table are provided. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga8378cf542c080182b597101ee2659834b60203d748803ef3af28de8d2900666"></a><!-- doxytag: member="DEBUG_SYMBOLS" ref="gga8378cf542c080182b597101ee2659834b60203d748803ef3af28de8d2900666" args="" -->DEBUG_SYMBOLS</em>&nbsp;</td><td>
Debug symbols (currently implemented as DEBUG_OR_EXPORT_SYMBOLS). </td></tr>
<tr><td valign="top"><em><a class="anchor" name="gga8378cf542c080182b597101ee2659835ac095606383aa2df08020d95b4f8009"></a><!-- doxytag: member="DEBUG_OR_EXPORT_SYMBOLS" ref="gga8378cf542c080182b597101ee2659835ac095606383aa2df08020d95b4f8009" args="" -->DEBUG_OR_EXPORT_SYMBOLS</em>&nbsp;</td><td>
First debug symbols if available, otherwise export symbols. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g3017af7e44f9c1926bd903a186064472"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddApplicationStartFunction" ref="g3017af7e44f9c1926bd903a186064472" args="(APPLICATION_START_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddApplicationStartFunction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#g0f271c9545b0d1b159827e718d1b7f74">APPLICATION_START_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a notification function that is called after pin initialization is finished. This notification function is available when pin launches the application and when pin attaches to a running process.<p>
When pin launches the application, this notification function is called on the application's main thread.<p>
When pin attaches to a running process, this notification function is called on a dedicated thread which is not part of the application's threads.<br>
 When it is called, all the application's threads are running.<p>
When Pin starts running a program, it calls into the tool several times in the following order:<br>
 1. Calls the tool's main() function.<br>
 2. If the tool set up a notification with <a class="el" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction()</a>, Pin calls this call-back for each image that is already loaded in the application's address space at the point when Pin attaches to it.<br>
 3. Calls any notification call-backs set up with <a class="el" href="group__PIN__CONTROL.html#g3017af7e44f9c1926bd903a186064472">PIN_AddApplicationStartFunction()</a>.<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Function to be called at application start. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Windows, Linux<br>
 <b>CPU:</b> IA-32, Intel(R) 64<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gdb70938ef31309447fe65a653667334a"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddContextChangeFunction" ref="gdb70938ef31309447fe65a653667334a" args="(CONTEXT_CHANGE_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddContextChangeFunction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#g78a7c9eeb76f7c94dbfc382ba6a213d1">CONTEXT_CHANGE_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a notification function that is called immediately before the application changes context due to receipt of an asynchronous event such as Unix signal or Windows APC.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function to execute immediately before the application changes context. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g451060f5e998243df750ac16720cadcf"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddDetachFunction" ref="g451060f5e998243df750ac16720cadcf" args="(DETACH_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddDetachFunction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#gbf9966c96960a9de9bccd39a6b6d6fd7">DETACH_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call func immediately before Pin relinquishes control of the application through <a class="el" href="group__PIN__CONTROL.html#g0f3537980bb5ab3b0411a83426a32370">PIN_Detach()</a>.<p>
At this stage no more instrumentation/analysis callbacks will be called<p>
This function is called one time for the process. It may be called by any thread. Pin memory is not freed at this moment.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Call back function to execute before detaching </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gdb1a5f5589efab9dd67bafe7cf5c37a3"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddDetachFunctionProbed" ref="gdb1a5f5589efab9dd67bafe7cf5c37a3" args="(DETACH_PROBED_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddDetachFunctionProbed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#gc0db898ddefe4b25ed1737176ce7c1ef">DETACH_PROBED_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a notification function that is called immediately after Pin relinquishes control of the application through <a class="el" href="group__PIN__CONTROL.html#g12d2f1c80491b151ce004ba459c5695e">PIN_DetachProbed()</a>. There can be more than one Detach callback function.<br>
 When this callback function is called, it is guaranteed that Pin removed all probes from the application code and that no other callback function will be called afterwards (except from additional Detach callback functions).<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Call back function to execute before detaching </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Windows, Linux<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g5ae6f03e5b5cd137cceee6d735aa7b04"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddFetchFunction" ref="g5ae6f03e5b5cd137cceee6d735aa7b04" args="(FETCH_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddFetchFunction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#gf26c93895c15754aa02c56d41f81f5f4">FETCH_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Called to register a function That will become the function that Pin calls to fetch application instructions. Pin sometimes attempt to fetch instructions from an invalid address, and the call-back needs to handle this correctly. If multiple functions are registered using this API, only the last one registered is used<p>
Pin cannot automatically detect self-modifying code (SMC) when a tool uses this API. Therefore, such tools take over responsibility for detecting SMC and must invalidate the code cache with <a class="el" href="group__CODECACHE__API.html#gef086e43aaa039bd0c0e936b32e19869">CODECACHE_InvalidateRange()</a> if self-modifying code is detected.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>The tool's call-back function. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>The tool's call-back value.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gd5efea3f1ee5611af535e22f35bce145"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddFiniFunction" ref="gd5efea3f1ee5611af535e22f35bce145" args="(FINI_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddFiniFunction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#gcc77dcacc144b3894f5f0fc13360cdec">FINI_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call func immediately before the application exits. The function is not an instrumentation function--it cannot insert instrumentation. There can be more than one Fini function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Call back function is passed exit code and val </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g6b3bfbcdcbf17e0b48c9fb1e38acfd04"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddFiniUnlockedFunction" ref="g6b3bfbcdcbf17e0b48c9fb1e38acfd04" args="(FINI_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddFiniUnlockedFunction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#gcc77dcacc144b3894f5f0fc13360cdec">FINI_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a function to be called when the application is about to exit. The registered function will be executed in a thread that does not hold any thread synchronization lock in Pin. It means that this callback function can be executed concurrently with other Pin callbacks and APIs.<br>
 All callbacks registered by this function will be executed before any callback registered by the <a class="el" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction()</a> function.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Callback function to be registered </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g7e45677714ab29a8d249f772de89f170"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddFollowChildProcessFunction" ref="g7e45677714ab29a8d249f772de89f170" args="(FOLLOW_CHILD_PROCESS_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddFollowChildProcessFunction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__CHILD__PROCESS__API.html#gcb01db8476fb5a6b4d86f09a336fe15f">FOLLOW_CHILD_PROCESS_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a notification function that is called before a child/exec-ed process is starting to execute<p>
NOTE: Only one callback can be registered<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Windows, Linux<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gd7da7a3f8249e8708524ee4b35f6e9ce"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddForkFunction" ref="gd7da7a3f8249e8708524ee4b35f6e9ce" args="(FPOINT point, FORK_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddForkFunction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#gb6974c15e664605870435c05a1bf33bd">FPOINT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__PIN__CONTROL.html#g81f4a1b953b4806f7db51c881f71e80f">FORK_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a notification handler that is called when the application forks a new process. The function can only be used on Linux.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>where</em>&nbsp;</td><td>Tells when to make the call-back and tells whether the parent or child makes the call-back. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function to execute. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>Value passed as final parameter to call-back.</td></tr>
  </table>
</dl>
If the fork function fails, the FPOINT_AFTER_IN_PARENT function, if it exists, is still called.<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g03f417057aac38bb39103bcaabef6f72"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddForkFunctionProbed" ref="g03f417057aac38bb39103bcaabef6f72" args="(FPOINT point, FORK_PROBE_MODE_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddForkFunctionProbed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#gb6974c15e664605870435c05a1bf33bd">FPOINT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>point</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__PIN__CONTROL.html#gbe792b6e32e9bbb19d51a1f352743a82">FORK_PROBE_MODE_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a notification handler that is called when the application forks a new process. If vfork() is called in application, Pin replaces it with fork(). This replacement is needed to keep Pin/Tool state consistent and prevent memory overlap in callbacks following the fork/vfork. The function can only be used on Linux.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>where</em>&nbsp;</td><td>Tells when to make the call-back and tells whether the parent or child makes the call-back. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function to execute. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>v</em>&nbsp;</td><td>Value passed as final parameter to call-back.</td></tr>
  </table>
</dl>
If the fork function fails, the FPOINT_AFTER_IN_PARENT function, if it exists, is still called.<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g02803b27d4a5c1ea27d07abeff4b7116"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddInternalExceptionHandler" ref="g02803b27d4a5c1ea27d07abeff4b7116" args="(INTERNAL_EXCEPTION_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddInternalExceptionHandler           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#gb3550c0044899834614bc73245f90743">INTERNAL_EXCEPTION_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a global (not per-thread) notification handler function that is called upon receipt of any unhandled internal exception in Pin or the tool. This handler does not catch exceptions that are generated by the application, nor does it catch exceptions that are handled by <a class="el" href="group__PIN__CONTROL.html#g22e1f539c7159c1bc9a2aac8f8803e81">PIN_TryStart()</a> / <a class="el" href="group__PIN__CONTROL.html#g865588e1c8ec27149ab627aecabfd4c1">PIN_TryEnd()</a>. The handler is active for all the application's threads, it should be called in tool's main() before <a class="el" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram()</a>. If it is called after <a class="el" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram()</a> is called, it will be ignored. The user can register up to MAX_IEH_CALLBACKS global notification functions.<p>
<dl compact><dt><b>Note:</b></dt><dd>This function should be used for permanent global call-back registration (as opposed to <a class="el" href="group__PIN__CONTROL.html#g22e1f539c7159c1bc9a2aac8f8803e81">PIN_TryStart()</a> / <a class="el" href="group__PIN__CONTROL.html#g865588e1c8ec27149ab627aecabfd4c1">PIN_TryEnd()</a> pair which should be used for function scope registration).</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Handler function to execute upon receipt of internal exception in pin/tool. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gcae8a563efbe6d5f2eff743d718e5ce0"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddOutOfMemoryFunction" ref="gcae8a563efbe6d5f2eff743d718e5ce0" args="(OUT_OF_MEMORY_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddOutOfMemoryFunction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#gde47352f7f71df0632aa847aae16a274">OUT_OF_MEMORY_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a notification function that is called when pin/tool is out of memory.<br>
 Try to reduce memory consumption when this notification function is called.<br>
 Any implicit or explicit usage of malloc()/realloc() etc. in this notification function might cause an infinite recursion.<br>
 The call to the notification function is NOT serialized by pin. The user can't assume anything about the locks state while the notification is delivered (as out of memory condition can occur anywhere). Avoid dead-locks by careful design of the notification function.<br>
<p>
A tool can register only one notification function.<br>
 A new notification function registration overwrites any previous registration.<br>
 To disable the notification function, pass a NULL function pointer.<br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Call back function is passed the size of the failing allocation </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; PROBE<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g34db6607a35ac556c2342c7352a47435"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddProbesInsertedFunction" ref="g34db6607a35ac556c2342c7352a47435" args="(PROBES_INSERTED_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddProbesInsertedFunction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#g8d5ecf0344c6faa23c1ee38437538f6c">PROBES_INSERTED_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a notification function that is called when Pin has inserted all probes.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>img</em>&nbsp;</td><td>Image. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Callback function to execute when probe insertion is complete. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gf2a8bb20cd2e70ca10e4b9a4471e171e"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddThreadAttachProbedFunction" ref="gf2a8bb20cd2e70ca10e4b9a4471e171e" args="(THREAD_ATTACH_PROBED_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddThreadAttachProbedFunction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#gc1b5679826895fc2627fe4fef50820bf">THREAD_ATTACH_PROBED_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API is useful when Pin is run in probe mode and attaches to a running process. Tools may use this API to register a notification that is called by each application thread.<p>
After Pin attaches to the process, Pin first notifies the tool of any images that are loaded (see <a class="el" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction()</a>) and then notifies the tool that initialization is complete (see <a class="el" href="group__PIN__CONTROL.html#g3017af7e44f9c1926bd903a186064472">PIN_AddApplicationStartFunction()</a>). After that, each thread in the application calls the notification set up by <a class="el" href="group__PIN__CONTROL.html#gf2a8bb20cd2e70ca10e4b9a4471e171e">PIN_AddThreadAttachProbedFunction()</a>. After each thread returns from this notification, it resumes execution in the application code.<p>
Note, this notification happens only for threads that exist in the process at the time that Pin attaches. It does not happen for threads that are created in the process after Pin is already attached.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function to execute for the attached thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g2d6c3eea4ebe3e76baed4481b079e3b1"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddThreadFiniFunction" ref="g2d6c3eea4ebe3e76baed4481b079e3b1" args="(THREAD_FINI_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddThreadFiniFunction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#gaf37c586368c5230ff7fba6c2bfebd01">THREAD_FINI_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a notification function that is called when an application thread terminates. The call-back happens even for the application's root (initial) thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function to execute for the terminating thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gd990464123111fae4a3e575039b11af7"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AddThreadStartFunction" ref="gd990464123111fae4a3e575039b11af7" args="(THREAD_START_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AddThreadStartFunction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#g299a24d8e05412410b32b75b51564081">THREAD_START_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a notification function that is called when a thread starts executing in the application. The call-back happens even for the application's root (initial) thread.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Call-back function to execute for the new thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gcfca774907868814fc1b1fbe3f16e265"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_AttachProbed" ref="gcfca774907868814fc1b1fbe3f16e265" args="(ATTACH_PROBED_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_AttachProbed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#g7d76d5f60f83d8564bb7d75198055059">ATTACH_PROBED_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initiate Pin attach request in probe mode. If Pin was not detached (using <a class="el" href="group__PIN__CONTROL.html#g12d2f1c80491b151ce004ba459c5695e">PIN_DetachProbed()</a>) this function will be ignored.<br>
 The given notification function will be called immediately after Pin regain control of the application. It is expected that in the scope of this callback, the tool will register callbacks (e.g. <a class="el" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction()</a>) and will reconfigure itself (if needed). In order to change tool's KNOB value, use <a class="el" href="group__KNOB__BASIC.html">KNOB: Basics</a><p>
<dl compact><dt><b>Note:</b></dt><dd>Pin's state can't be reconfigured in the scope of the callback function (don't use <a class="el" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init()</a>, <a class="el" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols()</a>, <a class="el" href="group__PIN__CONTROL.html#g7de96e728655962e8ecb4cfe49bd6c2c">PIN_StartProgramProbed()</a> etc.)</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>fun</em>&nbsp;</td><td>Call back function to execute when starting to attach </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>val</em>&nbsp;</td><td>Value to be passed to fun when it is called</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Windows, Linux<br>
 <b>CPU:</b> IA32, Intel64<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g8fa128a4393b96cc7f292d17d2ef0ba4"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_CallApplicationFunction" ref="g8fa128a4393b96cc7f292d17d2ef0ba4" args="(CONTEXT *ctxt, THREADID tid, CALLINGSTD_TYPE cstype, AFUNPTR origFunPtr,...)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_CallApplicationFunction           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__PROTO__API.html#g54651b96181be964a6a914420a4e021c">CALLINGSTD_TYPE</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>cstype</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>AFUNPTR&nbsp;</td>
          <td class="mdname" nowrap> <em>origFunPtr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>...</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API allows a tool to call a function inside the application. The function is executed under control of Pin's JIT compiler, and the application code is instrumented normally.<p>
<a class="el" href="group__PIN__CONTROL.html#g8fa128a4393b96cc7f292d17d2ef0ba4">PIN_CallApplicationFunction()</a> can be called from a replacement routine or an analysis routine. Pin restores the application context before calling the application function and then restores the tool context before returning to the replacement/analysis function. Tools should not call application functions directly because the context will not be switched properly.<p>
Note that if the tool changes the application register context using <a class="el" href="group__CONTEXT__API.html#ga3f8746ccdac1c1fbcb2e2f3f3cd7bcb">PIN_SetContextReg()</a>, and pass this context to <a class="el" href="group__PIN__CONTROL.html#g8fa128a4393b96cc7f292d17d2ef0ba4">PIN_CallApplicationFunction()</a>, the updated context will be used by the application function.<p>
<a class="el" href="group__RTN__BASIC__API.html#gdba66dc89d3e71ce4413aa55eb3d450f">RTN_ReplaceSignature()</a> should be used to replace the application routine, passing the application context and the original function pointer as additional arguments to the replacement function. <a class="el" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall()</a> should be used to access the analysis routine, passing the application context and the original function pointer as arguments.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ctxt</em>&nbsp;</td><td>The application register context of the call site. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tid</em>&nbsp;</td><td>The Pin id of the current thread (see <a class="el" href="group__PIN__THREAD__API.html#g55f2f9d397201431580d20123620dcfa">PIN_ThreadId()</a>) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cstype</em>&nbsp;</td><td>The calling standard used for compiling this function (CALLINGSTD_DEFAULT recommended). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>origFunPtr</em>&nbsp;</td><td>The entry point of the application function to be called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td>List of function argument type and size.</td></tr>
  </table>
</dl>
See <a class="el" href="group__PROTO__API.html#gae8aea17c700049aa39c32c370874f47">PIN_PARG</a> for the recommended method of passing function arguments. <a class="el" href="group__PROTO__API.html#gb8a98de8d0939ae762c9b890097a350b">PIN_PARG_END()</a> must end the argument list, even if the function has no arguments. If the application function has a return value, it must appear first in the argument list.<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT only<br>
 <b>O/S</b>: Linux and Windows<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g0f3537980bb5ab3b0411a83426a32370"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_Detach" ref="g0f3537980bb5ab3b0411a83426a32370" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_Detach           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Pin relinquishes control of the application and the original uninstrumented code is executed. On Linux: This routine may be invoked in JIT mode from analysis or instrumentation routine. It also can be invoked from a callback or from any special thread, dedicated by Pin tool and invisible for Pin VM.<p>
The request for detach is considered in Pin as asynchronous. <a class="el" href="group__PIN__CONTROL.html#g0f3537980bb5ab3b0411a83426a32370">PIN_Detach()</a> sets the request inside Pin and exits immediately. Note, the <a class="el" href="group__PIN__CONTROL.html#g0f3537980bb5ab3b0411a83426a32370">PIN_Detach()</a> procedure does not wait for detach completion.<p>
From user's perspective, calling to <a class="el" href="group__PIN__CONTROL.html#g0f3537980bb5ab3b0411a83426a32370">PIN_Detach()</a> doesn't mean that instrumentation function, analysis routines or callbacks will not be called any more. Since <a class="el" href="group__PIN__CONTROL.html#g0f3537980bb5ab3b0411a83426a32370">PIN_Detach()</a> is called, Pin performs detach at a point convenient for this procedure. Detach process, started by Pin can't be blocked, and will not run forever. User can't detach one thread; all threads are running natively after <a class="el" href="group__PIN__CONTROL.html#g0f3537980bb5ab3b0411a83426a32370">PIN_Detach()</a>.<p>
<a class="el" href="group__PIN__CONTROL.html#g451060f5e998243df750ac16720cadcf">PIN_AddDetachFunction()</a> lets user to receive notification when detach is completed. At this momment Pin notifyes that all threads are stopped inside VM and no more instrumentation function, analysis routines or callbacks will be called.<p>
Actually, Pin doesn't free memory used for Pin objects. But in the future, when re-attach will be possible, this memory will be reused.<p>
Pin runs an auxiliary process, which communicates with the running application process via debug interface. The auxiliary process is temporary and exits immediately when detach is completed. But for user it means that debugger can not be attached to application process at this time.<p>
On Windows amd Mac Os the function must be invoked through an analysis routine. Invoking via instrumentation routines could cause Pin to misbehave See Tests/detach.C for an example of its use.<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows, &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g12d2f1c80491b151ce004ba459c5695e"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_DetachProbed" ref="g12d2f1c80491b151ce004ba459c5695e" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_DetachProbed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initiate Pin detach request in probe mode. The user can get a notification when the detach operation has been completed (via callback registration using <a class="el" href="group__PIN__CONTROL.html#gdb1a5f5589efab9dd67bafe7cf5c37a3">PIN_AddDetachFunctionProbed()</a>). In the scope of this operation, Pin removes all probes set by Pin &amp; tool, in addition, it guarantees that no callback function registered previously by the tool will be called.<br>
 If Pin has already detached (using <a class="el" href="group__PIN__CONTROL.html#g12d2f1c80491b151ce004ba459c5695e">PIN_DetachProbed()</a>), or if Pin has not fully started yet (the notification function registered by <a class="el" href="group__PIN__CONTROL.html#g3017af7e44f9c1926bd903a186064472">PIN_AddApplicationStartFunction()</a> was not yet delivered to the tool), this function will be ignored.<br>
<p>
<dl compact><dt><b>Note:</b></dt><dd>Even though Pin removes all probes, replacement functions can still be active (for example, if the replacement function is still located on the call stack of one of the threads). It is the tool responsibility to handle these scenarios.<br>
</dd></dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Windows, Linux<br>
 <b>CPU:</b> IA32, Intel64<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g078bed712e6822f3b42a7b4815ba5c0a"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_Init" ref="g078bed712e6822f3b42a7b4815ba5c0a" args="(INT32 argc, CHAR **argv)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">BOOL LEVEL_PINCLIENT::PIN_Init           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">INT32&nbsp;</td>
          <td class="mdname" nowrap> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>CHAR **&nbsp;</td>
          <td class="mdname" nowrap> <em>argv</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize Pin system. Must be called before <a class="el" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>argc</em>&nbsp;</td><td>argc value passed to main </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>argv</em>&nbsp;</td><td>argv value passed to main, encoded in UTF8 (a superset of ASCII)</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>true if an error was detected parsing the command line</dd></dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga6749650a8dce7151075fcc9345f7bd9"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_InitSymbols" ref="ga6749650a8dce7151075fcc9345f7bd9" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_InitSymbols           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize symbol table code. Pin does not read symbols unless this is called. Must be called before <a class="el" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a><p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g6a86d823a691298dbe8b9ca73f328761"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_InitSymbolsAlt" ref="g6a86d823a691298dbe8b9ca73f328761" args="(SYMBOL_INFO_MODE mode)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">BOOL LEVEL_PINCLIENT::PIN_InitSymbolsAlt           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__CONTROL.html#ga8378cf542c080182b597101ee265983">SYMBOL_INFO_MODE</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>mode</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Initialize symbol table code with explicitly specified mode of symbol support. <br>
 Pin does not read symbols unless this is called. <br>
 Must be called before <a class="el" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>. <br>
 Alternative to <a class="el" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols()</a> on Windows. <br>
 On Linux &amp; MacOS it is implemented as <a class="el" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols()</a> <br>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mode</em>&nbsp;</td><td>Explicit mode of symbol support. Valid values: <br>
 EXPORT_SYMBOLS Only symbols taken from export table are provided. Line information is not available. <br>
 DEBUG_OR_EXPORT_SYMBOLS First debug symbols if available, otherwise export symbols. This mode is set by <a class="el" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols()</a> <br>
 This parameter is ignored on Linux &amp; MacOS. <br>
</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>TRUE if the operation succeeded <br>
</dd></dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Windows, Linux &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g51f4fcede5894981b70f3d73cbdb39f4"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_InsertCallProbed" ref="g51f4fcede5894981b70f3d73cbdb39f4" args="(ADDRINT addr, AFUNPTR funptr,...)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_InsertCallProbed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ADDRINT&nbsp;</td>
          <td class="mdname" nowrap> <em>addr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>AFUNPTR&nbsp;</td>
          <td class="mdname" nowrap> <em>funptr</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>&nbsp;</td>
          <td class="mdname" nowrap> <em>...</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a call to an analysis routine relative to a location. In this location we expect to find a safe instruction, i.e. an instruction which is large enough to be replaced entirely with a jump instruction (i.e. 5/7 bytes long), it is not a control flow instruction, and it doesn't have memory operand.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>the application address to instrument </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>funptr</em>&nbsp;</td><td>the analysis function </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>...</em>&nbsp;</td><td><a class="el" href="group__INST__ARGS.html#g7e2c955c99fa84246bb2bce1525b5681">IARG_TYPE</a>. The list must end with IARG_END.</td></tr>
  </table>
</dl>
<a class="el" href="group__PIN__CONTROL.html#g7de96e728655962e8ecb4cfe49bd6c2c">PIN_StartProgramProbed()</a> must be used when using this API.<p>
Some restrictions apply when using IARG_CONTEXT. See <a class="el" href="group__INST__ARGS.html">Instrumentation arguments</a> for more information. IARG_THREAD_ID is not supported.<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: All<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g6a0c20f386b88de45925e3434c52e4ff"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_InterceptSignal" ref="g6a0c20f386b88de45925e3434c52e4ff" args="(INT32 sig, INTERCEPT_SIGNAL_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">BOOL LEVEL_PINCLIENT::PIN_InterceptSignal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">INT32&nbsp;</td>
          <td class="mdname" nowrap> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__PIN__CONTROL.html#g2f00e98cd79f80c871f8ac193f9c1ba8">INTERCEPT_SIGNAL_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Establish an interceptor function for signals delivered to the application. Tools should never call sigaction() directly to handle signals. The interceptor function is called whenever the application receives the requested signal, regardless of whether the application has a handler for that signal. The tool's handler can then decide whether the signal should be forwarded to the application.<p>
There are two intended usage models for this API, which are both advanced features. If your tool merely needs to be notified of signals that are sent to the application, use <a class="el" href="group__PIN__CONTROL.html#gdb70938ef31309447fe65a653667334a">PIN_AddContextChangeFunction()</a> instead.<p>
In one usage model, a tool can take over ownership of a signal in order to use the signal as an asynchronous communication mechanism to the outside world. For example, if a tool intercepts SIGUSR1, a user of the tool could send this signal and tell the tool to do something. In this usage model, the tool may want to call <a class="el" href="group__PIN__CONTROL.html#g048709607373930698fb578b7150815d">PIN_UnblockSignal()</a> so that it will receive the signal even if the application attempts to block it.<p>
In the second usage model, the tool may need to "squash" certain signals that the application generates. For example, a tool that forces speculative execution in the application may want to intercept and squash exceptions generated in the speculative code.<p>
A tool can set only one "intercept" handler for a particular signal, so a new handler overwrites any previous handler for the same signal. To disable a handler, pass a NULL function pointer.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sig</em>&nbsp;</td><td>The signal number to intercept, which may not be SIGKILL or SIGSTOP. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>The tool's intercept function, or NULL. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the intercept function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>TRUE on success (always FALSE on Windows).</dd></dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gc738674dfc1a59b17f6af2da7ae083f4"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_IsActionPending" ref="gc738674dfc1a59b17f6af2da7ae083f4" args="(THREADID tid)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">BOOL LEVEL_PINCLIENT::PIN_IsActionPending           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>tid</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This function is useful when an analysis routine might block for an indefinite period of time. In such cases, the analysis code can periodically call <a class="el" href="group__PIN__CONTROL.html#gc738674dfc1a59b17f6af2da7ae083f4">PIN_IsActionPending()</a> to see if the thread has some pending action that needs to be handled in the Pin VM. If so, the analysis routine should return back to the VM, either by returning or by calling <a class="el" href="group__CONTEXT__API.html#gc12dbb3ebd227f71a9644733f6faa116">PIN_ExecuteAt()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>The ID of the calling thread.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>TRUE if the thread has a pending action in the Pin VM.</dd></dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g4eaf8017949dc10cb62476e6d0bceda5"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_IsProbeMode" ref="g4eaf8017949dc10cb62476e6d0bceda5" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">BOOL LEVEL_PINCLIENT::PIN_IsProbeMode           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<dl compact><dt><b>Returns:</b></dt><dd>Return TRUE if -probe on command line or if Tool started application calling <a class="el" href="group__PIN__CONTROL.html#g7de96e728655962e8ecb4cfe49bd6c2c">PIN_StartProgramProbed()</a>.<br>
</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd>Tool can run in Probe mode without specifying -probe on the command line. This switch is provided as a convenience. In that case, <a class="el" href="group__PIN__CONTROL.html#g4eaf8017949dc10cb62476e6d0bceda5">PIN_IsProbeMode()</a> will return FALSE before <a class="el" href="group__PIN__CONTROL.html#g7de96e728655962e8ecb4cfe49bd6c2c">PIN_StartProgramProbed()</a> was called (Since the default running mode is JIT).</dd></dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g761d2835019d91668430baa4323e5234"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_IsSafeForProbedInsertion" ref="g761d2835019d91668430baa4323e5234" args="(ADDRINT addr)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">BOOL LEVEL_PINCLIENT::PIN_IsSafeForProbedInsertion           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ADDRINT&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>addr</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Check if the given location is safe for probe insertion. This means that the location contains an instruction which is large enough to be replaced entirely with a jump instruction (i.e. 5/7 bytes long), it is not a control flow instruction, and it doesn't have memory operand.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>address</em>&nbsp;</td><td>the application address to instrument </td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>TRUE/FALSE if the location is safe</dd></dl>
<a class="el" href="group__PIN__CONTROL.html#g7de96e728655962e8ecb4cfe49bd6c2c">PIN_StartProgramProbed()</a> must be used when using this API.<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: All<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gc5d4cd777e5c34bb760ea6768e054f20"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_LockClient" ref="gc5d4cd777e5c34bb760ea6768e054f20" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_LockClient           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Some Pin API functions must be called when the thread is holding this lock. See also <a class="el" href="group__PIN__CONTROL.html#ga4d21b5ab38ba60932969d0d37e4f5de">PIN_UnlockClient</a>.<br>
 This function can be used in any thread, including any internal thread spawned by the tool.<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g80c35ab4c9835fa66947ecd50f09fd59"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_RemoveFiniFunctions" ref="g80c35ab4c9835fa66947ecd50f09fd59" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_RemoveFiniFunctions           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Invalidates all the Fini callback functions registered via <a class="el" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>; Fini callbacks will no longer be called before the application exits.<p>
Must be called prior to invoking <a class="el" href="group__PIN__CONTROL.html#g0f3537980bb5ab3b0411a83426a32370">PIN_Detach</a> if the tool has previously registered Fini callbacks and libc.so is not yet loaded into memory yet for a dynamically linked binary.<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gaee2fe5932a3cc759d9968820be6e15d"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_RemoveInstrumentation" ref="gaee2fe5932a3cc759d9968820be6e15d" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_RemoveInstrumentation           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
All instrumentation is removed. When application code is executed the instrumentation routines will be called to reinstrument all code. Similarly, any ahead-of-time instrumentation will be reapplied if the relevant code is re-executed.<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g1e6d08632dccfcd10aec3fbdd2562899"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_SafeCopy" ref="g1e6d08632dccfcd10aec3fbdd2562899" args="(VOID *dst, const VOID *src, size_t size)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">size_t LEVEL_PINCLIENT::PIN_SafeCopy           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy the specified number of bytes from a source memory region to a destination memory region. The function guarantees safe return to the caller even if the source or destination regions are inaccessible (entirely or partially).<p>
Tools should use this function to ensure safe access to the original content of the application's memory. For example, on Windows, Pin replaces certain TEB fields when running analysis routines in the tool. If the tool accesses these fields directly, it would see the values assigned by Pin rather than the original ones. On the contrary, <a class="el" href="group__PIN__CONTROL.html#g1e6d08632dccfcd10aec3fbdd2562899">PIN_SafeCopy()</a> always reads and modifies the original application's values of these fields.<p>
This function can be used in any thread, including any internal thread spawned by the tool.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>dst</em>&nbsp;</td><td>destination region </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src</em>&nbsp;</td><td>region to copy from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>number of bytes to copy</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Number of bytes successfully copied from the source to the destination region.</dd></dl>
<dl compact><dt><b>Note:</b></dt><dd><a class="el" href="group__PIN__CONTROL.html#g1e6d08632dccfcd10aec3fbdd2562899">PIN_SafeCopy()</a> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.</dd></dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g5f752650fe59150f3ba7afd2af936c2a"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_SafeCopyEx" ref="g5f752650fe59150f3ba7afd2af936c2a" args="(VOID *dst, const VOID *src, size_t size, EXCEPTION_INFO *pExceptInfo)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">size_t LEVEL_PINCLIENT::PIN_SafeCopyEx           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>dst</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>size_t&nbsp;</td>
          <td class="mdname" nowrap> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__EXCEPTION__API.html#gdd29f27899c5a5f3e140bbe3af31759f">EXCEPTION_INFO</a> *&nbsp;</td>
          <td class="mdname" nowrap> <em>pExceptInfo</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Copy the specified number of bytes from a source memory region to a destination memory region. The function guarantees safe return to the caller even if the source or destination regions are inaccessible (entirely or partially).<p>
In addition to the <a class="el" href="group__PIN__CONTROL.html#g1e6d08632dccfcd10aec3fbdd2562899">PIN_SafeCopy</a> functionality, this function allows the tool to obtain detailed exception information in case of failure.<p>
This function can be used in any thread, including any internal thread spawned by the tool.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>dst</em>&nbsp;</td><td>destination region </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>src</em>&nbsp;</td><td>region to copy from </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>size</em>&nbsp;</td><td>number of bytes to copy </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pExceptInfo</em>&nbsp;</td><td>pointer to the structure that receives the exception information in case of failure.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>Number of bytes successfully copied from the source to the destination region. If the function fails to copy all bytes, it provides detailed description of the failure in the <em></em> </dd></dl>
<p>
structure.<p>
<dl compact><dt><b>Note:</b></dt><dd>The exception address in the returned exception information always has zero value. If the tool wants to raise this exception on behalf of the application, it should use <a class="el" href="group__EXCEPTION__API.html#g0e088a9cbc9053d19dc7e1c755eae000">PIN_SetExceptionAddress</a> function to set an appropriate exception address before passing the exception information to the <a class="el" href="group__EXCEPTION__API.html#g40302a79ed756094abf1af155b6d3a0b">PIN_RaiseException</a> function.<p>
<a class="el" href="group__PIN__CONTROL.html#g5f752650fe59150f3ba7afd2af936c2a">PIN_SafeCopyEx()</a> should not be called before the application has been started. For instance, it cannot be called in an Image load callback. Unexpected results will occur.</dd></dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gdfaa67ec042ca4a007869b9d2cc080b9"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_StartProgram" ref="gdfaa67ec042ca4a007869b9d2cc080b9" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_StartProgram           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Starts executing the application, when Pin is in JIT mode, which is the default. Note that <a class="el" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init()</a> must be called before <a class="el" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram()</a>.<p>
The <a class="el" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram()</a> function never returns. It also unwinds the tool's stack, so any local (stack based) variables are lost.<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g7de96e728655962e8ecb4cfe49bd6c2c"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_StartProgramProbed" ref="g7de96e728655962e8ecb4cfe49bd6c2c" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_StartProgramProbed           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Starts executing the application, when Pin is in Probe mode. Note that <a class="el" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init()</a> must be called before <a class="el" href="group__PIN__CONTROL.html#g7de96e728655962e8ecb4cfe49bd6c2c">PIN_StartProgramProbed()</a>.<p>
The <a class="el" href="group__PIN__CONTROL.html#g7de96e728655962e8ecb4cfe49bd6c2c">PIN_StartProgramProbed()</a> function never returns. It also unwinds the tool's stack, so any local (stack based) variables are lost.<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g865588e1c8ec27149ab627aecabfd4c1"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_TryEnd" ref="g865588e1c8ec27149ab627aecabfd4c1" args="(THREADID tid)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_TryEnd           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>tid</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Unregister the last registered notification function (registered via <a class="el" href="group__PIN__CONTROL.html#g22e1f539c7159c1bc9a2aac8f8803e81">PIN_TryStart()</a>) from the context of the calling thread. This function should be called in the same function scope as the previously registered <a class="el" href="group__PIN__CONTROL.html#g22e1f539c7159c1bc9a2aac8f8803e81">PIN_TryStart()</a>.<br>
 This function can be used in any thread, including any internal thread spawned by the tool.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>Id of the calling thread.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Windows, Linux<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g22e1f539c7159c1bc9a2aac8f8803e81"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_TryStart" ref="g22e1f539c7159c1bc9a2aac8f8803e81" args="(THREADID tid, INTERNAL_EXCEPTION_CALLBACK fun, VOID *val)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_TryStart           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>tid</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__PIN__CONTROL.html#gb3550c0044899834614bc73245f90743">INTERNAL_EXCEPTION_CALLBACK</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>fun</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>VOID *&nbsp;</td>
          <td class="mdname" nowrap> <em>val</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Register a per-thread notification handler function that is called upon receipt of an internal exception in pin or the tool in the context of the calling thread. Use <a class="el" href="group__PIN__CONTROL.html#g865588e1c8ec27149ab627aecabfd4c1">PIN_TryEnd()</a> in order to remove the registered handler from the context of the calling thread (do it in the same function scope). The user can register up to MAX_IEH_CALLBACKS per-thread notification functions.<br>
 This function can be used in any thread, including any internal thread spawned by the tool.<p>
<dl compact><dt><b>Note:</b></dt><dd>It is unsupported to call <a class="el" href="group__PIN__CONTROL.html#g8fa128a4393b96cc7f292d17d2ef0ba4">PIN_CallApplicationFunction()</a> in the scope of <a class="el" href="group__PIN__CONTROL.html#g22e1f539c7159c1bc9a2aac8f8803e81">PIN_TryStart()</a> / <a class="el" href="group__PIN__CONTROL.html#g865588e1c8ec27149ab627aecabfd4c1">PIN_TryEnd()</a> pair.<br>
</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tid</em>&nbsp;</td><td>Id of the calling thread. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>fun</em>&nbsp;</td><td>Handler function to execute upon receipt of internal exception in pin/tool. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>val</em>&nbsp;</td><td>Value to pass to the handler function.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Windows, Linux<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g048709607373930698fb578b7150815d"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_UnblockSignal" ref="g048709607373930698fb578b7150815d" args="(INT32 sig, BOOL enable)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">BOOL LEVEL_PINCLIENT::PIN_UnblockSignal           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">INT32&nbsp;</td>
          <td class="mdname" nowrap> <em>sig</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>BOOL&nbsp;</td>
          <td class="mdname" nowrap> <em>enable</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
This API is normally used in conjunction with <a class="el" href="group__PIN__CONTROL.html#g6a0c20f386b88de45925e3434c52e4ff">PIN_InterceptSignal()</a> to prevent the application from blocking a signal that the tool intercepts. This is useful if the tool wants to ensure that the application will not prevent the tool from receiving the intercepted signal.<p>
When this API is called before <a class="el" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram()</a>, it affects all threads in the application. However, if it is called after <a class="el" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram()</a>, it only affects the calling thread. If the application spawns a thread, the child thread inherits the signal blocking state from its parent.<p>
Tools should take care when using this API because it can adversely affect the application if it also uses the signal <em>sig</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sig</em>&nbsp;</td><td>The signal number, which may not be SIGKILL or SIGSTOP. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>enable</em>&nbsp;</td><td>If TRUE, the application is prevented from blocking <em>sig</em>. If FALSE, the application may block or unblock <em>sig</em> at will.</td></tr>
  </table>
</dl>
<dl compact><dt><b>Returns:</b></dt><dd>TRUE on success (always FALSE on Windows).</dd></dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="ga4d21b5ab38ba60932969d0d37e4f5de"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_UnlockClient" ref="ga4d21b5ab38ba60932969d0d37e4f5de" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::PIN_UnlockClient           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Some Pin API functions must be called when the thread is holding this lock. See also <a class="el" href="group__PIN__CONTROL.html#gc5d4cd777e5c34bb760ea6768e054f20">PIN_LockClient</a>.<br>
 This function can be used in any thread, including any internal thread spawned by the tool.<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="gf54dbae6665a47abdc2f7054f2cd6b6e"></a><!-- doxytag: member="LEVEL_PINCLIENT::PIN_VmFullPath" ref="gf54dbae6665a47abdc2f7054f2cd6b6e" args="()" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">CHAR* LEVEL_PINCLIENT::PIN_VmFullPath           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns full path of Pin binary invoked, encoded in UTF8 (superset of ASCII), this is supported for Linux (only for locales encoded in UTF8)<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Fri Oct 22 02:29:23 2010 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
