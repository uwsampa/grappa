<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: Generic modification API</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Generic modification API<br>
<small>
[<a class="el" href="group__INS__BASIC__API.html">INS: Instruction Object</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__MOD__API__GEN__IA32.html#g9309f9f665d0d01b9c880eeaf2955d33">LEVEL_PINCLIENT::INS_RewriteMemoryOperand</a> (INS ins, UINT32 memindex, <a class="el" href="group__REG__CPU__IPF.html#g3b77029a2a445f70f0206dbad1e4e641">REG</a> reg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__MOD__API__GEN__IA32.html#g001c169ec3e061fc6436b63af220d81d">LEVEL_PINCLIENT::INS_InsertIndirectJump</a> (INS ins, <a class="el" href="group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21">IPOINT</a> ipoint, <a class="el" href="group__REG__CPU__IPF.html#g3b77029a2a445f70f0206dbad1e4e641">REG</a> reg)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__MOD__API__GEN__IA32.html#g85b5d845590e666a8424e3793a2cdf33">LEVEL_PINCLIENT::INS_InsertDirectJump</a> (INS ins, <a class="el" href="group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21">IPOINT</a> ipoint, ADDRINT tgt)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__INS__MOD__API__GEN__IA32.html#g408da5197af3462940d9d0de25bb886a">LEVEL_PINCLIENT::INS_Delete</a> (INS ins)</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Use these functions to modify instructions. They work for all instruction sets. For experts only!<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT &amp; Probe<br>
 <b>O/S</b>: Linux &amp; Windows<br>
 <b>CPU:</b> All<br>
 </dd></dl>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g408da5197af3462940d9d0de25bb886a"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_Delete" ref="g408da5197af3462940d9d0de25bb886a" args="(INS ins)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::INS_Delete           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">INS&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>ins</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Delete the instruction<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> All<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g85b5d845590e666a8424e3793a2cdf33"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertDirectJump" ref="g85b5d845590e666a8424e3793a2cdf33" args="(INS ins, IPOINT ipoint, ADDRINT tgt)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::INS_InsertDirectJump           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">INS&nbsp;</td>
          <td class="mdname" nowrap> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21">IPOINT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ipoint</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>ADDRINT&nbsp;</td>
          <td class="mdname" nowrap> <em>tgt</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a direct jump instruction relative to the given instruction When used with INS_Delete it can be used to emulate control transfer instructions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ins</em>&nbsp;</td><td>input instruction </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ipoint</em>&nbsp;</td><td>location relative to ins (only IPOINT_BEFORE and IPOINT_AFTER are supported) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>tgt</em>&nbsp;</td><td>absolute address of the target</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g001c169ec3e061fc6436b63af220d81d"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_InsertIndirectJump" ref="g001c169ec3e061fc6436b63af220d81d" args="(INS ins, IPOINT ipoint, REG reg)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::INS_InsertIndirectJump           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">INS&nbsp;</td>
          <td class="mdname" nowrap> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21">IPOINT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ipoint</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__REG__CPU__IPF.html#g3b77029a2a445f70f0206dbad1e4e641">REG</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert an indirect jump instruction relative to the given instruction. When used with INS_Delete it can be used to emulate control transfer instructions.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ins</em>&nbsp;</td><td>input instruction </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ipoint</em>&nbsp;</td><td>location relative to ins (only IPOINT_BEFORE and IPOINT_AFTER are supported) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reg</em>&nbsp;</td><td>register holding the target</td></tr>
  </table>
</dl>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="g9309f9f665d0d01b9c880eeaf2955d33"></a><!-- doxytag: member="LEVEL_PINCLIENT::INS_RewriteMemoryOperand" ref="g9309f9f665d0d01b9c880eeaf2955d33" args="(INS ins, UINT32 memindex, REG reg)" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">VOID LEVEL_PINCLIENT::INS_RewriteMemoryOperand           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">INS&nbsp;</td>
          <td class="mdname" nowrap> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>UINT32&nbsp;</td>
          <td class="mdname" nowrap> <em>memindex</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__REG__CPU__IPF.html#g3b77029a2a445f70f0206dbad1e4e641">REG</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>reg</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change this memory access instruction to reference the virtual memory location contained in the given register.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ins</em>&nbsp;</td><td>input instruction </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>memopIdx</em>&nbsp;</td><td>controls which memory operand to rewrite (0,1,...) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>newBase</em>&nbsp;</td><td>register containing the base address of the new operand which will normally be a scratch register allocated via <a class="el" href="group__REG__CPU__GENERIC.html#g8ae822ec8bc5d3579bfb6808fa1dd86a">PIN_ClaimToolRegister()</a></td></tr>
  </table>
</dl>
On IA-32 and Intel64, the modified operand uses only base register addressing with the new base register <em>newBase</em>. Any index, scale, or offset fields from that operand in the original instruction are removed. In addition, if the original instruction's operand uses a segment override, the instruction is changed to use the default segment.<p>
This function can be used to rewrite memory operands even when they are implicit (for instance call, ret, push, pop), though in this case the instruction may ultimately be replaced by a sequence of instructions which achieve the same effect. (This is transparent to instrumentation, which continues to see the original instruction).<p>
The only instruction which cannot be rewritten is <b>enter</b> with a second operand &gt; 0.<p>
Note that the address in <em>newBase</em> is always the lowest address which will be accessed by this operand. This is consistent with the way in which Pin returns addresses in IARG_*_EA, but means that if the operand is modified by the instruction before the memory access occurs (for instance a <b>push</b> instruction), the value in <em>newBase</em> will not be the value in the stack pointer, but the address of the memory which is accessed by the instruction.<p>
This can also be confusing for xlat; where the value of <em>newBase</em> is the address from which data is loaded, not the address of the base of the translation table. (Again, this is consistent with the IARG_*_EA which Pin will report for an xlat operation).<p>
Similarly for the bt,btc,btr and bts insructions, if the bit index is larger than the operand size (so that parts of the bit index affect the EA), they are included in Pin's normal EA calculation. In this case, Pin automatically masks the bit index operand so that it only includes the index within the addressed unit of memory. This ensures that your address manipulation function need only consider the translation of the EA, it does not have to worry about additional offsets generated by the bit index operand of these instructions. (This is equivalent to saying that if you replace all memory operands, but use an address computation function that simply returns the original EA, the code will continue to execute correctly).<p>
The canonical instrumentation code for memory address rewriting now looks something like this <div class="fragment"><pre class="fragment"> <span class="comment">// Map the originalEa to a translated address. </span>
 <span class="keyword">static</span> ADDRINT ProcessAddress(ADDRINT originalEa, ADDRINT size, UINT32 access);
 ...
    <span class="keywordflow">for</span> (UINT32 op = 0; op&lt;<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g5ee651cd69d153bb2ee86594a37e3ad6">INS_MemoryOperandCount</a>(ins); op++)
    {
        UINT32 access = (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g9200fcba361c9272ad963a5c5cb5c235">INS_MemoryOperandIsRead</a>(ins,op)    ? 1 : 0) |
                        (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g0cb7a4138a881972c59ca8c855765fba">INS_MemoryOperandIsWritten</a>(ins,op) ? 2 : 0);

        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>,
                       AFUNPTR(ProcessAddress),
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883955f1b855db490b9fca95e5497995">IARG_MEMORYOP_EA</a>,   op,
                       IARG_MEMORYOP_SIZE, op,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>,        access,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56817c4e6beb62b49ef970699ac2263b227c">IARG_RETURN_REGS</a>,   <a class="code" href="group__REG__CPU__IPF.html#gg3b77029a2a445f70f0206dbad1e4e641d9354825e5010ac4993d0c72d7451c8e">REG_INST_G0</a>+i, 
                       IARG_END);

        <a class="code" href="group__INS__MOD__API__GEN__IA32.html#g9309f9f665d0d01b9c880eeaf2955d33">INS_RewriteMemoryOperand</a>(ins, i, <a class="code" href="group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641">REG</a>(<a class="code" href="group__REG__CPU__IPF.html#gg3b77029a2a445f70f0206dbad1e4e641d9354825e5010ac4993d0c72d7451c8e">REG_INST_G0</a>+i));
    }
</pre></div> There is no need to handle any instructions specially.<p>
<dl compact><dt><b>Availability:</b></dt><dd><b>Mode:</b> JIT<br>
 <b>O/S</b>: Linux, Windows &amp; MacOS<br>
 <b>CPU:</b> IA-32 and Intel(R) 64 architectures<br>
 </dd></dl>
    </td>
  </tr>
</table>
<hr size="1"><address style="align: right;"><small>Generated on Fri Oct 22 02:29:22 2010 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
