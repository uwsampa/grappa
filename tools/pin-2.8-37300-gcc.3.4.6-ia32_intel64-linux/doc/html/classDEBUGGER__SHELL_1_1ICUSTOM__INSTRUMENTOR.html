<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li id="current"><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="classes.html"><span>Alphabetical&nbsp;List</span></a></li>
    <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
    <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
    <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<b>DEBUGGER_SHELL</b>::<a class="el" href="classDEBUGGER__SHELL_1_1ICUSTOM__INSTRUMENTOR.html">ICUSTOM_INSTRUMENTOR</a></div>
<h1>DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR Class Reference<br>
<small>
[<a class="el" href="group__DEBUGGER__SHELL.html">DEBUGGER_SHELL</a>]</small>
</h1><!-- doxytag: class="DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR" --><code>#include &lt;debugger-shell.H&gt;</code>
<p>
<a href="classDEBUGGER__SHELL_1_1ICUSTOM__INSTRUMENTOR-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDEBUGGER__SHELL_1_1ICUSTOM__INSTRUMENTOR.html#653cbbcac7b70637ff29df2e36901f87">InsertBreakpointBefore</a> (INS ins, BBL bbl, <a class="el" href="group__INST__ARGS.html#g70f950adfb17bcd687fe356ed198bd2e">CALL_ORDER</a> order, const std::string &amp;message)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual VOID&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDEBUGGER__SHELL_1_1ICUSTOM__INSTRUMENTOR.html#b6ee36f9d6775a63fb219def821bfa3d">InsertBreakpointAfter</a> (INS ins, BBL bbl, <a class="el" href="group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21">IPOINT</a> ipoint, <a class="el" href="group__INST__ARGS.html#g70f950adfb17bcd687fe356ed198bd2e">CALL_ORDER</a> order, const std::string &amp;message)=0</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Some tools may need to define their own analysis routine that stops at a debugger breakpoint. Such tools can define their own class, which derives from <a class="el" href="classDEBUGGER__SHELL_1_1ICUSTOM__INSTRUMENTOR.html">ICUSTOM_INSTRUMENTOR</a>. Pass a pointer to that object to <a class="el" href="structDEBUGGER__SHELL_1_1STARTUP__ARGUMENTS.html#8bd85746870a731b948783438057547e">STARTUP_ARGUMENTS::_customInstrumentor</a>.<p>
Most tools do not need to override the default instrumenation, so most tools need not use this interface. 
<p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="b6ee36f9d6775a63fb219def821bfa3d"></a><!-- doxytag: member="DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR::InsertBreakpointAfter" ref="b6ee36f9d6775a63fb219def821bfa3d" args="(INS ins, BBL bbl, IPOINT ipoint, CALL_ORDER order, const std::string &amp;message)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual VOID DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR::InsertBreakpointAfter           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">INS&nbsp;</td>
          <td class="mdname" nowrap> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>BBL&nbsp;</td>
          <td class="mdname" nowrap> <em>bbl</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21">IPOINT</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>ipoint</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__INST__ARGS.html#g70f950adfb17bcd687fe356ed198bd2e">CALL_ORDER</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>message</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The debugger shell calls this method to insert a "then" instrumentation call to an analysis routine that stops at a debugger breakpoint _after_ an instruction. The default instrumenation looks like this. Tools that implement this method should insert similar instrumentation:<p>
<div class="fragment"><pre class="fragment">  VOID <a class="code" href="classDEBUGGER__SHELL_1_1ICUSTOM__INSTRUMENTOR.html#b6ee36f9d6775a63fb219def821bfa3d">InsertBreakpointAfter</a>(INST ins, BBL bbl, <a class="code" href="group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21">IPOINT</a> ipoint, <a class="code" href="group__INST__ARGS.html#g70f950adfb17bcd687fe356ed198bd2e">CALL_ORDER</a> order,
      <span class="keyword">const</span> std::string &amp;message)
  {
      <a class="code" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall</a>(ins, ipoint, (AFUNPTR)TriggerBreakpointAfter,
          <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56817abcd1a5a41e91ce8d6a388b706bba42">IARG_CALL_ORDER</a>, order,
          <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56819673f5f1a6c7d03d31a2eab0af88628e">IARG_CONTEXT</a>, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681d04f1eb185e914f0f11a839e2c26cbd8">IARG_THREAD_ID</a>,
          <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811618560294ef8f249387968f55871e69">IARG_PTR</a>, message.c_str(),
          IARG_END);
  }

  VOID TriggerBreakpointAfter(<a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, ADDRINT pc, <a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, <span class="keyword">const</span> <span class="keywordtype">char</span> *message)
  {
      std::ostringstream os;
      os &lt;&lt; message &lt;&lt; <span class="stringliteral">"\n"</span>;
      os &lt;&lt; <span class="stringliteral">"Breakpoint triggered after instruction at 0x"</span> &lt;&lt; std::hex &lt;&lt; pc;

      <a class="code" href="group__APPDEBUG__API.html#g0cc79428309a39c0cbae4e6131b51f3a">PIN_ApplicationBreakpoint</a>(ctxt, tid, FALSE, os.str());
  }
</pre></div><p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ins</em>&nbsp;</td><td>Insert the instrumentation after this instruction. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bbl</em>&nbsp;</td><td>The basic block containing <em>ins</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ipoint</em>&nbsp;</td><td>Tells whether to instrument IPOINT_AFTER or IPOINT_TAKEN_BRANCH. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>order</em>&nbsp;</td><td>The instrumentation call order to use for the instrumentation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>message</em>&nbsp;</td><td>String telling why the breakpoint is triggered. The string is allocated in permanent storage, so the client can pass it directly to an analysis routine. If the debugger shell removes instrumenation, it will also deallocate this string. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<a class="anchor" name="653cbbcac7b70637ff29df2e36901f87"></a><!-- doxytag: member="DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR::InsertBreakpointBefore" ref="653cbbcac7b70637ff29df2e36901f87" args="(INS ins, BBL bbl, CALL_ORDER order, const std::string &amp;message)=0" --><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top">virtual VOID DEBUGGER_SHELL::ICUSTOM_INSTRUMENTOR::InsertBreakpointBefore           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">INS&nbsp;</td>
          <td class="mdname" nowrap> <em>ins</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>BBL&nbsp;</td>
          <td class="mdname" nowrap> <em>bbl</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap><a class="el" href="group__INST__ARGS.html#g70f950adfb17bcd687fe356ed198bd2e">CALL_ORDER</a>&nbsp;</td>
          <td class="mdname" nowrap> <em>order</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap> <em>message</em></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [pure virtual]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The debugger shell calls this method to insert a "then" instrumentation call to an analysis routine that stops at a debugger breakpoint _before_ an instruction. The default instrumenation looks like this. Tools that implement this method should insert similar instrumentation:<p>
<div class="fragment"><pre class="fragment">  VOID <a class="code" href="classDEBUGGER__SHELL_1_1ICUSTOM__INSTRUMENTOR.html#653cbbcac7b70637ff29df2e36901f87">InsertBreakpointBefore</a>(INST ins, BBL bbl, <a class="code" href="group__INST__ARGS.html#g70f950adfb17bcd687fe356ed198bd2e">CALL_ORDER</a> order, <span class="keyword">const</span> std::string &amp;message)
  {
      <a class="code" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)TriggerBreakpointBefore,
          <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56817abcd1a5a41e91ce8d6a388b706bba42">IARG_CALL_ORDER</a>, order,
          <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56819673f5f1a6c7d03d31a2eab0af88628e">IARG_CONTEXT</a>, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681d04f1eb185e914f0f11a839e2c26cbd8">IARG_THREAD_ID</a>,
          <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, static_cast&lt;UINT32&gt;(RegSkipOne),
          <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811618560294ef8f249387968f55871e69">IARG_PTR</a>, message.c_str(),
          IARG_END);
  }

  VOID TriggerBreakpointBefore(<a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, <a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, UINT32 regSkipOne, <span class="keyword">const</span> <span class="keywordtype">char</span> *message)
  {
      ADDRINT skipPc = <a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>(ctxt, static_cast&lt;REG&gt;(regSkipOne));
      ADDRINT pc = <a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>(ctxt, REG_INST_PTR);
      <span class="keywordflow">if</span> (skipPc == pc)
          <span class="keywordflow">return</span>

      <a class="code" href="group__CONTEXT__API.html#ga3f8746ccdac1c1fbcb2e2f3f3cd7bcb">PIN_SetContextReg</a>(ctxt, static_cast&lt;REG&gt;(regSkipOne), pc);
      <a class="code" href="group__APPDEBUG__API.html#g0cc79428309a39c0cbae4e6131b51f3a">PIN_ApplicationBreakpoint</a>(ctxt, tid, FALSE, message);
  }
</pre></div><p>
See the method <a class="el" href="classDEBUGGER__SHELL_1_1ISHELL.html#48c01d1a6bf74498bfa7a28adb1f4a38">ISHELL::GetSkipOneRegister()</a> for the register number to use for <em>RegSkipOne</em>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ins</em>&nbsp;</td><td>Insert the instrumentation before this instruction. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bbl</em>&nbsp;</td><td>The basic block containing <em>ins</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>order</em>&nbsp;</td><td>The instrumentation call order to use for the instrumentation. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>message</em>&nbsp;</td><td>String telling why the breakpoint is triggered. The string is allocated in permanent storage, so the client can pass it directly to an analysis routine. If the debugger shell removes instrumenation, it will also deallocate this string. </td></tr>
  </table>
</dl>
    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following file:<ul>
<li>debugger-shell.H</ul>
<hr size="1"><address style="align: right;"><small>Generated on Fri Oct 22 02:29:23 2010 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
