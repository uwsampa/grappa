<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pin: Pin 2.8 User Guide</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>Pin 2.8 User Guide</h1>
<p>
======================================================================================== <h2><a class="anchor" name="INTRO">
Introduction</a></h2>
========================================================================================<p>
Pin is a tool for the instrumentation of programs. It supports Linux* and Windows* executables for IA-32, Intel(R) 64, and IA-64 architectures.<p>
Pin allows a tool to insert arbitrary code (written in C or C++) in arbitrary places in the executable. The code is added dynamically while the executable is running. This also makes it possible to attach Pin to an already running process.<p>
Pin provides a rich API that abstracts away the underlying instruction set idiosyncracies and allows context information such as register contents to be passed to the injected code as parameters. Pin automatically saves and restores the registers that are overwritten by the injected code so the application continues to work. Limited access to symbol and debug information is available as well.<p>
Pin includes the source code for a large number of example instrumentation tools like basic block profilers, cache simulators, instruction trace generators, etc. It is easy to derive new tools using the examples as a template.<p>
Tutorial Sections<ul>
<li><a class="el" href="index.html#INSTRUMENTING">How to instrument with Pin</a></li><li><a class="el" href="index.html#EXAMPLES">Examples</a></li><li><a class="el" href="index.html#CALLBACK">Callbacks</a></li><li><a class="el" href="index.html#MODIFYING">Modifying Application Instructions</a></li><li><a class="el" href="index.html#APPDEBUG">Debugging the Application while Running Under Pin</a></li><li><a class="el" href="index.html#EX">Applying a Pintool to an Application</a></li><li><a class="el" href="index.html#DEBUGGING">Debugging Tips for Debugging a Pintool</a></li><li><a class="el" href="index.html#LOGGING">Recording Messages from a Pintool</a></li><li><a class="el" href="index.html#PERFORMANCE">Performance Considerations</a></li><li><a class="el" href="index.html#RESTRICTIONS">PinTools Information and Restrictions</a></li><li><a class="el" href="index.html#WINLIBRARIES">Libraries for Windows</a></li><li><a class="el" href="index.html#LIBRARIES">Libraries for Linux</a></li><li><a class="el" href="index.html#INSTALLATION">Installation</a></li><li><a class="el" href="index.html#FEEDBACK">Feedback</a></li><li><a class="el" href="index.html#LEGAL">Disclaimer and Legal Information</a></li></ul>
<p>
Reference Sections<ul>
<li><a class="el" href="group__API__REF.html">Pin API reference</a></li><li><a class="el" href="group__KNOBS.html">Pin Command Line Switches</a></li><li><a class="el" href="group__INSTLIB.html">Instrumentation Library</a></li></ul>
<p>
======================================================================================== <h2><a class="anchor" name="INSTRUMENTING">
How to Instrument with Pin</a></h2>
========================================================================================<p>
Table of Contents<ul>
<li><a class="el" href="index.html#Pin">Pin</a></li><li><a class="el" href="index.html#Pintools">Pintools</a></li><li><a class="el" href="index.html#Observations">Observations</a></li><li><a class="el" href="index.html#GRAN">Instrumentation Granularity</a></li><li><a class="el" href="index.html#SYMBOLS">Symbols</a></li><li><a class="el" href="index.html#FP">Floating Point Support in Analysis Routines</a></li><li><a class="el" href="index.html#MT">Instrumenting Multi-threaded Applications</a></li></ul>
<h3><a class="anchor" name="Pin">
Pin</a></h3>
The best way to think about Pin is as a "just in time" (JIT) compiler. The input to this compiler is not bytecode, however, but a regular executable. Pin intercepts the execution of the first instruction of the executable and generates ("compiles") new code for the straight line code sequence starting at this instruction. It then transfers control to the generated sequence. The generated code sequence is almost identical to the original one, but Pin ensures that it regains control when a branch exits the sequence. After regaining control, Pin generates more code for the branch target and continues execution. Pin makes this efficient by keeping all of the generated code in memory so it can be reused and directly branching from one sequence to another.<p>
In JIT mode, the only code ever executed is the generated code. The original code is only used for reference. When generating code, Pin gives the user an opportunity to inject their own code (instrumentation).<p>
Pin instruments all instructions that are actually excuted. It does not matter in what section they reside. Although there are some exceptions for conditional branches, generally speaking, if an instruction is never executed then it will not be instrumented.<h3><a class="anchor" name="Pintools">
Pintools</a></h3>
Conceptually, instrumentation consists of two components:<p>
<ul>
<li>A mechanism that decides where and what code is inserted</li></ul>
<p>
<ul>
<li>The code to execute at insertion points</li></ul>
<p>
These two components are <em>instrumentation</em> and <em>analysis</em> code. Both components live in a single executable, a <em>Pintool</em>. Pintools can be thought of as plugins that can modify the code generation process inside Pin.<p>
The Pintool registers instrumentation callback routines with Pin that are called from Pin whenever new code needs to be generated. This instrumentation callback routine represents the instrumentation component. It inspects the code to be generated, investigates its static properties, and decides if and where to inject calls to analysis functions.<p>
The analysis function gathers data about the application. Pin makes sure that the integer register state is saved and restored as necessary and allow arguments to be passed to the functions. Be aware that the floating point registers are not saved and restored and therefore additional support is required in the analysis routines. See <a class="el" href="index.html#FP">Floating Point Support in Analysis Routines</a> for more information.<p>
The Pintool can also register notification callback routines for events such as thread creation or forking. These callbacks are generally used to gather data or tool initialization or clean up.<h3><a class="anchor" name="Observations">
Observations</a></h3>
Since a Pintool works like a plugin, it must run in the same address space as Pin and the executable to be instrumented. Hence the Pintool has access to all of the executable's data. It also shares file descriptors and other process information with the executable.<p>
Pin and the Pintool control a program starting with the very first instruction. For executables compiled with shared libraries this implies that the execution of the dynamic loader and all shared libraries will be visible to the Pintool.<p>
When writing tools, it is more important to tune the analysis code than the instrumentation code. This is because the instrumentation is executed once, but analysis code is called many times.<h3><a class="anchor" name="GRAN">
Instrumentation Granularity</a></h3>
As described above, Pin's instrumentation is "just in time" (JIT). Instrumentation occurs immediately before a code sequence is executed for the first time. We call this mode of operation <em> trace instrumentation </em>.<p>
Trace instrumentation lets the Pintool inspect and instrument an executable one trace at a time. Traces usually begin at the target of a taken branch and end with an unconditional branch, including calls and returns. Pin guarantees that a trace is only entered at the top, but it may contain multiple exits. If a branch joins the middle of a trace, Pin constructs a new trace that begins with the branch target. Pin breaks the trace into basic blocks, <em>BBLs</em>. A BBL is a single entrance, single exit sequence of instructions. Branches to the middle of a bbl begin a new trace and hence a new BBL. It is often possible to insert a single analysis call for a BBL, instead of one analysis call for every instruction. Reducing the number of analysis calls makes instrumentation more efficient. Trace instrumentation utilizes the <a class="el" href="group__TRACE__BASIC__API.html#gb3762f773502ad865216ef941c38799e">TRACE_AddInstrumentFunction</a> API call.<p>
Note, though, that since Pin is discovering the control flow of the program dynamically as it executes, Pin's BBL can be different from the classical definition of a BBL which you will find in a compiler textbook. For instance, consider the code generated for the body of a switch statement like this <div class="fragment"><pre class="fragment">    <span class="keywordflow">switch</span>(i)
    {
        <span class="keywordflow">case</span> 4: total++;
        <span class="keywordflow">case</span> 3: total++;
        <span class="keywordflow">case</span> 2: total++;
        <span class="keywordflow">case</span> 1: total++;
        <span class="keywordflow">case</span> 0:
        <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
    }
</pre></div><p>
It will generate instructions something like this (for the IA-32 architecture) <div class="fragment"><pre class="fragment">.L7:
        addl    $1, -4(%ebp)
.L6:
        addl    $1, -4(%ebp)
.L5:
        addl    $1, -4(%ebp)
.L4:
        addl    $1, -4(%ebp)
</pre></div><p>
In terms of classical basic blocks, each addl instruction is in a single instruction basic block. However as the different switch cases are executed, Pin will generate BBLs which contain all four instructions (when the .L7 case is entered), three instructions (when the .L6 case is entered), and so on. This means that counting Pin BBLs is unlikely to give the count you would expect if you thought that Pin BBLs were the same as the basic blocks in the text book. Here, for instance, if the code branches to .L7 you will count one Pin BBL, but there are four classical basic blocks executed.<p>
Pin also breaks BBLs on some other instructions which may be unexpected, for instance (on IA-32 and Intel 64 architectures) cpuid, popf and REP prefixed instructions all end traces and therefore BBLs. Since REP prefixed instructions are treated as implicit loops, if a REP prefixed instruction iterates more than once, iterations after the first will cause a single instruction BBL to be generated, so in this case you would see more basic blocks executed than you might expect.<p>
As a convenience for Pintool writers, Pin also offers an <em> instruction instrumentation </em> mode which lets the tool inspect and instrument an executable a single instruction at a time. This is essentially identical to trace instrumentation where the Pintool writer has been freed from the responsibilty of iterating over the instructions inside a trace. As decribed under trace instrumentation, certain BBLs and the instructions inside of them may be generated (and hence instrumented) multiple times. Instruction instrumentation utilizes the <a class="el" href="group__INS__INST__API.html#ga80cd9a7905b82a86b9e31d9bf589dbe">INS_AddInstrumentFunction</a> API call.<p>
Sometimes, however, it can be useful to look at different granularity than a trace. For this purpose Pin offers two additional modes: image and routine instrumentation. These modes are implemented by "caching" instrumentation requests and hence incur a space overhead.<p>
Image instrumentation lets the Pintool inspect and instrument an entire image, IMG, when it is first loaded. A Pintool can walk the sections, SEC, of the image, the routines, RTN, of a section, and the instructions, INS of a routine. Instrumentation can be inserted so that it is executed before or after a routine is executed, or before or after an instruction is executed. Image instrumentation utilizes the <a class="el" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction</a> API call. Image instrumentation depends on symbol information to determine routine boundaries hence <a class="el" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a> must be called before <a class="el" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>.<p>
Routine instrumentation lets the Pintool inspect and instrument an entire routine before the first time it is called. A Pintool can walk the instructions of a routine. There is not enough information available to break the instructions into BBLs. Instrumentation can be inserted so that it is executed before or after a routine is executed, or before or after an instruction is executed. Routine instrumentation can be more efficient than image instrumentation in space and time when the only a small number of the routines in an image are executed. Routine instrumentation utilizes the <a class="el" href="group__RTN__BASIC__API.html#g8622a6ba858eb8d55df4e006eb165e57">RTN_AddInstrumentFunction</a> API call. Instrumentation of routine exits does not work reliably in the presence of tail calls or when return instructions cannot reliably be detected.<h3><a class="anchor" name="SYMBOLS">
Symbols</a></h3>
Pin provides access to function names using the symbol object (SYM). Symbol objects only provide information about the function symbols in the application. Information about other types of symbols (e.g. data symbols), must be obtained independently by the tool.<p>
On Windows, you can use dbghelp.dll for this. Note that using dbghelp.dll in an instrumented process is not safe and can cause dead-locks in some cases. A possible solution is to find symbols using a different non-instrumented process.<p>
On Linux, libelf.so or libdwarf.so can be used to access symbol information.<p>
<a class="el" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a> must be called to access functions by name. See <a class="el" href="group__SYM__BASIC__API.html">SYM: Symbol Object</a> for more information.<h3><a class="anchor" name="FP">
Floating Point Support in Analysis Routines</a></h3>
Additional support is required if floating point computation is done in an analysis routine. Pin does not isolate the Pintool and the user application when it comes to x87 or the MXCSR. If you use x87 (or some SSE operation that modifies MXCSR) in an analysis routine, you'll likely corrupt the user application' s state. You have to do an fxsave;emms ... fxrstor pair around analysis code that uses or might use x87 or MXCSR.<p>
Also, IARG_REG_VALUE cannot be used to pass floating point register values as arguments to analysis routines.<h3><a class="anchor" name="MT">
Instrumenting Multi-threaded Applications</a></h3>
Instrumenting a multi-threaded program requires that the tool be thread safe - access to global storage must be coordinated with other threads. Pin tries to provide a conventional C++ program environment for tools, but it is not possible to use the standard libary interfaces to manage threads in a Pintool. For example, Linux tools cannot use the pthreads library and Windows tools should not use the Win32 API's to manage threads. Instead, Pin provides its own locking and thread management API's, which the Pintool should use. (See <a class="el" href="group__LOCK.html">LOCK: Locking Primitives</a> and <a class="el" href="group__PIN__THREAD__API.html">Pin Thread API</a>.)<p>
Pintools do not need to add explicit locking to instrumentation routines because Pin calls these routines while holding an internal lock called the VM lock. However, Pin does execute analysis and replacement functions in parallel, so Pintools may need to add locking to these routines if they access global data.<p>
Pintools on Linux also need to take care when calling standard C or C++ library routines from analysis or replacement functions because the C and C++ libraries linked into Pintools are <b>not</b> thread-safe. Some simple C / C++ routines are safe to call without locking, because their implementations are inherently thread-safe, however, Pin does not attempt to provide a list of safe routines. If you are in doubt, you should add locking around calls to library functions. In particular, the "errno" value is not multi-thread safe, so tools that use this should provide their own locking. Note that these restrictions only exist on the Unix platforms, as the library routines on Windows are thread safe.<p>
Pin provides call-backs when each thread starts and ends (see PIN_AddThreadStartFunction and PIN_AddThreadFiniFunction). These provide a convenient place for a Pintool to allocate and manipulate thread local data and store it a thread local storage.<p>
Pin also provides an analysis routine argument (IARG_THREAD_ID), which passes a Pin-specific thread ID for the calling thread. This ID is different from the O/S system thread ID, and is a small number starting at 0, which can be used as an index to array of thread data or as the locking value to Pin user locks. See the example <a class="el" href="index.html#MallocMT">Instrumenting Threaded Applications</a> for more information.<p>
In addition to the Pin thread ID, the Pin API provides an efficient thread local storage (TLS), with the option to allocate a new TLS key and associate it with a given data destruction function. Any thread of the process can store and retrieve values in its own slot, referenced by the allocated key. The initial value associated with the key in all threads is NULL. See the example <a class="el" href="index.html#InscountTLS">Using TLS</a> for more information.<p>
False sharing occurs when multiple threads access different parts of the same cache line and at least one of them is a write. To maintain memory coherency, the computer must copy the memory from one CPU's cache to another, even though data is not truly shared. False sharing can usually be avoided by padding critical data structures to the size of a cache line, or by rearranging the data layout of structures. See the example <a class="el" href="index.html#InscountTLS">Using TLS</a> for more information.<p>
======================================================================================== <h2><a class="anchor" name="EXAMPLES">
Examples</a></h2>
========================================================================================<p>
Table of Contents<ul>
<li><a class="el" href="index.html#SimpleCount">Simple Instruction Count (Instruction Instrumentation)</a></li><li><a class="el" href="index.html#IAddressTrace">Instruction Address Trace (Instruction Instrumentation)</a></li><li><a class="el" href="index.html#MAddressTrace">Memory Reference Trace (Instruction Instrumentation)</a></li><li><a class="el" href="index.html#ImageLoad">Detecting the Loading and Unloading of Images (Image Instrumentation)</a></li><li><a class="el" href="index.html#inscount1">More Efficient Instruction Counting (Trace Instrumentation)</a></li><li><a class="el" href="index.html#ProcInstrCount">Procedure Instruction Count (Routine Instrumentation)</a></li><li><a class="el" href="index.html#SafeCopy">Using PIN_SafeCopy()</a></li><li><a class="el" href="index.html#Invocation">Order of Instrumentation</a></li><li><a class="el" href="index.html#FunctionArguments">Finding the Value of Function Arguments</a></li><li><a class="el" href="index.html#FindSymbol">Finding Functions By Name on Windows</a></li><li><a class="el" href="index.html#MallocMT">Instrumenting Threaded Applications</a></li><li><a class="el" href="index.html#InscountTLS">Using TLS</a></li><li><a class="el" href="index.html#Buffering">Using the Fast Buffering APIs</a></li><li><a class="el" href="index.html#StaticInstructionCounts">Finding the Static Properties of an Image</a></li><li><a class="el" href="index.html#DetachPin">Detaching Pin from the Application</a></li><li><a class="el" href="index.html#ReplaceSigProbed">Replacing a Routine in Probe Mode</a></li><li><a class="el" href="index.html#FollowChild">Instrumenting Child Processes</a></li><li><a class="el" href="index.html#ForkOnLinux">Instrumenting Before and After Forks</a></li></ul>
<p>
To illustrate how to write Pintools, we present some simple examples. In the web based version of the manual, you can click on a function in the Pin API to see its documentation.<h3><a class="anchor" name="SimpleCount">
Simple Instruction Count (Instruction Instrumentation)</a></h3>
The example below instruments a program to count the total number of instructions executed. It inserts a call to <code>docount</code> before every instruction. When the program exits, it saves the count in the file <code>inscount.out</code>.<p>
Here is how to run it and display its output (note that the file list is the <code>ls</code> output, so may be different on your machine, similarly the instruction count will depend on the implementation of <code>ls</code>):<p>
<div class="fragment"><pre class="fragment">$ pin -t inscount0.so -- /bin/ls
Makefile          atrace.o     imageload.out  itrace      proccount
Makefile.example  imageload    inscount0      itrace.o    proccount.o
atrace            imageload.o  inscount0.o    itrace.out
$ cat inscount.out
Count 422838
$
</pre></div><p>
The KNOB exhibited in the example below overwrites the default name for the output file. To use this feature, add "-o &lt;file_name&gt;" to the command line. Tool command line options should be inserted between the tool name and the double dash ("--"). For more information on how to add command line options to your tool, please see <a class="el" href="group__KNOB__API.html">KNOB: Commandline Option Handling</a>.<p>
<div class="fragment"><pre class="fragment">$ pin -t inscount0.so -o inscount0.log -- /bin/ls
</pre></div><p>
The example can be found in source/tools/ManualExamples/inscount0.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

<span class="comment">// The running count of instructions is kept here</span>
<span class="comment">// make it static to help the compiler optimize docount</span>
<span class="keyword">static</span> UINT64 icount = 0;

<span class="comment">// This function is called before every instruction is executed</span>
VOID docount() { icount++; }
    
<span class="comment">// Pin calls this function every time a new instruction is encountered</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// Insert a call to docount before every instruction, no arguments are passed</span>
    <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)docount, IARG_END);
}

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"inscount.out"</span>, <span class="stringliteral">"specify output file name"</span>);

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    ofstream OutFile;
    OutFile.open(KnobOutputFile.Value().c_str());
    OutFile.setf(ios::showbase);
    OutFile &lt;&lt; <span class="stringliteral">"Count "</span> &lt;&lt; icount &lt;&lt; endl;
    OutFile.close();
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool counts the number of dynamic instructions executed"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>
<span class="comment">/*   argc, argv are the entire command line: pin -t &lt;toolname&gt; -- ...    */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__INS__INST__API.html#ga80cd9a7905b82a86b9e31d9bf589dbe">INS_AddInstrumentFunction</a>(Instruction, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="IAddressTrace">
Instruction Address Trace (Instruction Instrumentation)</a></h3>
In the previous example, we did not pass any arguments to <code>docount</code>, the analysis procedure. In this example, we show how to pass arguments. When calling an analysis procedure, Pin allows you to pass the instruction pointer, current value of registers, effective address of memory operations, constants, etc. For a complete list, see <a class="el" href="group__INST__ARGS.html#g7e2c955c99fa84246bb2bce1525b5681">IARG_TYPE</a>.<p>
With a small change, we can turn the instruction counting example into a Pintool that prints the address of every instruction that is executed. This tool is useful for understanding the control flow of a program for debugging, or in processor design when simulating an instruction cache.<p>
We change the arguments to INS_InsertCall to pass the address of the instruction about to be executed. We replace <code>docount</code> with <code>printip</code>, which prints the instruction address. It writes it output to to the file <code>itrace.out</code>.<p>
This is how to run it and look at the output:<p>
<div class="fragment"><pre class="fragment">$ pin -t itrace.so -- /bin/ls
Makefile          atrace.o     imageload.out  itrace      proccount
Makefile.example  imageload    inscount0      itrace.o    proccount.o
atrace            imageload.o  inscount0.o    itrace.out
$ head itrace.out
0x40001e90
0x40001e91
0x40001ee4
0x40001ee5
0x40001ee7
0x40001ee8
0x40001ee9
0x40001eea
0x40001ef0
0x40001ee0
$
</pre></div><p>
The example can be found in source/tools/ManualExamples/itrace.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

FILE * trace;

<span class="comment">// This function is called before every instruction is executed</span>
<span class="comment">// and prints the IP</span>
VOID printip(VOID *ip) { fprintf(trace, <span class="stringliteral">"%p\n"</span>, ip); }

<span class="comment">// Pin calls this function every time a new instruction is encountered</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// Insert a call to printip before every instruction, and pass it the IP</span>
    <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)printip, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>, IARG_END);
}

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"#eof\n"</span>);
    fclose(trace);
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    PIN_ERROR(<span class="stringliteral">"This Pintool prints the IPs of every instruction executed\n"</span> 
              + KNOB_BASE::StringKnobSummary() + <span class="stringliteral">"\n"</span>);
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    trace = fopen(<span class="stringliteral">"itrace.out"</span>, <span class="stringliteral">"w"</span>);
    
    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__INS__INST__API.html#ga80cd9a7905b82a86b9e31d9bf589dbe">INS_AddInstrumentFunction</a>(Instruction, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="MAddressTrace">
Memory Reference Trace (Instruction Instrumentation)</a></h3>
The previous example instruments all instructions. Sometimes a tool may only want to instrument a class of instructions, like memory operations or branch instructions. A tool can do this by using the Pin API which includes functions that classify and examine instructions. The basic API is common to all instruction sets and is described <a class="el" href="group__INS__BASIC__API.html">here.</a> In addition, there is an instruction set specific API for the <a class="el" href="group__INS__BASIC__API__IA32.html">IA-32 ISA,</a> and <a class="el" href="group__INS__BASIC__API__IPF.html">IA-64 ISA.</a><p>
In this example, we show how to do more selective instrumentation by examining the instructions. This tool generates a trace of all memory addresses referenced by a program. This is also useful for debugging and for simulating a data cache in a processor.<p>
We only instrument instructions that read or write memory. We also use <a class="el" href="group__INS__INST__API.html#g446df8cbefd4950b78cba7c9e7346053">INS_InsertPredicatedCall</a> instead of <a class="el" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a> to avoid generating references to instructions that are predicated when the predicate is false. Predication is a general architectural feature of the IA-64 architecture. On IA-32 and Intel 64 architectures CMOVcc, FCMOVcc and REP prefixed string operations are treated as being predicated. For CMOVcc and FCMOVcc the predicate is the condition test implied by "cc", for REP prefixed string ops it is that the count register is non-zero.<p>
Since the instrumentation functions are only called once and the analysis functions are called every time an instruction is executed, it is much faster to instrument only the memory operations, as compared to the previous instruction trace example that instruments every instruction.<p>
Here is how to run it and the sample output:<p>
<div class="fragment"><pre class="fragment">$ pin -t pinatrace.so -- /bin/ls
Makefile          atrace.o    imageload.o    inscount0.o  itrace.out
Makefile.example  atrace.out  imageload.out  itrace       proccount
atrace            imageload   inscount0      itrace.o     proccount.o
$ head pinatrace.out 
0x40001ee0: R 0xbfffe798
0x40001efd: W 0xbfffe7d4
0x40001f09: W 0xbfffe7d8
0x40001f20: W 0xbfffe864
0x40001f20: W 0xbfffe868
0x40001f20: W 0xbfffe86c
0x40001f20: W 0xbfffe870
0x40001f20: W 0xbfffe874
0x40001f20: W 0xbfffe878
0x40001f20: W 0xbfffe87c
$
</pre></div><p>
The example can be found in source/tools/ManualExamples/pinatrace.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> *  This file contains an ISA-portable PIN tool for tracing memory accesses.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>


FILE * trace;

<span class="comment">// Print a memory read record</span>
VOID RecordMemRead(VOID * ip, VOID * addr)
{
    fprintf(trace,<span class="stringliteral">"%p: R %p\n"</span>, ip, addr);
}

<span class="comment">// Print a memory write record</span>
VOID RecordMemWrite(VOID * ip, VOID * addr)
{
    fprintf(trace,<span class="stringliteral">"%p: W %p\n"</span>, ip, addr);
}

<span class="comment">// Is called for every instruction and instruments reads and writes</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// Instruments memory accesses using a predicated call, i.e.</span>
    <span class="comment">// the instrumentation is called iff the instruction will actually be executed.</span>
    <span class="comment">//</span>
    <span class="comment">// The IA-64 architecture has explicitly predicated instructions. </span>
    <span class="comment">// On the IA-32 and Intel(R) 64 architectures conditional moves and REP </span>
    <span class="comment">// prefixed instructions appear as predicated instructions in Pin.</span>
    UINT32 memOperands = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g5ee651cd69d153bb2ee86594a37e3ad6">INS_MemoryOperandCount</a>(ins);

    <span class="comment">// Iterate over each memory operand of the instruction.</span>
    <span class="keywordflow">for</span> (UINT32 memOp = 0; memOp &lt; memOperands; memOp++)
    {
        <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g9200fcba361c9272ad963a5c5cb5c235">INS_MemoryOperandIsRead</a>(ins, memOp))
        {
            <a class="code" href="group__INS__INST__API.html#g446df8cbefd4950b78cba7c9e7346053">INS_InsertPredicatedCall</a>(
                ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)RecordMemRead,
                <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>,
                <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883955f1b855db490b9fca95e5497995">IARG_MEMORYOP_EA</a>, memOp,
                IARG_END);
        }
        <span class="comment">// Note that in some architectures a single memory operand can be </span>
        <span class="comment">// both read and written (for instance incl (%eax) on IA-32)</span>
        <span class="comment">// In that case we instrument it once for read and once for write.</span>
        <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g0cb7a4138a881972c59ca8c855765fba">INS_MemoryOperandIsWritten</a>(ins, memOp))
        {
            <a class="code" href="group__INS__INST__API.html#g446df8cbefd4950b78cba7c9e7346053">INS_InsertPredicatedCall</a>(
                ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)RecordMemWrite,
                <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>,
                <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883955f1b855db490b9fca95e5497995">IARG_MEMORYOP_EA</a>, memOp,
                IARG_END);
        }
    }
}

VOID Fini(INT32 code, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"#eof\n"</span>);
    fclose(trace);
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>
   
INT32 Usage()
{
    PIN_ERROR( <span class="stringliteral">"This Pintool prints a trace of memory addresses\n"</span> 
              + KNOB_BASE::StringKnobSummary() + <span class="stringliteral">"\n"</span>);
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    trace = fopen(<span class="stringliteral">"pinatrace.out"</span>, <span class="stringliteral">"w"</span>);

    <a class="code" href="group__INS__INST__API.html#ga80cd9a7905b82a86b9e31d9bf589dbe">INS_AddInstrumentFunction</a>(Instruction, 0);
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);

    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="ImageLoad">
Detecting the Loading and Unloading of Images (Image Instrumentation)</a></h3>
The example below prints a message to a trace file every time and image is loaded or unloaded. It really abuses the image instrumentation mode as the Pintool neither inspects the image nor adds instrumentation code.<p>
If you invoke it on ls, you would see this output:<p>
<div class="fragment"><pre class="fragment">$ pin -t imageload.so -- /bin/ls
Makefile          atrace.o    imageload.o    inscount0.o  proccount
Makefile.example  atrace.out  imageload.out  itrace       proccount.o
atrace            imageload   inscount0      itrace.o     trace.out
$ cat imageload.out 
Loading /bin/ls
Loading /lib/ld-linux.so.2
Loading /lib/libtermcap.so.2
Loading /lib/i686/libc.so.6
Unloading /bin/ls
Unloading /lib/ld-linux.so.2
Unloading /lib/libtermcap.so.2
Unloading /lib/i686/libc.so.6
$ 
</pre></div><p>
The example can be found in source/tools/ManualExamples/imageload.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">//</span>
<span class="comment">// This tool prints a trace of image load and unload events</span>
<span class="comment">//</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

FILE * trace;

<span class="comment">// Pin calls this function every time a new img is loaded</span>
<span class="comment">// It can instrument the image, but this example does not</span>
<span class="comment">// Note that imgs (including shared libraries) are loaded lazily</span>

VOID ImageLoad(IMG img, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"Loading %s, Image id = %d\n"</span>, <a class="code" href="group__IMG__BASIC__API.html#g9f68164bfac7c031b82549eba91681c3">IMG_Name</a>(img).c_str(), <a class="code" href="group__IMG__BASIC__API.html#g9440e63ee69888e8889a90912f605316">IMG_Id</a>(img));
}

<span class="comment">// Pin calls this function every time a new img is unloaded</span>
<span class="comment">// You can't instrument an image that is about to be unloaded</span>
VOID ImageUnload(IMG img, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"Unloading %s\n"</span>, <a class="code" href="group__IMG__BASIC__API.html#g9f68164bfac7c031b82549eba91681c3">IMG_Name</a>(img).c_str());
}

<span class="comment">// This function is called when the application exits</span>
<span class="comment">// It closes the output file.</span>
VOID Fini(INT32 code, VOID *v)
{
    fclose(trace);
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    PIN_ERROR(<span class="stringliteral">"This tool prints a log of image load and unload events\n"</span>
             + KNOB_BASE::StringKnobSummary() + <span class="stringliteral">"\n"</span>);
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    trace = fopen(<span class="stringliteral">"imageload.out"</span>, <span class="stringliteral">"w"</span>);

    <span class="comment">// Initialize symbol processing</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    
    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();
    
    <span class="comment">// Register ImageLoad to be called when an image is loaded</span>
    <a class="code" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction</a>(ImageLoad, 0);

    <span class="comment">// Register ImageUnload to be called when an image is unloaded</span>
    <a class="code" href="group__IMG__BASIC__API.html#gbcbc2007e5a261dcd4893e9bd59ef7aa">IMG_AddUnloadFunction</a>(ImageUnload, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="inscount1">
More Efficient Instruction Counting (Trace Instrumentation)</a></h3>
The example <a class="el" href="index.html#SimpleCount">Simple Instruction Count (Instruction Instrumentation)</a> computed the number of executed instructions by inserting a call before every instruction. In this example, we make it more efficient by counting the number of instructions in a BBL at instrumentation time, and incrementing the counter once per BBL, instead of once per instruction.<p>
The example can be found in source/tools/ManualExamples/inscount1.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

<span class="comment">// The running count of instructions is kept here</span>
<span class="comment">// make it static to help the compiler optimize docount</span>
<span class="keyword">static</span> UINT64 icount = 0;

<span class="comment">// This function is called before every block</span>
VOID docount(UINT32 c) { icount += c; }
    
<span class="comment">// Pin calls this function every time a new basic block is encountered</span>
<span class="comment">// It inserts a call to docount</span>
VOID Trace(<a class="code" href="group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc">TRACE</a> trace, VOID *v)
{
    <span class="comment">// Visit every basic block  in the trace</span>
    <span class="keywordflow">for</span> (BBL bbl = <a class="code" href="group__TRACE__BASIC__API.html#g1804f26fc605c9344d57be21b392796b">TRACE_BblHead</a>(trace); <a class="code" href="group__BBL__BASIC__API.html#g5aaace888f68ec067f60e3b74c0b9131">BBL_Valid</a>(bbl); bbl = <a class="code" href="group__BBL__BASIC__API.html#g60805b0620b58e2c9ca2add6e16d26ef">BBL_Next</a>(bbl))
    {
        <span class="comment">// Insert a call to docount before every bbl, passing the number of instructions</span>
        <a class="code" href="group__BBL__BASIC__API.html#g5fba2db08badc1f77616c8f41ce31884">BBL_InsertCall</a>(bbl, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, <a class="code" href="group__BBL__BASIC__API.html#g3d7437048b7fd658b1e4d413c69d9ccb">BBL_NumIns</a>(bbl), IARG_END);
    }
}

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"inscount.out"</span>, <span class="stringliteral">"specify output file name"</span>);

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    ofstream OutFile;
    OutFile.open(KnobOutputFile.Value().c_str());
    OutFile.setf(ios::showbase);
    OutFile &lt;&lt; <span class="stringliteral">"Count "</span> &lt;&lt; icount &lt;&lt; endl;
    OutFile.close();
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool counts the number of dynamic instructions executed"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__TRACE__BASIC__API.html#gb3762f773502ad865216ef941c38799e">TRACE_AddInstrumentFunction</a>(Trace, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="ProcInstrCount">
Procedure Instruction Count (Routine Instrumentation)</a></h3>
The example below instruments a program to count the number of times a procedure is called, and the total number of instructions executed in each procedure. When it finishes, it prints a profile to proccount.out<p>
Executing the tool and sample output:<p>
<div class="fragment"><pre class="fragment">$ pin -t proccount.so -- /bin/grep proccount.cpp Makefile
proccount_SOURCES = proccount.cpp
$ head proccount.out
              Procedure           Image            Address        Calls Instructions
                  _fini       libc.so.6         0x40144d00            1           21
__deregister_frame_info       libc.so.6         0x40143f60            2           70
  __register_frame_info       libc.so.6         0x40143df0            2           62
              fde_merge       libc.so.6         0x40143870            0            8
            __init_misc       libc.so.6         0x40115824            1           85
            __getclktck       libc.so.6         0x401157f4            0            2
                 munmap       libc.so.6         0x40112ca0            1            9
                   mmap       libc.so.6         0x40112bb0            1           23
            getpagesize       libc.so.6         0x4010f934            2           26
$
</pre></div><p>
The example can be found in source/tools/ManualExamples/proccount.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">//</span>
<span class="comment">// This tool counts the number of times a routine is executed and </span>
<span class="comment">// the number of instructions executed in a routine</span>
<span class="comment">//</span>

<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;iomanip&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

<span class="comment">// Holds instruction count for a single procedure</span>
<span class="keyword">typedef</span> <span class="keyword">struct </span>RtnCount
{
    string _name;
    string _image;
    ADDRINT _address;
    RTN _rtn;
    UINT64 _rtnCount;
    UINT64 _icount;
    <span class="keyword">struct </span>RtnCount * _next;
} RTN_COUNT;

<span class="comment">// Linked list of instruction counts for each routine</span>
RTN_COUNT * RtnList = 0;

<span class="comment">// This function is called before every instruction is executed</span>
VOID docount(UINT64 * counter)
{
    (*counter)++;
}
    
<span class="keyword">const</span> <span class="keywordtype">char</span> * StripPath(<span class="keyword">const</span> <span class="keywordtype">char</span> * path)
{
    <span class="keyword">const</span> <span class="keywordtype">char</span> * file = strrchr(path,<span class="charliteral">'/'</span>);
    <span class="keywordflow">if</span> (file)
        <span class="keywordflow">return</span> file+1;
    <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> path;
}

<span class="comment">// Pin calls this function every time a new rtn is executed</span>
VOID Routine(RTN rtn, VOID *v)
{
    
    <span class="comment">// Allocate a counter for this routine</span>
    RTN_COUNT * rc = <span class="keyword">new</span> RTN_COUNT;

    <span class="comment">// The RTN goes away when the image is unloaded, so save it now</span>
    <span class="comment">// because we need it in the fini</span>
    rc-&gt;_name = <a class="code" href="group__RTN__BASIC__API.html#gb274bf5dadf6f1ae3259715ae161ebd1">RTN_Name</a>(rtn);
    rc-&gt;_image = StripPath(<a class="code" href="group__IMG__BASIC__API.html#g9f68164bfac7c031b82549eba91681c3">IMG_Name</a>(<a class="code" href="group__SEC__BASIC__API.html#g12d872ebd06751c73246dc869cf49b91">SEC_Img</a>(<a class="code" href="group__RTN__BASIC__API.html#g9046edfd85722ef2f701282ba7a5c7a2">RTN_Sec</a>(rtn))).c_str());
    rc-&gt;_address = <a class="code" href="group__RTN__BASIC__API.html#gb74b01b5b6feb47a1f52d9f8ea7ea154">RTN_Address</a>(rtn);
    rc-&gt;_icount = 0;
    rc-&gt;_rtnCount = 0;

    <span class="comment">// Add to list of routines</span>
    rc-&gt;_next = RtnList;
    RtnList = rc;
            
    <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>(rtn);
            
    <span class="comment">// Insert a call at the entry point of a routine to increment the call count</span>
    <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(rtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811618560294ef8f249387968f55871e69">IARG_PTR</a>, &amp;(rc-&gt;_rtnCount), IARG_END);
    
    <span class="comment">// For each instruction of the routine</span>
    <span class="keywordflow">for</span> (INS ins = <a class="code" href="group__RTN__BASIC__API.html#gb49dd96d5d0d0fdcf38c922585c6ba06">RTN_InsHead</a>(rtn); <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g98b61a0ca7456dce466a5f773656e310">INS_Valid</a>(ins); ins = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g2711640bba1359feb3385a0c7b42ff4b">INS_Next</a>(ins))
    {
        <span class="comment">// Insert a call to docount to increment the instruction counter for this rtn</span>
        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811618560294ef8f249387968f55871e69">IARG_PTR</a>, &amp;(rc-&gt;_icount), IARG_END);
    }

    
    <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>(rtn);
}

<span class="comment">// This function is called when the application exits</span>
<span class="comment">// It prints the name and count for each procedure</span>
VOID Fini(INT32 code, VOID *v)
{
    ofstream count(<span class="stringliteral">"proccount.out"</span>);

    count &lt;&lt; setw(23) &lt;&lt; <span class="stringliteral">"Procedure"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(15) &lt;&lt; <span class="stringliteral">"Image"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(18) &lt;&lt; <span class="stringliteral">"Address"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(12) &lt;&lt; <span class="stringliteral">"Calls"</span> &lt;&lt; <span class="stringliteral">" "</span>
          &lt;&lt; setw(12) &lt;&lt; <span class="stringliteral">"Instructions"</span> &lt;&lt; endl;

    <span class="keywordflow">for</span> (RTN_COUNT * rc = RtnList; rc; rc = rc-&gt;_next)
    {
        <span class="keywordflow">if</span> (rc-&gt;_icount &gt; 0)
            count &lt;&lt; setw(23) &lt;&lt; rc-&gt;_name &lt;&lt; <span class="stringliteral">" "</span>
                  &lt;&lt; setw(15) &lt;&lt; rc-&gt;_image &lt;&lt; <span class="stringliteral">" "</span>
                  &lt;&lt; setw(18) &lt;&lt; hex &lt;&lt; rc-&gt;_address &lt;&lt; dec &lt;&lt;<span class="stringliteral">" "</span>
                  &lt;&lt; setw(12) &lt;&lt; rc-&gt;_rtnCount &lt;&lt; <span class="stringliteral">" "</span>
                  &lt;&lt; setw(12) &lt;&lt; rc-&gt;_icount &lt;&lt; endl;
    }

}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This Pintool counts the number of times a routine is executed"</span> &lt;&lt; endl;
    cerr &lt;&lt; <span class="stringliteral">"and the number of instructions executed in a routine"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize symbol table code, needed for rtn instrumentation</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();

    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    <span class="comment">// Register Routine to be called to instrument rtn</span>
    <a class="code" href="group__RTN__BASIC__API.html#g8622a6ba858eb8d55df4e006eb165e57">RTN_AddInstrumentFunction</a>(Routine, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="SafeCopy">
Using PIN_SafeCopy()</a></h3>
PIN_SafeCopy is used to copy the specified number of bytes from a source memory region to a destination memory region. This function guarantees safe return to the caller even if the source or destination regions are inaccessible (entirely or partially).<p>
Use of this function also guarantees that the tool reads or writes the values used by the application. For example, on Windows, Pin replaces certain TEB fields when running a tool's analysis code. If the tool accessed these fields directly, it would see the modified values rather than the original ones. Using <a class="el" href="group__PIN__CONTROL.html#g1e6d08632dccfcd10aec3fbdd2562899">PIN_SafeCopy()</a> allows the tool to read or write the application's values for these fields.<p>
We recommend using this API any time a tool reads or writes application memory.<p>
<div class="fragment"><pre class="fragment">$ pin -t obj-ia32/safecopy.so -- /bin/cp makefile obj-ia32/safecopy.so.makefile.copy
$ head safecopy.out
Emulate loading from addr 0xbff0057c to ebx
Emulate loading from addr 0x64ffd4 to eax
Emulate loading from addr 0xbff00598 to esi
Emulate loading from addr 0x6501c8 to edi
Emulate loading from addr 0x64ff14 to edx
Emulate loading from addr 0x64ff1c to edx
Emulate loading from addr 0x64ff24 to edx
Emulate loading from addr 0x64ff2c to edx
Emulate loading from addr 0x64ff34 to edx
Emulate loading from addr 0x64ff3c to edx
</pre></div><p>
The example can be found in source/tools/ManualExamples/safecopy.cpp.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include "pin_isa.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>

std::ofstream* out = 0;

<span class="comment">//=======================================================</span>
<span class="comment">//  Analysis routines</span>
<span class="comment">//=======================================================</span>

<span class="comment">// Move from memory to register</span>
ADDRINT DoLoad(<a class="code" href="group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641">REG</a> reg, ADDRINT * addr)
{
    *out &lt;&lt; <span class="stringliteral">"Emulate loading from addr "</span> &lt;&lt; addr &lt;&lt; <span class="stringliteral">" to "</span> &lt;&lt; <a class="code" href="group__REG__CPU__GENERIC.html#g6940f3aeb9d4063fe1783efbec5c0287">REG_StringShort</a>(reg) &lt;&lt; endl;
    ADDRINT value;
    <a class="code" href="group__PIN__CONTROL.html#g1e6d08632dccfcd10aec3fbdd2562899">PIN_SafeCopy</a>(&amp;value, addr, <span class="keyword">sizeof</span>(ADDRINT));
    <span class="keywordflow">return</span> value;
}

<span class="comment">//=======================================================</span>
<span class="comment">// Instrumentation routines</span>
<span class="comment">//=======================================================</span>

VOID EmulateLoad(INS ins, VOID* v)
{
    <span class="comment">// Find the instructions that move a value from memory to a register</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g82b583eb54370b90eb16013b9ceccb0a">INS_Opcode</a>(ins) == XED_ICLASS_MOV &amp;&amp;
        <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g52d77b7e3ad272c7aed02875dc9907d5">INS_IsMemoryRead</a>(ins) &amp;&amp; 
        <a class="code" href="group__INS__BASIC__API__IA32.html#gda61f0bd5ba11973274b344ccf76b5d3">INS_OperandIsReg</a>(ins, 0) &amp;&amp;
        <a class="code" href="group__INS__BASIC__API__IA32.html#g4e3ee4b5d8346e8f32e5154a720ab093">INS_OperandIsMemory</a>(ins, 1))
    {
        <span class="comment">// op0 &lt;- *op1</span>
        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins,
                       <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>,
                       AFUNPTR(DoLoad),
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>,
                       <a class="code" href="group__REG__CPU__IA32.html#g3b77029a2a445f70f0206dbad1e4e641">REG</a>(<a class="code" href="group__INS__BASIC__API__IA32.html#g556f7a38ca8ca40562d77810940f46b9">INS_OperandReg</a>(ins, 0)),
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56813cf8e5e03da1a8033539aab405df247a">IARG_MEMORYREAD_EA</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56817c4e6beb62b49ef970699ac2263b227c">IARG_RETURN_REGS</a>,
                       <a class="code" href="group__INS__BASIC__API__IA32.html#g556f7a38ca8ca40562d77810940f46b9">INS_OperandReg</a>(ins, 0),
                       IARG_END);

        <span class="comment">// Delete the instruction</span>
        <a class="code" href="group__INS__MOD__API__GEN__IA32.html#g408da5197af3462940d9d0de25bb886a">INS_Delete</a>(ins);
    }
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool demonstrates the use of SafeCopy"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    out = <span class="keyword">new</span> std::ofstream(<span class="stringliteral">"safecopy.out"</span>);

    <span class="comment">// Initialize pin &amp; symbol manager</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();

    <span class="comment">// Register EmulateLoad to be called to instrument instructions</span>
    <a class="code" href="group__INS__INST__API.html#ga80cd9a7905b82a86b9e31d9bf589dbe">INS_AddInstrumentFunction</a>(EmulateLoad, 0);

    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();   
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="Invocation">
Order of Instrumentation</a></h3>
The calls inserted by <a class="el" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall()</a> and <a class="el" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall()</a> are executed in the order in which they were inserted. The INS_InsertCall(ins, IPOINT_TAKEN_BRANCH, ...) API is executed last. The RTN_InsertCall(rtn, IPOINT_AFTER, ...) API is implemented by instrumenting each return instruction in a routine. Pin tries to find all return instructions, but success is not guaranteed. The example below instruments all return instructions three different ways.<p>
<div class="fragment"><pre class="fragment">$ pin -t obj-ia32/invocation.so -- obj-ia32/little_malloc
$ head invocation.out
After: IP = 0x64bc5e
Before: IP = 0x64bc5e
Taken: IP = 0x63a12e
After: IP = 0x64bc5e
Before: IP = 0x64bc5e
Taken: IP = 0x641c76
After: IP = 0x641ca6
After: IP = 0x64bc5e
Before: IP = 0x64bc5e
Taken: IP = 0x648b02
</pre></div><p>
The example can be found in source/tools/ManualExamples/invocation.cpp.<p>
<div class="fragment"><pre class="fragment">
<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="keyword">using namespace </span>std;


KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"invocation.out"</span>, <span class="stringliteral">"specify output file name"</span>);

ofstream OutFile;

<span class="comment">/*</span>
<span class="comment"> * Analysis routines</span>
<span class="comment"> */</span>
VOID Taken( <span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> * ctxt)
{
    ADDRINT TakenIP = (ADDRINT)<a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>( ctxt, REG_INST_PTR );
    OutFile &lt;&lt; <span class="stringliteral">"Taken: IP = "</span> &lt;&lt; hex &lt;&lt; TakenIP &lt;&lt; dec &lt;&lt; endl;
}

VOID Before(<a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> * ctxt)
{
    ADDRINT BeforeIP = (ADDRINT)<a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>( ctxt, REG_INST_PTR);
    OutFile &lt;&lt; <span class="stringliteral">"Before: IP = "</span> &lt;&lt; hex &lt;&lt; BeforeIP &lt;&lt; dec &lt;&lt; endl;
}


VOID After(<a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> * ctxt)
{
    ADDRINT AfterIP = (ADDRINT)<a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>( ctxt, REG_INST_PTR);
    OutFile &lt;&lt; <span class="stringliteral">"After: IP = "</span> &lt;&lt; hex &lt;&lt; AfterIP &lt;&lt; dec &lt;&lt; endl;
}

    
<span class="comment">/*</span>
<span class="comment"> * Instrumentation routines</span>
<span class="comment"> */</span>
VOID ImageLoad(IMG img, VOID *v)
{
    <span class="keywordflow">for</span> (SEC sec = <a class="code" href="group__IMG__BASIC__API.html#gc217d3b81c96828a0ee9a7574d3ac05f">IMG_SecHead</a>(img); <a class="code" href="group__SEC__BASIC__API.html#g1b12fe810ea34835d192449f8d41e226">SEC_Valid</a>(sec); sec = <a class="code" href="group__SEC__BASIC__API.html#g594dcea6346920b05dc979e379959a77">SEC_Next</a>(sec))
    {
        <span class="comment">// RTN_InsertCall() and INS_InsertCall() are executed in order of</span>
        <span class="comment">// appearance.  In the code sequence below, the IPOINT_AFTER is</span>
        <span class="comment">// executed before the IPOINT_BEFORE.</span>
        <span class="keywordflow">for</span> (RTN rtn = <a class="code" href="group__SEC__BASIC__API.html#g3015a2dd44717006bca05e459b344b42">SEC_RtnHead</a>(sec); <a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>(rtn); rtn = <a class="code" href="group__RTN__BASIC__API.html#gf21d0d3fd6851e83e42827f09c03a4e7">RTN_Next</a>(rtn))
        {
            <span class="comment">// Open the RTN.</span>
            <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>( rtn );
            
            <span class="comment">// IPOINT_AFTER is implemented by instrumenting each return</span>
            <span class="comment">// instruction in a routine.  Pin tries to find all return</span>
            <span class="comment">// instructions, but success is not guaranteed.</span>
            <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>( rtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a214b3338de54a3d5823a5b612fd4d2d846">IPOINT_AFTER</a>, (AFUNPTR)After,
                            <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56819673f5f1a6c7d03d31a2eab0af88628e">IARG_CONTEXT</a>, IARG_END);
            
            <span class="comment">// Examine each instruction in the routine.</span>
            <span class="keywordflow">for</span>( INS ins = <a class="code" href="group__RTN__BASIC__API.html#gb49dd96d5d0d0fdcf38c922585c6ba06">RTN_InsHead</a>(rtn); <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g98b61a0ca7456dce466a5f773656e310">INS_Valid</a>(ins); ins = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g2711640bba1359feb3385a0c7b42ff4b">INS_Next</a>(ins) )
            {
                <span class="keywordflow">if</span>( <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g487a70954c5adee0c5084995819a513d">INS_IsRet</a>(ins) )
                {
                    <span class="comment">// instrument each return instruction.</span>
                    <span class="comment">// IPOINT_TAKEN_BRANCH always occurs last.</span>
                    <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>( ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)Before,
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56819673f5f1a6c7d03d31a2eab0af88628e">IARG_CONTEXT</a>, IARG_END);
                    <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>( ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21e3df50f902d3b951e0a8ab8afbcf2902">IPOINT_TAKEN_BRANCH</a>, (AFUNPTR)Taken,
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56819673f5f1a6c7d03d31a2eab0af88628e">IARG_CONTEXT</a>, IARG_END);
                }
            }
            <span class="comment">// Close the RTN.</span>
            <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>( rtn );
        }
    }
}

VOID Fini(INT32 code, VOID *v)
{
    OutFile.close();
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This is the invocation pintool"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin &amp; symbol manager</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();

    <span class="comment">// Register ImageLoad to be called to instrument instructions</span>
    <a class="code" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction</a>(ImageLoad, 0);
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);

    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    OutFile.open(KnobOutputFile.Value().c_str());
    OutFile.setf(ios::showbase);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
<span class="comment">/* ===================================================================== */</span>
    
</pre></div><h3><a class="anchor" name="FunctionArguments">
Finding the Value of Function Arguments</a></h3>
Often one needs the know the value of the argument passed into a function, or the return value. You can use Pin to find this information. Using the <a class="el" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall()</a> function, you can specify the arguments of interest.<p>
The example below prints the input argument for malloc() and free(), and the return value from malloc().<p>
<div class="fragment"><pre class="fragment">$ pin -t obj-ia32/malloctrace.so -- /bin/cp makefile obj-ia32/malloctrace.so.makefile.copy
$ head malloctrace.out
malloc(0x24d)
  returns 0x6504f8
malloc(0x57)
  returns 0x650748
malloc(0xc)
  returns 0x6507a0
malloc(0x3c0)
  returns 0x6507b0
malloc(0xc)
  returns 0x650b70
</pre></div><p>
The example can be found in source/tools/ManualExamples/malloctrace.cpp.<p>
<div class="fragment"><pre class="fragment">
<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Names of malloc and free */</span>
<span class="comment">/* ===================================================================== */</span>
<span class="preprocessor">#if defined(TARGET_MAC)</span>
<span class="preprocessor"></span><span class="preprocessor">#define MALLOC "_malloc"</span>
<span class="preprocessor"></span><span class="preprocessor">#define FREE "_free"</span>
<span class="preprocessor"></span><span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#define MALLOC "malloc"</span>
<span class="preprocessor"></span><span class="preprocessor">#define FREE "free"</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Global Variables */</span>
<span class="comment">/* ===================================================================== */</span>

std::ofstream TraceFile;

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Commandline Switches */</span>
<span class="comment">/* ===================================================================== */</span>

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"malloctrace.out"</span>, <span class="stringliteral">"specify trace file name"</span>);

<span class="comment">/* ===================================================================== */</span>


<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Analysis routines                                                     */</span>
<span class="comment">/* ===================================================================== */</span>
 
VOID Arg1Before(CHAR * name, ADDRINT size)
{
    TraceFile &lt;&lt; name &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; endl;
}

VOID MallocAfter(ADDRINT ret)
{
    TraceFile &lt;&lt; <span class="stringliteral">"  returns "</span> &lt;&lt; ret &lt;&lt; endl;
}


<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Instrumentation routines                                              */</span>
<span class="comment">/* ===================================================================== */</span>
   
VOID Image(IMG img, VOID *v)
{
    <span class="comment">// Instrument the malloc() and free() functions.  Print the input argument</span>
    <span class="comment">// of each malloc() or free(), and the return value of malloc().</span>
    <span class="comment">//</span>
    <span class="comment">//  Find the malloc() function.</span>
    RTN mallocRtn = <a class="code" href="group__RTN__BASIC__API.html#g926d67b40afab106e86ccbb33565c889">RTN_FindByName</a>(img, MALLOC);
    <span class="keywordflow">if</span> (<a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>(mallocRtn))
    {
        <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>(mallocRtn);

        <span class="comment">// Instrument malloc() to print the input argument value and the return value.</span>
        <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(mallocRtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)Arg1Before,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, MALLOC,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c82efb4d44af4401e73fc01b7ac1c3c3">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 0,
                       IARG_END);
        <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(mallocRtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a214b3338de54a3d5823a5b612fd4d2d846">IPOINT_AFTER</a>, (AFUNPTR)MallocAfter,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681bfe16dc65390153dcbaea818fb0f77da">IARG_FUNCRET_EXITPOINT_VALUE</a>, IARG_END);

        <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>(mallocRtn);
    }

    <span class="comment">// Find the free() function.</span>
    RTN freeRtn = <a class="code" href="group__RTN__BASIC__API.html#g926d67b40afab106e86ccbb33565c889">RTN_FindByName</a>(img, FREE);
    <span class="keywordflow">if</span> (<a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>(freeRtn))
    {
        <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>(freeRtn);
        <span class="comment">// Instrument free() to print the input argument value.</span>
        <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(freeRtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)Arg1Before,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, FREE,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c82efb4d44af4401e73fc01b7ac1c3c3">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 0,
                       IARG_END);
        <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>(freeRtn);
    }
}

<span class="comment">/* ===================================================================== */</span>

VOID Fini(INT32 code, VOID *v)
{
    TraceFile.close();
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>
   
INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool produces a trace of calls to malloc."</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="comment">// Initialize pin &amp; symbol manager</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    <span class="keywordflow">if</span>( <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc,argv) )
    {
        <span class="keywordflow">return</span> Usage();
    }
    
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    TraceFile.open(KnobOutputFile.Value().c_str());
    TraceFile &lt;&lt; hex;
    TraceFile.setf(ios::showbase);
    
    <span class="comment">// Register Image to be called to instrument functions.</span>
    <a class="code" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction</a>(Image, 0);
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);

    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* eof */</span>
<span class="comment">/* ===================================================================== */</span>
</pre></div><h3><a class="anchor" name="FindSymbol">
Finding Functions By Name on Windows</a></h3>
Finding functions by name on Windows requires a different methodology. Several symbols could resolve to the same function address. It is important to check all symbol names.<p>
The following example finds the function name in the symbol table, and uses the symbol address to find the appropriate RTN.<p>
<div class="fragment"><pre class="fragment">$ pin  -t obj-ia32\w_malloctrace.dll -- ..\Tests\obj-ia32\cp-pin.exe makefile w_malloctrace.makefile.copy
$ head *.out
Before: RtlAllocateHeap(00150000, 0, 0x94)
After: RtlAllocateHeap  returns 0x153440
After: RtlAllocateHeap  returns 0x153440
Before: RtlAllocateHeap(00150000, 0, 0x20)
After: RtlAllocateHeap  returns 0
After: RtlAllocateHeap  returns 0x1567c0
Before: RtlAllocateHeap(019E0000, 0x8, 0x1800)
After: RtlAllocateHeap  returns 0x19e0688
Before: RtlAllocateHeap(00150000, 0, 0x1a)thread begin 0

After: RtlAllocateHeap  returns 0
</pre></div><p>
The example can be found in source/tools/ManualExamples/w_malloctrace.cpp.<p>
<div class="fragment"><pre class="fragment"><span class="comment">/* ===================================================================== */</span>
<span class="comment">/* This example demonstrates finding a function by name on Windows.      */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="preprocessor">#include "pin.H"</span>
<span class="keyword">namespace </span>WINDOWS
{
<span class="preprocessor">#include&lt;Windows.h&gt;</span>
}
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Global Variables */</span>
<span class="comment">/* ===================================================================== */</span>

std::ofstream TraceFile;

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Commandline Switches */</span>
<span class="comment">/* ===================================================================== */</span>

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"w_malloctrace.out"</span>, <span class="stringliteral">"specify trace file name"</span>);

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool produces a trace of calls to RtlAllocateHeap."</span>;
    cerr &lt;&lt; endl &lt;&lt; endl;
    cerr &lt;&lt; KNOB_BASE::StringKnobSummary();
    cerr &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Analysis routines                                                     */</span>
<span class="comment">/* ===================================================================== */</span>
 
VOID Before(CHAR * name, WINDOWS::HANDLE hHeap,
            WINDOWS::DWORD dwFlags, WINDOWS::DWORD dwBytes) 
{
    TraceFile &lt;&lt; <span class="stringliteral">"Before: "</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">"("</span> &lt;&lt; hex &lt;&lt; hHeap &lt;&lt; <span class="stringliteral">", "</span>
              &lt;&lt; dwFlags &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; dwBytes &lt;&lt; <span class="stringliteral">")"</span> &lt;&lt; dec &lt;&lt; endl;
}

VOID After(CHAR * name, ADDRINT ret)
{
    TraceFile &lt;&lt; <span class="stringliteral">"After: "</span> &lt;&lt; name &lt;&lt; <span class="stringliteral">"  returns "</span> &lt;&lt; hex
              &lt;&lt; ret &lt;&lt; dec &lt;&lt; endl;
}


<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Instrumentation routines                                              */</span>
<span class="comment">/* ===================================================================== */</span>
   
VOID Image(IMG img, VOID *v)
{
    <span class="comment">// Walk through the symbols in the symbol table.</span>
    <span class="comment">//</span>
    <span class="keywordflow">for</span> (SYM sym = <a class="code" href="group__IMG__BASIC__API.html#g80dd86f9de65aa86b2db7d33aae819ff">IMG_RegsymHead</a>(img); <a class="code" href="group__SYM__BASIC__API.html#ge83aad6ccb150a96e6bde242326a8ad4">SYM_Valid</a>(sym); sym = <a class="code" href="group__SYM__BASIC__API.html#ge180d8ef29e941662eae416f92adbd72">SYM_Next</a>(sym))
    {
        string undFuncName = <a class="code" href="group__SYM__BASIC__API.html#gd02e31773f5a8aef5e5a70be7f09dd17">PIN_UndecorateSymbolName</a>(<a class="code" href="group__SYM__BASIC__API.html#g2322cb4a1c052fa27420f66b1f3eb8e3">SYM_Name</a>(sym), <a class="code" href="group__SYM__BASIC__API.html#gg8aa0db3277ed9b401a204bf2d1bdc6aa7ac5b7ca1c9423fbe3d44bfbda828c43">UNDECORATION_NAME_ONLY</a>);

        <span class="comment">//  Find the RtlAllocHeap() function.</span>
        <span class="keywordflow">if</span> (undFuncName == <span class="stringliteral">"RtlAllocateHeap"</span>)
        {
            RTN allocRtn = <a class="code" href="group__RTN__BASIC__API.html#gc9d3d0a9e51f251da80910c74d4118c9">RTN_FindByAddress</a>(<a class="code" href="group__IMG__BASIC__API.html#g08c181dc4776ed954ebda9c5c28ce6c4">IMG_LowAddress</a>(img) + <a class="code" href="group__SYM__BASIC__API.html#g00de931c3077bdbfa72bb16c49fc007d">SYM_Value</a>(sym));
            
            <span class="keywordflow">if</span> (<a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>(allocRtn))
            {
                <span class="comment">// Instrument to print the input argument value and the return value.</span>
                <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>(allocRtn);
                
                <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(allocRtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)Before,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, <span class="stringliteral">"RtlAllocateHeap"</span>,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c82efb4d44af4401e73fc01b7ac1c3c3">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 0,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c82efb4d44af4401e73fc01b7ac1c3c3">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 1,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c82efb4d44af4401e73fc01b7ac1c3c3">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 2,
                               IARG_END);
                <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(allocRtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a214b3338de54a3d5823a5b612fd4d2d846">IPOINT_AFTER</a>, (AFUNPTR)After,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, <span class="stringliteral">"RtlAllocateHeap"</span>,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681bfe16dc65390153dcbaea818fb0f77da">IARG_FUNCRET_EXITPOINT_VALUE</a>,
                               IARG_END);
                
                <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>(allocRtn);
            }
        }
    }
}

<span class="comment">/* ===================================================================== */</span>

VOID Fini(INT32 code, VOID *v)
{
    TraceFile.close();
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="comment">// Initialize pin &amp; symbol manager</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    <span class="keywordflow">if</span>( <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc,argv) )
    {
        <span class="keywordflow">return</span> Usage();
    }
    
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    TraceFile.open(KnobOutputFile.Value().c_str());
    TraceFile &lt;&lt; hex;
    TraceFile.setf(ios::showbase);
    
    <span class="comment">// Register Image to be called to instrument functions.</span>
    <a class="code" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction</a>(Image, 0);
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);

    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* eof */</span>
<span class="comment">/* ===================================================================== */</span>
</pre></div><h3><a class="anchor" name="MallocMT">
Instrumenting Threaded Applications</a></h3>
The following example demonstrates using the ThreadStart() and ThreadFini() notification callbacks. Although ThreadStart() and ThreadFini() are executed under the VM and client locks, they could still contend with resources that are shared by other analysis routines. Using PIN_GetLock() prevents this.<p>
Note that there is known isolation issue when using Pin on Windows. On Windows, a deadlock can occur if a tool opens a file in a callback when run on a multi-threaded application. To work around this problem, open one file in main, and tag the data with the thread ID. See source/tools/ManualExamples/buffer-win.cpp as an example. This problem does not exist on Linux.<p>
<div class="fragment"><pre class="fragment">$ pin -t obj-ia32/malloc_mt.so -- obj-ia32/thread_lin
$ head malloc_mt.out
thread begin 0
thread 0 entered malloc(24d)
thread 0 entered malloc(57)
thread 0 entered malloc(c)
thread 0 entered malloc(3c0)
thread 0 entered malloc(c)
thread 0 entered malloc(58)
thread 0 entered malloc(56)
thread 0 entered malloc(19)
thread 0 entered malloc(25c)
</pre></div><p>
The example can be found in source/tools/ManualExamples/malloc_mt.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"malloc_mt.out"</span>, <span class="stringliteral">"specify output file name"</span>);

<span class="comment">//==============================================================</span>
<span class="comment">//  Analysis Routines</span>
<span class="comment">//==============================================================</span>
<span class="comment">// Note:  threadid+1 is used as an argument to the GetLock()</span>
<span class="comment">//        routine as a debugging aid.  This is the value that</span>
<span class="comment">//        the lock is set to, so it must be non-zero.</span>

<span class="comment">// lock serializes access to the output file.</span>
FILE * out;
<a class="code" href="group__LOCK.html#gf6a5e5e7a828fea525903e0f2757bee6">PIN_LOCK</a> lock;

<span class="comment">// Note that opening a file in a callback is only supported on Linux systems.</span>
<span class="comment">// See buffer-win.cpp for how to work around this issue on Windows.</span>
<span class="comment">//</span>
<span class="comment">// This routine is executed every time a thread is created.</span>
VOID ThreadStart(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid, <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, INT32 flags, VOID *v)
{
    <a class="code" href="group__LOCK.html#g36070bd375e4defc52ecfc38f9c46732">GetLock</a>(&amp;lock, threadid+1);
    fprintf(out, <span class="stringliteral">"thread begin %d\n"</span>,threadid);
    fflush(out);
    <a class="code" href="group__LOCK.html#ge1f816bf92874cea96639dac6af37849">ReleaseLock</a>(&amp;lock);
}

<span class="comment">// This routine is executed every time a thread is destroyed.</span>
VOID ThreadFini(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid, <span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, INT32 code, VOID *v)
{
    <a class="code" href="group__LOCK.html#g36070bd375e4defc52ecfc38f9c46732">GetLock</a>(&amp;lock, threadid+1);
    fprintf(out, <span class="stringliteral">"thread end %d code %d\n"</span>,threadid, code);
    fflush(out);
    <a class="code" href="group__LOCK.html#ge1f816bf92874cea96639dac6af37849">ReleaseLock</a>(&amp;lock);
}

<span class="comment">// This routine is executed each time malloc is called.</span>
VOID BeforeMalloc( <span class="keywordtype">int</span> size, <a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid )
{
    <a class="code" href="group__LOCK.html#g36070bd375e4defc52ecfc38f9c46732">GetLock</a>(&amp;lock, threadid+1);
    fprintf(out, <span class="stringliteral">"thread %d entered malloc(%d)\n"</span>, threadid, size);
    fflush(out);
    <a class="code" href="group__LOCK.html#ge1f816bf92874cea96639dac6af37849">ReleaseLock</a>(&amp;lock);
}


<span class="comment">//====================================================================</span>
<span class="comment">// Instrumentation Routines</span>
<span class="comment">//====================================================================</span>

<span class="comment">// This routine is executed for each image.</span>
VOID ImageLoad(IMG img, VOID *)
{
    RTN rtn = <a class="code" href="group__RTN__BASIC__API.html#g926d67b40afab106e86ccbb33565c889">RTN_FindByName</a>(img, <span class="stringliteral">"malloc"</span>);
    
    <span class="keywordflow">if</span> ( <a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>( rtn ))
    {
        <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>(rtn);
        
        <a class="code" href="group__RTN__BASIC__API.html#g006ef964b9e6e4d8e7880231e216344a">RTN_InsertCall</a>(rtn, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, AFUNPTR(BeforeMalloc),
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c82efb4d44af4401e73fc01b7ac1c3c3">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 0,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681d04f1eb185e914f0f11a839e2c26cbd8">IARG_THREAD_ID</a>, IARG_END);

        <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>(rtn);
    }
}

<span class="comment">// This routine is executed once at the end.</span>
VOID Fini(INT32 code, VOID *v)
{
    fclose(out);
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    PIN_ERROR(<span class="stringliteral">"This Pintool prints a trace of malloc calls in the guest application\n"</span>
              + KNOB_BASE::StringKnobSummary() + <span class="stringliteral">"\n"</span>);
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(INT32 argc, CHAR **argv)
{
    <span class="comment">// Initialize the pin lock</span>
    <a class="code" href="group__LOCK.html#g7b98e356ed047ffd72a7a8f7b63620af">InitLock</a>(&amp;lock);
    
    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    
    out = fopen(KnobOutputFile.Value().c_str(), <span class="stringliteral">"w"</span>);

    <span class="comment">// Register ImageLoad to be called when each image is loaded.</span>
    <a class="code" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction</a>(ImageLoad, 0);

    <span class="comment">// Register Analysis routines to be called when a thread begins/ends</span>
    <a class="code" href="group__PIN__CONTROL.html#gd990464123111fae4a3e575039b11af7">PIN_AddThreadStartFunction</a>(ThreadStart, 0);
    <a class="code" href="group__PIN__CONTROL.html#g2d6c3eea4ebe3e76baed4481b079e3b1">PIN_AddThreadFiniFunction</a>(ThreadFini, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="InscountTLS">
Using TLS</a></h3>
Pin provides efficient thread local storage (TLS) APIs. These APIs allow a tool to create thread-specific data. The example below demonstrates how to use these APIs.<p>
<div class="fragment"><pre class="fragment">$ pin -t obj-ia32/inscount_tls.so -- ./obj-ia32/thread_lin
$ head
Count[0]= 237993
Count[1]= 213296
Count[2]= 209223
Count[3]= 209223
Count[4]= 209223
Count[5]= 209223
Count[6]= 209223
Count[7]= 209223
Count[8]= 209223
Count[9]= 209223
</pre></div><p>
The example can be found in source/tools/ManualExamples/inscount_tls.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"inscount_tls.out"</span>, <span class="stringliteral">"specify output file name"</span>);

<a class="code" href="group__LOCK.html#gf6a5e5e7a828fea525903e0f2757bee6">PIN_LOCK</a> lock;
INT32 numThreads = 0;

<span class="comment">// Force each thread's data to be in its own data cache line so that</span>
<span class="comment">// multiple threads do not contend for the same data cache line.</span>
<span class="comment">// This avoids the false sharing problem.</span>
<span class="preprocessor">#define PADSIZE 56  // 64 byte line size: 64-8</span>
<span class="preprocessor"></span>
<span class="comment">// a running count of the instructions</span>
<span class="keyword">class </span>thread_data_t
{
  <span class="keyword">public</span>:
    thread_data_t() : _count(0) {}
    UINT64 _count;
    UINT8 _pad[PADSIZE];
};


<span class="comment">// key for accessing TLS storage in the threads. initialized once in main()</span>
<span class="keyword">static</span>  <a class="code" href="group__PIN__THREAD__API.html#g48422bbc491485657227fe94386b964c">TLS_KEY</a> tls_key;

<span class="comment">// function to access thread-specific data</span>
thread_data_t* get_tls(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid)
{
    thread_data_t* tdata = 
          static_cast&lt;thread_data_t*&gt;(<a class="code" href="group__PIN__THREAD__API.html#g428ab4182b5fec58ee34b21362774d5f">PIN_GetThreadData</a>(tls_key, threadid));
    <span class="keywordflow">return</span> tdata;
}

<span class="comment">// This function is called before every block</span>
VOID <a class="code" href="group__INST__ARGS.html#gf3202cd2f4be9bf9d4fa7a035ece147b">PIN_FAST_ANALYSIS_CALL</a> docount(UINT32 c, <a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid)
{
    thread_data_t* tdata = get_tls(threadid);
    tdata-&gt;_count += c;
}

VOID ThreadStart(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid, <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, INT32 flags, VOID *v)
{
    <a class="code" href="group__LOCK.html#g36070bd375e4defc52ecfc38f9c46732">GetLock</a>(&amp;lock, threadid+1);
    numThreads++;
    <a class="code" href="group__LOCK.html#ge1f816bf92874cea96639dac6af37849">ReleaseLock</a>(&amp;lock);

    thread_data_t* tdata = <span class="keyword">new</span> thread_data_t;

    <a class="code" href="group__PIN__THREAD__API.html#g1aa594f2e2588a78829ad0c608a55048">PIN_SetThreadData</a>(tls_key, tdata, threadid);
}


<span class="comment">// Pin calls this function every time a new basic block is encountered.</span>
<span class="comment">// It inserts a call to docount.</span>
VOID Trace(<a class="code" href="group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc">TRACE</a> trace, VOID *v)
{
    <span class="comment">// Visit every basic block  in the trace</span>
    <span class="keywordflow">for</span> (BBL bbl = <a class="code" href="group__TRACE__BASIC__API.html#g1804f26fc605c9344d57be21b392796b">TRACE_BblHead</a>(trace); <a class="code" href="group__BBL__BASIC__API.html#g5aaace888f68ec067f60e3b74c0b9131">BBL_Valid</a>(bbl); bbl = <a class="code" href="group__BBL__BASIC__API.html#g60805b0620b58e2c9ca2add6e16d26ef">BBL_Next</a>(bbl))
    {
        <span class="comment">// Insert a call to docount for every bbl, passing the number of instructions.</span>
        
        <a class="code" href="group__BBL__BASIC__API.html#g5fba2db08badc1f77616c8f41ce31884">BBL_InsertCall</a>(bbl, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a2198931604835e0f9ad1cd29cc1bc1f384">IPOINT_ANYWHERE</a>, (AFUNPTR)docount, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c51073d5f62b8800cb3285ede6f9077e">IARG_FAST_ANALYSIS_CALL</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, <a class="code" href="group__BBL__BASIC__API.html#g3d7437048b7fd658b1e4d413c69d9ccb">BBL_NumIns</a>(bbl), <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681d04f1eb185e914f0f11a839e2c26cbd8">IARG_THREAD_ID</a>, IARG_END);
    }
}

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    ofstream OutFile;
    OutFile.open(KnobOutputFile.Value().c_str());
    OutFile &lt;&lt; <span class="stringliteral">"Total number of threads = "</span> &lt;&lt; numThreads &lt;&lt; endl;
    
    <span class="keywordflow">for</span> (INT32 t=0; t&lt;numThreads; t++)
    {
        thread_data_t* tdata = get_tls(t);
        OutFile &lt;&lt; <span class="stringliteral">"Count["</span> &lt;&lt; <a class="code" href="group__MISC__PRINT.html#gc6fa0ac95dc5a5baf1093baa1efc6b6c">decstr</a>(t) &lt;&lt; <span class="stringliteral">"]= "</span> &lt;&lt; tdata-&gt;_count &lt;&lt; endl;
    }

    OutFile.close();
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool counts the number of dynamic instructions executed"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    <span class="comment">// Initialize the lock</span>
    <a class="code" href="group__LOCK.html#g7b98e356ed047ffd72a7a8f7b63620af">InitLock</a>(&amp;lock);

    <span class="comment">// Obtain  a key for TLS storage.</span>
    tls_key = <a class="code" href="group__PIN__THREAD__API.html#g36b79c1845d1874b1d6fbe7c8e7f3e91">PIN_CreateThreadDataKey</a>(0);

    <span class="comment">// Register ThreadStart to be called when a thread starts.</span>
    <a class="code" href="group__PIN__CONTROL.html#gd990464123111fae4a3e575039b11af7">PIN_AddThreadStartFunction</a>(ThreadStart, 0);

    <span class="comment">// Register Instruction to be called to instrument instructions.</span>
    <a class="code" href="group__TRACE__BASIC__API.html#gb3762f773502ad865216ef941c38799e">TRACE_AddInstrumentFunction</a>(Trace, 0);

    <span class="comment">// Register Fini to be called when the application exits.</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);

    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="Buffering">
Using the Fast Buffering APIs</a></h3>
Pin provides support for buffering data for processing. If all that your analysis callback does is to store its arguments into a buffer, then you should be able to use the buffering API instead, with some performance benefit. <a class="el" href="group__BUFFER__API.html#g16f88ae475a2539bfec3c7ce8b9eb16e">PIN_DefineTraceBuffer()</a> defines the buffer that will be used. The buffer is allocated by each thread when it starts up, and deallocated when the thread exits. <a class="el" href="group__INS__INST__API.html#g4b68e6136fdec6a50269edfa4ff4c977">INS_InsertFillBuffer()</a> writes the requested data directly to the given buffer. The callback delineated in the <a class="el" href="group__BUFFER__API.html#g16f88ae475a2539bfec3c7ce8b9eb16e">PIN_DefineTraceBuffer()</a> call is used to process the buffer when the buffer is nearly full, and when the thread exits. This example records the PC of all instructions that access memory, and the effective address accessed by the instruction.<p>
<div class="fragment"><pre class="fragment">$ pin -t obj-ia32/buffer-lin.so -- ./obj-ia32/thread_lin
$ tail buffer.out.*.*
3263df   330108
3263df   330108
3263f1   a92f43fc
3263f7   a92f4d7d
326404   a92f43fc
32640a   a92f4bf8
32640a   a92f4bf8
32640f   a92f4d94
32641b   a92f43fc
326421   a92f4bf8
</pre></div><p>
The example can be found in source/tools/ManualExamples/buffer-lin.cpp. This example is appropriate for Linux tools. If you are writing a tool for Windows, please see source/tools/ManualExamples/buffer-win.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> * Sample buffering tool</span>
<span class="comment"> * </span>
<span class="comment"> * This tool collects an address trace of instructions that access memory</span>
<span class="comment"> * by filling a buffer.  When the buffer overflows,the callback writes all</span>
<span class="comment"> * of the collected records to a file.</span>
<span class="comment"> *</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include "portability.H"</span>
<span class="keyword">using namespace </span>std;

<span class="comment">/*</span>
<span class="comment"> * Name of the output file</span>
<span class="comment"> */</span>
KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>, <span class="stringliteral">"o"</span>, <span class="stringliteral">"buffer.out"</span>, <span class="stringliteral">"output file"</span>);

<span class="comment">/*</span>
<span class="comment"> * The ID of the buffer</span>
<span class="comment"> */</span>
BUFFER_ID bufId;

<span class="comment">/*</span>
<span class="comment"> * Thread specific data</span>
<span class="comment"> */</span>
<a class="code" href="group__PIN__THREAD__API.html#g48422bbc491485657227fe94386b964c">TLS_KEY</a> mlog_key;

<span class="comment">/*</span>
<span class="comment"> * Number of OS pages for the buffer</span>
<span class="comment"> */</span>
<span class="preprocessor">#define NUM_BUF_PAGES 1024</span>
<span class="preprocessor"></span>

<span class="comment">/*</span>
<span class="comment"> * Record of memory references.  Rather than having two separate</span>
<span class="comment"> * buffers for reads and writes, we just use one struct that includes a</span>
<span class="comment"> * flag for type.</span>
<span class="comment"> */</span>
<span class="keyword">struct </span>MEMREF
{
    ADDRINT     pc;
    ADDRINT     ea;
    UINT32      size;
    BOOL        read;
};


<span class="comment">/*</span>
<span class="comment"> * MLOG - thread specific data that is not handled by the buffering API.</span>
<span class="comment"> */</span>
<span class="keyword">class </span>MLOG
{
  <span class="keyword">public</span>:
    MLOG(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid);
    ~MLOG();

    VOID DumpBufferToFile( <span class="keyword">struct</span> MEMREF * reference, UINT64 numElements, <a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid );

  <span class="keyword">private</span>:
    ofstream _ofile;
};


MLOG::MLOG(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid)
{
    string filename = KnobOutputFile.Value() + <span class="stringliteral">"."</span> + <a class="code" href="group__MISC__PRINT.html#gc6fa0ac95dc5a5baf1093baa1efc6b6c">decstr</a>(getpid_portable()) + <span class="stringliteral">"."</span> + <a class="code" href="group__MISC__PRINT.html#gc6fa0ac95dc5a5baf1093baa1efc6b6c">decstr</a>(tid);
    
    _ofile.open(filename.c_str());
    
    <span class="keywordflow">if</span> ( ! _ofile )
    {
        cerr &lt;&lt; <span class="stringliteral">"Error: could not open output file."</span> &lt;&lt; endl;
        exit(1);
    }
    
    _ofile &lt;&lt; hex;
}


MLOG::~MLOG()
{
    _ofile.close();
}


VOID MLOG::DumpBufferToFile( <span class="keyword">struct</span> MEMREF * reference, UINT64 numElements, <a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid )
{
    <span class="keywordflow">for</span>(UINT64 i=0; i&lt;numElements; i++, reference++)
    {
        <span class="keywordflow">if</span> (reference-&gt;ea != 0)
            _ofile &lt;&lt; reference-&gt;pc &lt;&lt; <span class="stringliteral">"   "</span> &lt;&lt; reference-&gt;ea &lt;&lt; endl;
    }
}



<span class="comment">/**************************************************************************</span>
<span class="comment"> *</span>
<span class="comment"> *  Instrumentation routines</span>
<span class="comment"> *</span>
<span class="comment"> **************************************************************************/</span>

<span class="comment">/*</span>
<span class="comment"> * Insert code to write data to a thread-specific buffer for instructions</span>
<span class="comment"> * that access memory.</span>
<span class="comment"> */</span>
VOID Trace(<a class="code" href="group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc">TRACE</a> trace, VOID *v)
{
    <span class="keywordflow">for</span>(BBL bbl = <a class="code" href="group__TRACE__BASIC__API.html#g1804f26fc605c9344d57be21b392796b">TRACE_BblHead</a>(trace); <a class="code" href="group__BBL__BASIC__API.html#g5aaace888f68ec067f60e3b74c0b9131">BBL_Valid</a>(bbl); bbl=<a class="code" href="group__BBL__BASIC__API.html#g60805b0620b58e2c9ca2add6e16d26ef">BBL_Next</a>(bbl))
    {
        <span class="keywordflow">for</span>(INS ins = <a class="code" href="group__BBL__BASIC__API.html#gc87b625878d4ba42dfbeac2c81ac48bc">BBL_InsHead</a>(bbl); <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g98b61a0ca7456dce466a5f773656e310">INS_Valid</a>(ins); ins=<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g2711640bba1359feb3385a0c7b42ff4b">INS_Next</a>(ins))
        {
            UINT32 memoryOperands = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g5ee651cd69d153bb2ee86594a37e3ad6">INS_MemoryOperandCount</a>(ins);

            <span class="keywordflow">for</span> (UINT32 memOp = 0; memOp &lt; memoryOperands; memOp++)
            {
                UINT32 refSize = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#gf14f2e298d864d2114a8dad4eec1864f">INS_MemoryOperandSize</a>(ins, memOp);

                <span class="comment">// Note that if the operand is both read and written we log it once</span>
                <span class="comment">// for each.</span>
                <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g9200fcba361c9272ad963a5c5cb5c235">INS_MemoryOperandIsRead</a>(ins, memOp))
                {
                    <a class="code" href="group__INS__INST__API.html#g4b68e6136fdec6a50269edfa4ff4c977">INS_InsertFillBuffer</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, bufId,
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>, offsetof(<span class="keyword">struct</span> MEMREF, pc),
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883955f1b855db490b9fca95e5497995">IARG_MEMORYOP_EA</a>, memOp, offsetof(<span class="keyword">struct</span> MEMREF, ea),
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, refSize, offsetof(<span class="keyword">struct</span> MEMREF, size), 
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681dbe9ffb8ed09a01b294343c88b0fe35f">IARG_BOOL</a>, TRUE, offsetof(<span class="keyword">struct</span> MEMREF, read),
                                         IARG_END);
                }

                <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g0cb7a4138a881972c59ca8c855765fba">INS_MemoryOperandIsWritten</a>(ins, memOp))
                {
                    <a class="code" href="group__INS__INST__API.html#g4b68e6136fdec6a50269edfa4ff4c977">INS_InsertFillBuffer</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, bufId,
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>, offsetof(<span class="keyword">struct</span> MEMREF, pc),
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883955f1b855db490b9fca95e5497995">IARG_MEMORYOP_EA</a>, memOp, offsetof(<span class="keyword">struct</span> MEMREF, ea),
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, refSize, offsetof(<span class="keyword">struct</span> MEMREF, size), 
                                         <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681dbe9ffb8ed09a01b294343c88b0fe35f">IARG_BOOL</a>, FALSE, offsetof(<span class="keyword">struct</span> MEMREF, read),
                                         IARG_END);
                }
            }
        }
    }
}


<span class="comment">/**************************************************************************</span>
<span class="comment"> *</span>
<span class="comment"> *  Callback Routines</span>
<span class="comment"> *</span>
<span class="comment"> **************************************************************************/</span>

VOID * BufferFull(BUFFER_ID <span class="keywordtype">id</span>, <a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, <span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, VOID *buf,
                  UINT64 numElements, VOID *v)
{
    <span class="keyword">struct </span>MEMREF * reference=(<span class="keyword">struct </span>MEMREF*)buf;

    MLOG * mlog = static_cast&lt;MLOG*&gt;( <a class="code" href="group__PIN__THREAD__API.html#g428ab4182b5fec58ee34b21362774d5f">PIN_GetThreadData</a>( mlog_key, tid ) );

    mlog-&gt;DumpBufferToFile( reference, numElements, tid );
    
    <span class="keywordflow">return</span> buf;
}


<span class="comment">/*</span>
<span class="comment"> * Note that opening a file in a callback is only supported on Linux systems.</span>
<span class="comment"> * See buffer-win.cpp for how to work around this issue on Windows.</span>
<span class="comment"> */</span>
VOID ThreadStart(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, INT32 flags, VOID *v)
{
    <span class="comment">// There is a new MLOG for every thread.  Opens the output file.</span>
    MLOG * mlog = <span class="keyword">new</span> MLOG(tid);

    <span class="comment">// A thread will need to look up its MLOG, so save pointer in TLS</span>
    <a class="code" href="group__PIN__THREAD__API.html#g1aa594f2e2588a78829ad0c608a55048">PIN_SetThreadData</a>(mlog_key, mlog, tid);

}


VOID ThreadFini(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid, <span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, INT32 code, VOID *v)
{
    MLOG * mlog = static_cast&lt;MLOG*&gt;(<a class="code" href="group__PIN__THREAD__API.html#g428ab4182b5fec58ee34b21362774d5f">PIN_GetThreadData</a>(mlog_key, tid));

    <span class="keyword">delete</span> mlog;

    <a class="code" href="group__PIN__THREAD__API.html#g1aa594f2e2588a78829ad0c608a55048">PIN_SetThreadData</a>(mlog_key, 0, tid);
}


<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool demonstrates the basic use of the buffering API."</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}


<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="comment">// Initialize PIN library. Print help message if -h(elp) is specified</span>
    <span class="comment">// in the command line or the command line is invalid</span>
    <span class="keywordflow">if</span>( <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc,argv) )
    {
        <span class="keywordflow">return</span> Usage();
    }
    
    <span class="comment">// Initialize the memory reference buffer;</span>
    <span class="comment">// set up the callback to process the buffer.</span>
    <span class="comment">//</span>
    bufId = <a class="code" href="group__BUFFER__API.html#g16f88ae475a2539bfec3c7ce8b9eb16e">PIN_DefineTraceBuffer</a>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> MEMREF), NUM_BUF_PAGES,
                                  BufferFull, 0);

    <span class="keywordflow">if</span>(bufId == BUFFER_ID_INVALID)
    {
        cerr &lt;&lt; <span class="stringliteral">"Error: could not allocate initial buffer"</span> &lt;&lt; endl;
        <span class="keywordflow">return</span> 1;
    }

    <span class="comment">// Initialize thread-specific data not handled by buffering api.</span>
    mlog_key = <a class="code" href="group__PIN__THREAD__API.html#g36b79c1845d1874b1d6fbe7c8e7f3e91">PIN_CreateThreadDataKey</a>(0);
   
    <span class="comment">// add an instrumentation function</span>
    <a class="code" href="group__TRACE__BASIC__API.html#gb3762f773502ad865216ef941c38799e">TRACE_AddInstrumentFunction</a>(Trace, 0);

    <span class="comment">// add callbacks</span>
    <a class="code" href="group__PIN__CONTROL.html#gd990464123111fae4a3e575039b11af7">PIN_AddThreadStartFunction</a>(ThreadStart, 0);
    <a class="code" href="group__PIN__CONTROL.html#g2d6c3eea4ebe3e76baed4481b079e3b1">PIN_AddThreadFiniFunction</a>(ThreadFini, 0);

    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}


</pre></div><h3><a class="anchor" name="StaticInstructionCounts">
Finding the Static Properties of an Image</a></h3>
It is also possible to use pin to examine binaries without instrumenting them. This is useful when you need to know static properties of an image. The sample tool below counts the number of instructions in an image, but does not insert any instrumentation.<p>
The example can be found in source/tools/ManualExamples/staticcount.cpp<p>
<div class="fragment"><pre class="fragment"><span class="comment">//</span>
<span class="comment">// This tool prints a trace of image load and unload events</span>
<span class="comment">//</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>


<span class="comment">// Pin calls this function every time a new img is loaded</span>
<span class="comment">// It can instrument the image, but this example merely</span>
<span class="comment">// counts the number of static instructions in the image</span>

VOID ImageLoad(IMG img, VOID *v)
{
    UINT32 count = 0;
    
    <span class="keywordflow">for</span> (SEC sec = <a class="code" href="group__IMG__BASIC__API.html#gc217d3b81c96828a0ee9a7574d3ac05f">IMG_SecHead</a>(img); <a class="code" href="group__SEC__BASIC__API.html#g1b12fe810ea34835d192449f8d41e226">SEC_Valid</a>(sec); sec = <a class="code" href="group__SEC__BASIC__API.html#g594dcea6346920b05dc979e379959a77">SEC_Next</a>(sec))
    { 
        <span class="keywordflow">for</span> (RTN rtn = <a class="code" href="group__SEC__BASIC__API.html#g3015a2dd44717006bca05e459b344b42">SEC_RtnHead</a>(sec); <a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>(rtn); rtn = <a class="code" href="group__RTN__BASIC__API.html#gf21d0d3fd6851e83e42827f09c03a4e7">RTN_Next</a>(rtn))
        {
            <span class="comment">// Prepare for processing of RTN, an  RTN is not broken up into BBLs,</span>
            <span class="comment">// it is merely a sequence of INSs </span>
            <a class="code" href="group__RTN__BASIC__API.html#g7225aeb74e1fd3f3b554dbbc285653e0">RTN_Open</a>(rtn);
            
            <span class="keywordflow">for</span> (INS ins = <a class="code" href="group__RTN__BASIC__API.html#gb49dd96d5d0d0fdcf38c922585c6ba06">RTN_InsHead</a>(rtn); <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g98b61a0ca7456dce466a5f773656e310">INS_Valid</a>(ins); ins = <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g2711640bba1359feb3385a0c7b42ff4b">INS_Next</a>(ins))
            {
                count++;
            }

            <span class="comment">// to preserve space, release data associated with RTN after we have processed it</span>
            <a class="code" href="group__RTN__BASIC__API.html#g1e79031f51f9dbdc1726cc46b01870c3">RTN_Close</a>(rtn);
        }
    }
    fprintf(stderr, <span class="stringliteral">"Image %s has  %d instructions\n"</span>, <a class="code" href="group__IMG__BASIC__API.html#g9f68164bfac7c031b82549eba91681c3">IMG_Name</a>(img).c_str(), count);
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool prints a log of image load and unload events"</span> &lt;&lt; endl;
    cerr &lt;&lt; <span class="stringliteral">" along with static instruction counts for each image."</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// prepare for image instrumentation mode</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();

    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    <span class="comment">// Register ImageLoad to be called when an image is loaded</span>
    <a class="code" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction</a>(ImageLoad, 0);

    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="DetachPin">
Detaching Pin from the Application</a></h3>
Pin can relinquish control of application any time when invoked via <a class="el" href="group__PIN__CONTROL.html#g0f3537980bb5ab3b0411a83426a32370">PIN_Detach</a>. Control is returned to the original uninstrumented code and the application runs at native speed. Thereafter no instrumented code is ever executed.<p>
The example can be found in source/tools/ManualExamples/detach.cpp<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>

<span class="comment">// This tool shows how to detach Pin from an </span>
<span class="comment">// application that is under Pin's control.</span>

UINT64 icount = 0;

<span class="preprocessor">#define N 10000</span>
<span class="preprocessor"></span>VOID docount() 
{
    icount++;

    <span class="comment">// Release control of application if 10000 </span>
    <span class="comment">// instructions have been executed</span>
    <span class="keywordflow">if</span> ((icount % N) == 0) 
    {
        <a class="code" href="group__PIN__CONTROL.html#g0f3537980bb5ab3b0411a83426a32370">PIN_Detach</a>();
    }
}
 
VOID Instruction(INS ins, VOID *v)
{
    <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)docount, IARG_END);
}

VOID ByeWorld(VOID *v)
{
    std::cerr &lt;&lt; endl &lt;&lt; <span class="stringliteral">"Detached at icount = "</span> &lt;&lt; N &lt;&lt; endl;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool demonstrates how to detach Pin from an "</span> &lt;&lt; endl;
    cerr &lt;&lt; <span class="stringliteral">"application that is under Pin's control"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    <span class="comment">// Callback function to invoke for every </span>
    <span class="comment">// execution of an instruction</span>
    <a class="code" href="group__INS__INST__API.html#ga80cd9a7905b82a86b9e31d9bf589dbe">INS_AddInstrumentFunction</a>(Instruction, 0);
    
    <span class="comment">// Callback functions to invoke before</span>
    <span class="comment">// Pin releases control of the application</span>
    <a class="code" href="group__PIN__CONTROL.html#g451060f5e998243df750ac16720cadcf">PIN_AddDetachFunction</a>(ByeWorld, 0);
    
    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="ReplaceSigProbed">
Replacing a Routine in Probe Mode</a></h3>
Probe mode is a method of using Pin to insert probes at the start of specified routines. A probe is a jump instruction that is placed at the start of the specified routine. The probe redirects the flow of control to the replacement function. Before the probe is inserted, the first few instructions of the specified routine are relocated. It is not uncommon for the replacement function to call the replaced routine. Pin provides the relocated address to facilate this. See the example below.<p>
In probe mode, the application and the replacement routine are run natively. This improves performance, but it puts more responsibility on the tool writer. Probes can only be placed on RTN boundaries.<p>
Many of the PIN APIs that are available in JIT mode are not applicable in Probe mode. In particular, the Pin thread APIs are not supported in Probe mode, because Pin has no information about the threads when the application is run natively. For more information, check the RTN API documentation.<p>
The tool writer must guarantee that there is not jump target where the probe is placed. A probe is five bytes long on IA-32 architecture, seven bytes long on Intel(R) 64 architecture, and one bundle on IA-64 architecture.<p>
Also, it is the tool writer's responsibility to ensure that no thread is currently executing the code where a probe is inserted. Tool writers are encouraged to insert probes when an image is loaded to avoid this problem. Pin will automatically remove the probes when an image is unloaded.<p>
When using probes, Pin must be started with the <a class="el" href="group__PIN__CONTROL.html#g7de96e728655962e8ecb4cfe49bd6c2c">PIN_StartProgramProbed()</a> API.<p>
Additional libraries must be installed to use Probe mode. See <a class="el" href="index.html#LIBRARIES">Libraries for Linux</a> for further information.<p>
The example can be found in source/tools/ManualExamples/replacesigprobed.cpp. To build this test, execute: <div class="fragment"><pre class="fragment">$ make replacesigprobed.test
</pre></div><p>
<div class="fragment"><pre class="fragment"><span class="comment">//  Replace an original function with a custom function defined in the tool using</span>
<span class="comment">//  probes.  The replacement function has a different signature from that of the </span>
<span class="comment">//  original replaced function.</span>

<span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="keyword">using namespace </span>std;

<span class="keyword">typedef</span> VOID * ( *FP_MALLOC )( size_t );

<span class="comment">// This is the replacement routine.</span>
<span class="comment">//</span>
VOID * NewMalloc( FP_MALLOC orgFuncptr, UINT32 arg0, ADDRINT returnIp )
{
    <span class="comment">// Normally one would do something more interesting with this data.</span>
    <span class="comment">//</span>
    cout &lt;&lt; <span class="stringliteral">"NewMalloc ("</span>
         &lt;&lt; hex &lt;&lt; ADDRINT ( orgFuncptr ) &lt;&lt; <span class="stringliteral">", "</span> 
         &lt;&lt; dec &lt;&lt; arg0 &lt;&lt; <span class="stringliteral">", "</span> 
         &lt;&lt; hex &lt;&lt; returnIp &lt;&lt; <span class="stringliteral">")"</span>
         &lt;&lt; endl &lt;&lt; flush;

    <span class="comment">// Call the relocated entry point of the original (replaced) routine.</span>
    <span class="comment">//</span>
    VOID * v = orgFuncptr( arg0 );

    <span class="keywordflow">return</span> v;
}


<span class="comment">// Pin calls this function every time a new img is loaded.</span>
<span class="comment">// It is best to do probe replacement when the image is loaded,</span>
<span class="comment">// because only one thread knows about the image at this time.</span>
<span class="comment">//</span>
VOID ImageLoad( IMG img, VOID *v )
{
    <span class="comment">// See if malloc() is present in the image.  If so, replace it.</span>
    <span class="comment">//</span>
    RTN rtn = <a class="code" href="group__RTN__BASIC__API.html#g926d67b40afab106e86ccbb33565c889">RTN_FindByName</a>( img, <span class="stringliteral">"malloc"</span> );
    
    <span class="keywordflow">if</span> (<a class="code" href="group__RTN__BASIC__API.html#g2883b22d046e8c6c5ac303465dfa4ed6">RTN_Valid</a>(rtn))
    {
        cout &lt;&lt; <span class="stringliteral">"Replacing malloc in "</span> &lt;&lt; <a class="code" href="group__IMG__BASIC__API.html#g9f68164bfac7c031b82549eba91681c3">IMG_Name</a>(img) &lt;&lt; endl;
        
        <span class="comment">// Define a function prototype that describes the application routine</span>
        <span class="comment">// that will be replaced.</span>
        <span class="comment">//</span>
        <a class="code" href="group__PROTO__API.html#gaa40d7e36e9ad7a07ee68adb5b312377">PROTO</a> proto_malloc = <a class="code" href="group__PROTO__API.html#g49300accd53f8e574af0b706ee553625">PROTO_Allocate</a>( <a class="code" href="group__PROTO__API.html#gae8aea17c700049aa39c32c370874f47">PIN_PARG</a>(<span class="keywordtype">void</span> *), CALLINGSTD_DEFAULT,
                                             <span class="stringliteral">"malloc"</span>, <a class="code" href="group__PROTO__API.html#gae8aea17c700049aa39c32c370874f47">PIN_PARG</a>(<span class="keywordtype">int</span>), <a class="code" href="group__PROTO__API.html#gb8a98de8d0939ae762c9b890097a350b">PIN_PARG_END</a>() );
        
        <span class="comment">// Replace the application routine with the replacement function.</span>
        <span class="comment">// Additional arguments have been added to the replacement routine.</span>
        <span class="comment">//</span>
        <a class="code" href="group__RTN__BASIC__API.html#g5cc8019660f41cae2449c826a878afe0">RTN_ReplaceSignatureProbed</a>(rtn, AFUNPTR(NewMalloc),
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681f007683926859b1cfd7c10c66a3555e2">IARG_PROTOTYPE</a>, proto_malloc,
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56812a8d49dccc99d1dfaeb26d8b3e583505">IARG_ORIG_FUNCPTR</a>,
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c82efb4d44af4401e73fc01b7ac1c3c3">IARG_FUNCARG_ENTRYPOINT_VALUE</a>, 0,
                                   <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681a9f63b1e494a1c86d00e4836f845c0c5">IARG_RETURN_IP</a>,
                                   IARG_END);

        <span class="comment">// Free the function prototype.</span>
        <span class="comment">//</span>
        <a class="code" href="group__PROTO__API.html#g0affd7dbe19f86b3b3ffb260540d37e4">PROTO_Free</a>( proto_malloc );
    }
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool demonstrates how to replace an original"</span> &lt;&lt; endl;
    cerr &lt;&lt; <span class="stringliteral">" function with a custom function defined in the tool "</span> &lt;&lt; endl;
    cerr &lt;&lt; <span class="stringliteral">" using probes.  The replacement function has a different "</span> &lt;&lt; endl;
    cerr &lt;&lt; <span class="stringliteral">" signature from that of the original replaced function."</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main: Initialize and start Pin in Probe mode.                         */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main( INT32 argc, CHAR *argv[] )
{
    <span class="comment">// Initialize symbol processing</span>
    <span class="comment">//</span>
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    
    <span class="comment">// Initialize pin</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();
    
    <span class="comment">// Register ImageLoad to be called when an image is loaded</span>
    <span class="comment">//</span>
    <a class="code" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction</a>( ImageLoad, 0 );
    
    <span class="comment">// Start the program in probe mode, never returns</span>
    <span class="comment">//</span>
    <a class="code" href="group__PIN__CONTROL.html#g7de96e728655962e8ecb4cfe49bd6c2c">PIN_StartProgramProbed</a>();
    
    <span class="keywordflow">return</span> 0;
}

</pre></div><h3><a class="anchor" name="FollowChild">
Instrumenting Child Processes</a></h3>
The <a class="el" href="group__PIN__CONTROL.html#g7e45677714ab29a8d249f772de89f170">PIN_AddFollowChildProcessFunction()</a> allows you to define the function you will like to execute before an execv'd process starts. Use the -follow_execv option on the command line to instrument the child processes, like this:<p>
<div class="fragment"><pre class="fragment">$ pin -follow_execv -t obj-intel64/follow_child_tool.so -- obj-intel64/follow_child_app1 obj-intel64/follow_child_app2
</pre></div><p>
The example can be found in source/tools/ManualExamples/follow_child_tool.cpp. To build this test, execute: <div class="fragment"><pre class="fragment">$ make follow_child_tool.test
</pre></div><p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include "pin.H"</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;unistd.h&gt;</span>

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Command line Switches */</span>
<span class="comment">/* ===================================================================== */</span>


BOOL FollowChild(<a class="code" href="group__CHILD__PROCESS__API.html#g104e2b5e1bfd80e62cb3cd8f50ddfdf2">CHILD_PROCESS</a> childProcess, VOID * userData)
{
    fprintf(stdout, <span class="stringliteral">"before child:%u\n"</span>, getpid());
    <span class="keywordflow">return</span> TRUE;
}        

<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(INT32 argc, CHAR **argv)
{
    <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv);

    <a class="code" href="group__PIN__CONTROL.html#g7e45677714ab29a8d249f772de89f170">PIN_AddFollowChildProcessFunction</a>(FollowChild, 0);

    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();

    <span class="keywordflow">return</span> 0;
}

</pre></div><h3><a class="anchor" name="ForkOnLinux">
Instrumenting Before and After Forks</a></h3>
Pin allows Pintools to register for notification callbacks around forks. The <a class="el" href="group__PIN__CONTROL.html#gd7da7a3f8249e8708524ee4b35f6e9ce">PIN_AddForkFunction()</a> and <a class="el" href="group__PIN__CONTROL.html#g03f417057aac38bb39103bcaabef6f72">PIN_AddForkFunctionProbed()</a> callbacks allow you to define the function you want to execute at one of these FPOINTs: <div class="fragment"><pre class="fragment">    FPOINT_BEFORE            Call-back in parent, just before fork.  
    FPOINT_AFTER_IN_PARENT   Call-back in parent, immediately after fork.  
    FPOINT_AFTER_IN_CHILD    Call-back in child, immediately after fork.  
</pre></div><p>
Note that <a class="el" href="group__PIN__CONTROL.html#gd7da7a3f8249e8708524ee4b35f6e9ce">PIN_AddForkFunction()</a> is used for JIT mode and <a class="el" href="group__PIN__CONTROL.html#g03f417057aac38bb39103bcaabef6f72">PIN_AddForkFunctionProbed()</a> is used for Probed mode. If the fork() fails, the FPOINT_AFTER_IN_PARENT callback, if it is defined, will execute anyway.<p>
The example can be found in source/tools/ManualExamples/fork_jit_tool.cpp. To build this test, execute: <div class="fragment"><pre class="fragment">$ make fork_jit_tool.test
</pre></div><p>
<div class="fragment"><pre class="fragment">
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;sys/types.h&gt;</span>
<span class="preprocessor">#include &lt;unistd.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>

<span class="preprocessor">#include "pin.H"</span>

<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>

<span class="keyword">using namespace </span>std;


INT32 Usage()
{
    cerr &lt;&lt;
        <span class="stringliteral">"This pin tool registers callbacks around fork().\n"</span>
        <span class="stringliteral">"\n"</span>;
    cerr &lt;&lt; KNOB_BASE::StringKnobSummary();
    cerr &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}


pid_t parent_pid;
<a class="code" href="group__LOCK.html#gf6a5e5e7a828fea525903e0f2757bee6">PIN_LOCK</a> lock;

VOID BeforeFork(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid, <span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a>* ctxt, VOID * arg)
{
    <a class="code" href="group__LOCK.html#g36070bd375e4defc52ecfc38f9c46732">GetLock</a>(&amp;lock, threadid+1);
    cerr &lt;&lt; <span class="stringliteral">"TOOL: Before fork."</span> &lt;&lt; endl;
    <a class="code" href="group__LOCK.html#ge1f816bf92874cea96639dac6af37849">ReleaseLock</a>(&amp;lock);
    parent_pid = <a class="code" href="group__PIN__PROCESS__API.html#ga49549dfe3363154368aa80038463078">PIN_GetPid</a>();
}

VOID AfterForkInParent(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid, <span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a>* ctxt, VOID * arg)
{
    <a class="code" href="group__LOCK.html#g36070bd375e4defc52ecfc38f9c46732">GetLock</a>(&amp;lock, threadid+1);
    cerr &lt;&lt; <span class="stringliteral">"TOOL: After fork in parent."</span> &lt;&lt; endl;
    <a class="code" href="group__LOCK.html#ge1f816bf92874cea96639dac6af37849">ReleaseLock</a>(&amp;lock);

    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__PROCESS__API.html#ga49549dfe3363154368aa80038463078">PIN_GetPid</a>() != parent_pid)
    {
        cerr &lt;&lt; <span class="stringliteral">"PIN_GetPid() fails in parent process"</span> &lt;&lt; endl;
        exit(-1);
    }
}

VOID AfterForkInChild(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> threadid, <span class="keyword">const</span> <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a>* ctxt, VOID * arg)
{
    <a class="code" href="group__LOCK.html#g36070bd375e4defc52ecfc38f9c46732">GetLock</a>(&amp;lock, threadid+1);
    cerr &lt;&lt; <span class="stringliteral">"TOOL: After fork in child."</span> &lt;&lt; endl;
    <a class="code" href="group__LOCK.html#ge1f816bf92874cea96639dac6af37849">ReleaseLock</a>(&amp;lock);
    
    <span class="keywordflow">if</span> ((<a class="code" href="group__PIN__PROCESS__API.html#ga49549dfe3363154368aa80038463078">PIN_GetPid</a>() == parent_pid) || (getppid() != parent_pid))
    {
        cerr &lt;&lt; <span class="stringliteral">"PIN_GetPid() fails in child process"</span> &lt;&lt; endl;
        exit(-1);
    }
}

<span class="keywordtype">int</span> main(INT32 argc, CHAR **argv)
{
    <a class="code" href="group__PIN__CONTROL.html#ga6749650a8dce7151075fcc9345f7bd9">PIN_InitSymbols</a>();
    <span class="keywordflow">if</span>( <a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc,argv) )
    {
        <span class="keywordflow">return</span> Usage();
    }
    
    <span class="comment">// Initialize the pin lock</span>
    <a class="code" href="group__LOCK.html#g7b98e356ed047ffd72a7a8f7b63620af">InitLock</a>(&amp;lock);
    
    <span class="comment">// Register a notification handler that is called when the application</span>
    <span class="comment">// forks a new process.</span>
    <a class="code" href="group__PIN__CONTROL.html#gd7da7a3f8249e8708524ee4b35f6e9ce">PIN_AddForkFunction</a>(<a class="code" href="group__PIN__CONTROL.html#ggb6974c15e664605870435c05a1bf33bd1bf77c6f3a5ac150cf7fb1c10f0429cf">FPOINT_BEFORE</a>, BeforeFork, 0);  
    <a class="code" href="group__PIN__CONTROL.html#gd7da7a3f8249e8708524ee4b35f6e9ce">PIN_AddForkFunction</a>(<a class="code" href="group__PIN__CONTROL.html#ggb6974c15e664605870435c05a1bf33bdcba5c8d0ce036ae68ab51e180e5f7d35">FPOINT_AFTER_IN_PARENT</a>, AfterForkInParent, 0);
    <a class="code" href="group__PIN__CONTROL.html#gd7da7a3f8249e8708524ee4b35f6e9ce">PIN_AddForkFunction</a>(<a class="code" href="group__PIN__CONTROL.html#ggb6974c15e664605870435c05a1bf33bd35c7c8f0fae3a1a1cbe29d6d79045c88">FPOINT_AFTER_IN_CHILD</a>, AfterForkInChild, 0);
    
    <span class="comment">// Never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><p>
======================================================================================== <h2><a class="anchor" name="CALLBACK">
Callbacks</a></h2>
========================================================================================<p>
The examples in the previous section have introduced a number of ways to register callback functions via the Pin API, such as:<p>
<ul>
<li><a class="el" href="group__INS__INST__API.html#ga80cd9a7905b82a86b9e31d9bf589dbe">INS_AddInstrumentFunction</a> (INSCALLBACK fun, VOID *val)</li><li><a class="el" href="group__TRACE__BASIC__API.html#gb3762f773502ad865216ef941c38799e">TRACE_AddInstrumentFunction</a> (TRACECALLBACK fun, VOID *val)</li><li><a class="el" href="group__RTN__BASIC__API.html#g8622a6ba858eb8d55df4e006eb165e57">RTN_AddInstrumentFunction</a> (RTNCALLBACK fun, VOID *val)</li><li><a class="el" href="group__IMG__BASIC__API.html#gb0ad0d50126fd5ddcfee28005c681049">IMG_AddInstrumentFunction</a> (IMGCALLBACK fun, VOID *val)</li><li><a class="el" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a> (FINICALLBACK fun, VOID *val)</li><li><a class="el" href="group__PIN__CONTROL.html#g451060f5e998243df750ac16720cadcf">PIN_AddDetachFunction</a> (DETACHCALLBACK fun, VOID *val)</li></ul>
<p>
The extra parameter <code>val</code> (shared by all the registration functions) will be passed to <code>fun</code> as its second argument whenever it is "called back". This is a standard mechanism used in GUI programming with callbacks.<p>
If this feature is not needed, it is safe to pass 0 for <code>val</code> when registering a callback. The expected use of <code>val</code> is to pass a pointer to an instance of a class. Since <code>val</code> is a generic pointer, <code>fun</code> must cast it back to an object before dereferencing the pointer.<p>
======================================================================================== <h2><a class="anchor" name="MODIFYING">
Modifying Application Instructions</a></h2>
========================================================================================<p>
Although Pin is most commonly used for instrumenting applications, it is also possible to change the application's instructions. The simplest way to do this is to insert an analysis routine to emulate an instruction, and then use <a class="el" href="group__INS__MOD__API__GEN__IA32.html#g408da5197af3462940d9d0de25bb886a">INS_Delete()</a> to remove the original instruction. It is also possible to insert direct or indirect branches (using <a class="el" href="group__INS__MOD__API__GEN__IA32.html#g85b5d845590e666a8424e3793a2cdf33">INS_InsertDirectJump</a> and <a class="el" href="group__INS__MOD__API__GEN__IA32.html#g001c169ec3e061fc6436b63af220d81d">INS_InsertIndirectJump</a>), which makes it easier to emulate instructions that change the control flow.<p>
The memory addresses accessed by an instruction can be modified to refer to a value calculated by an analysis routine using <a class="el" href="group__INS__MOD__API__GEN__IA32.html#g9309f9f665d0d01b9c880eeaf2955d33">INS_RewriteMemoryOperand</a>.<p>
Note that in all of the cases where an instruction is modified, the modification is only made after all of the instrumentation routines have been executed. Therefore all of the instrumentation routines see the original, un-modified instruction.<p>
======================================================================================== <h2><a class="anchor" name="APPDEBUG">
Debugging the Application while Running Under Pin</a></h2>
========================================================================================<p>
It is possible to use GDB on Linux to debug the application while it is running under Pin. This is useful in a couple different scenarios:<p>
<ul>
<li>Some Pintools are emulators which provide functionality that does not exist on real hardware or on the real O/S. For example, a Pintool might emulate new instructions that do not yet exist on the CPU. A user of an emulation tool like this can use Pin's debugger feature to debug the application while it is being emulated by the tool.</li></ul>
<p>
<ul>
<li>Some Pintools are designed look for "interesting" situations. For example, an address tracing tool might look for writes to a particular address. Tools like this can stop at a breakpoint in a live debugger session at the interesting point. You can then use the debugger to observe the state of the application.</li></ul>
<p>
Note that the application debugging feature is totally different from debugging the Pintool. For instructions on how to debug your Pintool, see <a class="el" href="index.html#DEBUGGING">Tips for Debugging a Pintool</a>.<p>
Throughout this section, we demonstrate the application debugging features in Pin with the example tool "stack-debugger.cpp", which is available in the directory "source/tools/ManualExamples". You may want to compile that tool and follow along:<p>
<div class="fragment"><pre class="fragment">$ cd source/tools/ManualExamples
$ make stack-debugger.test
</pre></div><p>
The tool and its associated test application, "fibonacci", are built in a directory named "obj-ia32", "obj-intel64", etc., depending on your machine type.<p>
To enable the application debugging feature, run Pin with the <a class="el" href="group__KNOBS.html#SWITCH_APPDEBUG">-appdebug</a> command line switch. This causes Pin to start the application and stop immediately before the first instruction. Pin then prints a message telling you to start GDB.<p>
<div class="fragment"><pre class="fragment">$ pin -appdebug -t stack-debugger.so -- fibonacci 1000
Application stopped until continued from debugger.
Start GDB, then issue this command at the (gdb) prompt:
  target remote :33030
</pre></div><p>
In another window, start GDB and enter the command that Pin printed:<p>
<div class="fragment"><pre class="fragment">$ gdb fibonacci
(gdb) target remote :33030
</pre></div><p>
At this point, the debugger is attached to the application that is running under Pin. You can set breakpoints, continue execution, print out variables, disassemble code, etc.<p>
<div class="fragment"><pre class="fragment">(gdb) break main
Breakpoint 1 at 0x401194: file fibonacci.cpp, line 11.
(gdb) cont
Continuing.
 
Breakpoint 1, main (argc=2, argv=0x7fbffff3c8) at fibonacci.cpp:11
11          if (argc != 2)
(gdb) print argc
$1 = 2
(gdb) x/4i $pc
0x401194 &lt;main+27&gt;:     cmpl   $0x2,0xfffffffffffffe5c(%rbp)
0x40119b &lt;main+34&gt;:     je     0x4011c8 &lt;main+79&gt;
0x40119d &lt;main+36&gt;:     mov    $0x402080,%esi
0x4011a2 &lt;main+41&gt;:     mov    $0x603300,%edi
</pre></div><p>
Of course, any information you observe in the debugger shows the application's "pure" state. The details of Pin and the tool's instrumentation are hidden. For example, the disassembly you see above shows only the application's instructions, not any of the instructions inserted by the tool. However, when you use commands like "cont" or "step" to advance execution of the application, your tool's instrumentation runs as it normally would under Pin.<p>
<dl compact><dt><b>Note:</b></dt><dd>After connecting GDB with the "target remote" command, you should NOT use the "run" command. The application is already running and stopped at the first instruction. Instead, use the "cont" command to continue execution.</dd></dl>
<h3><a class="anchor" name="APPDEBUG_EXTEND">
Extending the Debugger</a></h3>
Simply debugging the application as it runs under Pin has its uses, but Pin's debugger integration allows more powerful features too. For example, you can write a Pintool that adds new commands to GDB, as the stack-debugger tool demonstrates. Notice the call to <a class="el" href="group__APPDEBUG__API.html#gea5826d7103d2f8cfd14320d388dbad9">PIN_AddDebugInterpreter()</a> and this call-back function:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> BOOL DebugInterpreter(<a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a>, <a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, <span class="keyword">const</span> string &amp;cmd, string *result, VOID *)
{
    TINFO *tinfo = reinterpret_cast&lt;TINFO *&gt;(<a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>(ctxt, RegTinfo));
    std::string line = TrimWhitespace(cmd);
    *result = <span class="stringliteral">""</span>;

    <span class="comment">// [...]</span>

    <span class="keywordflow">if</span> (line == <span class="stringliteral">"stats"</span>)
    {
        size_t size = tinfo-&gt;_stackBase - <a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>(ctxt, REG_STACK_PTR);
        tinfo-&gt;_os.str(<span class="stringliteral">""</span>);
        tinfo-&gt;_os &lt;&lt; <span class="stringliteral">"Current stack usage: "</span> &lt;&lt; std::dec &lt;&lt; size &lt;&lt; <span class="stringliteral">" bytes.\n"</span>;
        tinfo-&gt;_os &lt;&lt; <span class="stringliteral">"Maximum stack usage: "</span> &lt;&lt; tinfo-&gt;_max &lt;&lt; <span class="stringliteral">" bytes.\n"</span>;
        *result = tinfo-&gt;_os.str();
        <span class="keywordflow">return</span> TRUE;
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (line == <span class="stringliteral">"stacktrace on"</span>)
    {
        <span class="keywordflow">if</span> (!EnableInstrumentation)
        {
            <a class="code" href="group__PIN__CONTROL.html#gaee2fe5932a3cc759d9968820be6e15d">PIN_RemoveInstrumentation</a>();
            EnableInstrumentation = <span class="keyword">true</span>;
            *result = <span class="stringliteral">"Stack tracing enabled.\n"</span>;
        }
        <span class="keywordflow">return</span> TRUE;
    }

    <span class="comment">// [...]</span>

    <span class="keywordflow">return</span> FALSE;  <span class="comment">// Unknown command</span>

}
</pre></div><p>
The <a class="el" href="group__APPDEBUG__API.html#gea5826d7103d2f8cfd14320d388dbad9">PIN_AddDebugInterpreter()</a> API allows a Pintool to establish a handler for extended GDB commands. For example, the code snippet above implements the new commands "stats" and "stacktrace on". You can execute these commands in GDB by using the "monitor" command:<p>
<div class="fragment"><pre class="fragment">(gdb) monitor stats
Current stack usage: 688 bytes.
Maximum stack usage: 0 bytes.
</pre></div><p>
A Pintool can do various things when the user enters an extended debugger command. For example, the "stats" command prints out some information that the tool has collected. Any text that the tool writes to the "result" parameter is printed to the GDB console. Note that the CONTEXT parameter has the register state for the debugger's "focus" thread, so the tool can easily display information about this focus thread.<p>
An extended debugger command can also cause the Pintool to adjust its instrumentation, as demonstrated by the "stacktrace on" command. The call to <a class="el" href="group__PIN__CONTROL.html#gaee2fe5932a3cc759d9968820be6e15d">PIN_RemoveInstrumentation()</a> causes Pin to discard any previous instrumentation, so the tool re-instruments the code when the debugger continues execution of the application. As we will see later, the tool's global variable "EnableInstrumentation" adjusts the instrumentation that it inserts.<h3><a class="anchor" name="DEBUGAPP_BREAK">
Semantic Breakpoints</a></h3>
Another powerful debugger features that Pin provides is the ability to stop at a breakpoint. When a Pintool's analysis function calls <a class="el" href="group__APPDEBUG__API.html#g0cc79428309a39c0cbae4e6131b51f3a">PIN_ApplicationBreakpoint()</a>, Pin stops all threads in the debugger as though a breakpoint was triggered. This allows a Pintool to use instrumentation to check for very complicated breakpoint conditions.<p>
For example, the "stack-debugger" tool instruments all the instructions that change the stack pointer and triggers a breakpoint when a thread's stack usage reaches some threshold. The instrumentation code to do this is fairly simple:<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> VOID Instruction(INS ins, VOID *)
{
    <span class="keywordflow">if</span> (!EnableInstrumentation)
        <span class="keywordflow">return</span>;

    <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g58cec08c8d1797904fa60e938eee1e32">INS_RegWContain</a>(ins, REG_STACK_PTR))
    {
        <a class="code" href="group__INST__ARGS.html#ga46cc1807fc61addd9afe69ee6736a21">IPOINT</a> where = <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a214b3338de54a3d5823a5b612fd4d2d846">IPOINT_AFTER</a>;
        <span class="keywordflow">if</span> (!<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g85371f49008f053ffa09ac242ae1c9e3">INS_HasFallThrough</a>(ins))
            where = <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21e3df50f902d3b951e0a8ab8afbcf2902">IPOINT_TAKEN_BRANCH</a>;

        <a class="code" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall</a>(ins, where, (AFUNPTR)OnStackChangeIf, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818b1a445366074f7277035293fcc20c98">IARG_REG_VALUE</a>, REG_STACK_PTR,
            <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818b1a445366074f7277035293fcc20c98">IARG_REG_VALUE</a>, RegTinfo, IARG_END);
        <a class="code" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall</a>(ins, where, (AFUNPTR)DoBreakpoint, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56819673f5f1a6c7d03d31a2eab0af88628e">IARG_CONTEXT</a>, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681d04f1eb185e914f0f11a839e2c26cbd8">IARG_THREAD_ID</a>, IARG_END);
    }
}
</pre></div><p>
The call to <a class="el" href="group__INS__BASIC__API__GEN__IA32.html#g58cec08c8d1797904fa60e938eee1e32">INS_RegWContain()</a> tests whether an instruction modifies the stack pointer. If it does, we insert an analysis call immediately after the instruction, which tests for the threshold.<p>
Notice that all the instrumentation is gated by the global flag "EnableInstrumentation", which we saw earlier in the "stacktrace on" command. Thus, the user can disable instrumentation (with "stacktrace off") in order to execute quickly through uninteresting parts of the application, and then re-enable it (with "stacktrace on") for the interesting parts.<p>
The Pintool's analysis code checks to see if the stack pointer has crossed a threshold. If so, it calls <a class="el" href="group__APPDEBUG__API.html#g0cc79428309a39c0cbae4e6131b51f3a">PIN_ApplicationBreakpoint()</a> to stop at a breakpoint. We split the analysis code into two parts, using if / then instrumentation because <a class="el" href="group__APPDEBUG__API.html#g0cc79428309a39c0cbae4e6131b51f3a">PIN_ApplicationBreakpoint()</a> requires an IARG_CONTEXT parameter, which can be slow.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> ADDRINT OnStackChangeIf(ADDRINT sp, ADDRINT addrInfo)
{
    TINFO *tinfo = reinterpret_cast&lt;TINFO *&gt;(addrInfo);

    <span class="comment">// The stack pointer may go above the base slightly.  (For example, the application's dynamic</span>
    <span class="comment">// loader does this briefly during start-up.)</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (sp &gt; tinfo-&gt;_stackBase)
        <span class="keywordflow">return</span> 0;

    <span class="comment">// Keep track of the maximum stack usage.</span>
    <span class="comment">//</span>
    size_t size = tinfo-&gt;_stackBase - sp;
    <span class="keywordflow">if</span> (size &gt; tinfo-&gt;_max)
        tinfo-&gt;_max = size;

    <span class="comment">// See if we need to trigger a breakpoint.</span>
    <span class="comment">//</span>
    <span class="keywordflow">if</span> (BreakOnNewMax &amp;&amp; size &gt; tinfo-&gt;_maxReported)
        <span class="keywordflow">return</span> 1;
    <span class="keywordflow">if</span> (BreakOnSize &amp;&amp; size &gt;= BreakOnSize)
        <span class="keywordflow">return</span> 1;
    <span class="keywordflow">return</span> 0;
}

<span class="keyword">static</span> VOID DoBreakpoint(<a class="code" href="group__CONTEXT__API.html#g70a3022fd8834c783509c028ffcd07cb">CONTEXT</a> *ctxt, <a class="code" href="group__PIN__THREAD__API.html#g3bc3c874675eba0be607f41464eeb31c">THREADID</a> tid)
{
    TINFO *tinfo = reinterpret_cast&lt;TINFO *&gt;(<a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>(ctxt, RegTinfo));

    <span class="comment">// Keep track of the maximum reported stack usage for "stackbreak newmax".</span>
    <span class="comment">//</span>
    size_t size = tinfo-&gt;_stackBase - <a class="code" href="group__CONTEXT__API.html#gdc986c9a416cd32de1f18e0ffbf5b898">PIN_GetContextReg</a>(ctxt, REG_STACK_PTR);
    <span class="keywordflow">if</span> (size &gt; tinfo-&gt;_maxReported)
        tinfo-&gt;_maxReported = size;

    ConnectDebugger();  <span class="comment">// Ask the user to connect a debugger, if it is not already connected.</span>

    <span class="comment">// Construct a string that the debugger will print when it stops.  If a debugger is</span>
    <span class="comment">// not connected, no breakpoint is triggered and execution resumes immediately.</span>
    <span class="comment">//</span>
    tinfo-&gt;_os.str(<span class="stringliteral">""</span>);
    tinfo-&gt;_os &lt;&lt; <span class="stringliteral">"Thread "</span> &lt;&lt; std::dec &lt;&lt; tid &lt;&lt; <span class="stringliteral">" uses "</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">" bytes of stack."</span>;
    <a class="code" href="group__APPDEBUG__API.html#g0cc79428309a39c0cbae4e6131b51f3a">PIN_ApplicationBreakpoint</a>(ctxt, tid, FALSE, tinfo-&gt;_os.str());
}
</pre></div><p>
The analysis routine OnStackChangeIf() keeps track of some metrics on stack usage and tests whether the threshold has been reached. If the threshold is crossed, it returns non-zero, and Pin executes the DoBreakpoint() analysis routine. That analysis routine calls <a class="el" href="group__APPDEBUG__API.html#g0cc79428309a39c0cbae4e6131b51f3a">PIN_ApplicationBreakpoint()</a>, which cause the application to stop at a breakpoint. Notice that there is a string parameter to <a class="el" href="group__APPDEBUG__API.html#g0cc79428309a39c0cbae4e6131b51f3a">PIN_ApplicationBreakpoint()</a>. GDB prints this string to its console when the breakpoint triggers, so it's a good way to tell the user what caused the breakpoint. We can see the breakpoint feature in action by using the "stackbreak 4000" command like this:<p>
<div class="fragment"><pre class="fragment">(gdb) monitor stacktrace on
Stack tracing enabled.
(gdb) monitor stackbreak 4000
Will break when thread uses more than 4000 bytes of stack.
(gdb) c
Continuing.
Thread 0 uses 4000 bytes of stack.
Program received signal SIGTRAP, Trace/breakpoint trap.
0x0000000000400e27 in Fibonacci (num=0) at fibonacci.cpp:34
(gdb)
</pre></div><p>
When you are done, you can either continue the application and let it terminate, or you can quit from the debugger:<p>
<div class="fragment"><pre class="fragment">(gdb) quit
The program is running.  Exit anyway? (y or n) y
</pre></div><h3><a class="anchor" name="DEBUGAPP_LATER">
Connecting the Debugger Later</a></h3>
In the previous example, we used the Pin switch <a class="el" href="group__KNOBS.html#SWITCH_APPDEBUG">-appdebug</a> to stop the application and debug it from the first instruction. You can also enable the Pin application debugger support without stopping at the first instruction. The following example shows how you can use the stack-debugger tool to start the application and attach with the debugger only after it triggers a stack limit breakpoint.<p>
<div class="fragment"><pre class="fragment">$ pin -appdebug_enable -appdebug_silent -t stack-debugger.so -stackbreak 4000 -- fibonacci 1000
</pre></div><p>
The <a class="el" href="group__KNOBS.html#SWITCH_APPDEBUG_ENABLE">-appdebug_enable</a> switch tells Pin to enable application debugging without stopping at the first instruction. The <a class="el" href="group__KNOBS.html#SWITCH_APPDEBUG_SILENT">-appdebug_silent</a> switch disables the message that tells how to connect with GDB. As we will see later, the Pintool can print a custom message instead. Finally, the "-stackbreak 4000" switch tells the stack-debugger tool to trigger a breakpoint when the stack grows to 4000 bytes. When the tool does trigger a breakpoint, it prints a message like this:<p>
<div class="fragment"><pre class="fragment">Triggered stack-limit breakpoint.
Start GDB and enter this command:
  target remote :45462
</pre></div><p>
You can now connect with GDB as you did before, except now GDB stops the application at the point where the stack-debugger tool triggered the stack-limit breakpoint.<p>
<div class="fragment"><pre class="fragment">gdb fibonacci
(gdb) target remote :45462
0x0000000000400e27 in Fibonacci (num=0) at fibonacci.cpp:34
(gdb)
</pre></div><p>
Let's look at the code in the tool that connects to the debugger now.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">void</span> ConnectDebugger()
{
    <span class="keywordflow">if</span> (<a class="code" href="group__APPDEBUG__API.html#gf5d23fef76d1846b74cc1c4b61813e93">PIN_GetDebugStatus</a>() == <a class="code" href="group__APPDEBUG__API.html#gg2873b12faab265843028e2f388009e9872687f0941714f6c2148741707066ca1">DEBUG_STATUS_CONNECTED</a>)
        <span class="keywordflow">return</span>;

    <a class="code" href="structDEBUG__CONNECTION__INFO.html">DEBUG_CONNECTION_INFO</a> info;
    <span class="keywordflow">if</span> (!<a class="code" href="group__APPDEBUG__API.html#g88a899a52d6a26fb8d43f239fe0b7518">PIN_GetDebugConnectionInfo</a>(&amp;info) || info.<a class="code" href="structDEBUG__CONNECTION__INFO.html#208cf456b6613ddc3c964386f8bbbbff">_type</a> != <a class="code" href="group__APPDEBUG__API.html#gg0ed05063ceaa339416ac7156e97de9db08b522b6be460c66d44a60258dbbdcd5">DEBUG_CONNECTION_TYPE_TCP_SERVER</a>)
        <span class="keywordflow">return</span>;

    *Output &lt;&lt; <span class="stringliteral">"Triggered stack-limit breakpoint.\n"</span>;
    *Output &lt;&lt; <span class="stringliteral">"Start GDB and enter this command:\n"</span>;
    *Output &lt;&lt; <span class="stringliteral">"  target remote :"</span> &lt;&lt; std::dec &lt;&lt; info.<a class="code" href="structDEBUG__CONNECTION__INFO.html#73d65291e3ebef305deeffe69b4fdf60">_tcpServer</a>._tcpPort &lt;&lt; <span class="stringliteral">"\n"</span>;
    *Output &lt;&lt; std::flush;

    <span class="keywordflow">if</span> (<a class="code" href="group__APPDEBUG__API.html#g10470a2efb23fe149125a72fcf6ac337">PIN_WaitForDebuggerToConnect</a>(1000*KnobTimeout.Value()))
        <span class="keywordflow">return</span>;

    *Output &lt;&lt; <span class="stringliteral">"No debugger attached after "</span> &lt;&lt; KnobTimeout.Value() &lt;&lt; <span class="stringliteral">" seconds.\n"</span>;
    *Output &lt;&lt; <span class="stringliteral">"Resuming application without stopping.\n"</span>;
    *Output &lt;&lt; std::flush;
}
</pre></div><p>
The ConnectDebugger() function is called each time the tool wants to stop at a breakpoint. It first calls <a class="el" href="group__APPDEBUG__API.html#gf5d23fef76d1846b74cc1c4b61813e93">PIN_GetDebugStatus()</a> to see if Pin is already connected to a debugger. If not, it uses <a class="el" href="group__APPDEBUG__API.html#g88a899a52d6a26fb8d43f239fe0b7518">PIN_GetDebugConnectionInfo()</a> to get the TCP port number that is needed to connect GDB to Pin. This is, for example, the "45462" number that the user types in the "target remote" command. After asking the user to start GDB, the tool then calls <a class="el" href="group__APPDEBUG__API.html#g10470a2efb23fe149125a72fcf6ac337">PIN_WaitForDebuggerToConnect()</a> to wait for GDB to connect. If the user doesn't start GDB after a timeout period, the tool prints a message and then continues executing the application.<p>
As before, you can either continue the application and let it terminate, or you can quit from the debugger:<p>
<div class="fragment"><pre class="fragment">(gdb) quit
The program is running.  Exit anyway? (y or n) y
</pre></div><p>
======================================================================================== <h2><a class="anchor" name="EX">
Applying a Pintool to an Application</a></h2>
========================================================================================<p>
An application and a tool are invoked as follows:<p>
<div class="fragment"><pre class="fragment">pin [pin-option]... -t [toolname] [tool-options]... -- [application] [application-option]..
</pre></div><p>
These are a few of the Pin options are currently available. See <a class="el" href="group__KNOBS.html">Command Line Switches</a> for the complete list. <ul>
<li>
-t <em>toolname</em>: specifies the Pintool to use. If you are running a 32-bit application in an IA-32 architecture, or a 64-bit application on an IA-64 architecture, only -t &lt;toolname&gt; is needed. If you are running an application on an Intel(R) 64 architecture, where all of the components in the chain are either 32-bit or 64-bit, but not both, only -t &lt;toolname&gt; is needed. See <a class="el" href="index.html#MIXED-MODE">Instrumenting Applications on Intel(R) 64 Architectures</a> </li>
<li>
-t64 <em>toolname</em>: Specify tool binary for Intel(R) 64 architecture. See <a class="el" href="index.html#MIXED-MODE">Instrumenting Applications on Intel(R) 64 Architectures</a> </li>
<li>
-p32 <em>toolname</em>: Specify Pin binary for IA-32 architecture. See <a class="el" href="index.html#MIXED-MODE">Instrumenting Applications on Intel(R) 64 Architectures</a> </li>
<li>
-p64 <em>toolname</em>: Specify Pin binary for Intel(R) 64 architecture. See <a class="el" href="index.html#MIXED-MODE">Instrumenting Applications on Intel(R) 64 Architectures</a> </li>
<li>
-pause_tool n: is a useful Pin-option which prints out the process id and pauses Pin for n seconds to permit attaching with gdb. See <a class="el" href="index.html#DEBUGGING">Tips for Debugging a Pintool</a>. </li>
<li>
-follow_execv: Execute with Pin all processes spawned by execv class system calls. </li>
<li>
-injection <em>mode</em>: Where <em>mode</em> is one of dynamic, self, child, parent. <em>UNIX-only</em> See <a class="el" href="index.html#INJECTION">Injection</a>.<p>
</li>
</ul>
<p>
The tool-options follow immediately after the tool specification and depend on the tool used.<p>
Everything following the <code>--</code> is the command line for the application.<p>
For example, to apply the itrace example (<a class="el" href="index.html#IAddressTrace">Instruction Address Trace (Instruction Instrumentation)</a>) to a run of the "ls" program:<p>
<div class="fragment"><pre class="fragment">pin -t itrace.so -- /bin/ls
</pre></div><p>
To get a listing of the available command line options for Pin:<p>
<div class="fragment"><pre class="fragment">pin -help
</pre></div><p>
To get a listing of the available command line options for the itrace example:<p>
<div class="fragment"><pre class="fragment">pin -t itrace.so -help -- /bin/ls
</pre></div><p>
Note that in the last case <code>/bin/ls</code> is necessary on the command line but will not be executed.<h3><a class="anchor" name="MIXED-MODE">
Instrumenting Applications on Intel(R) 64 Architectures</a></h3>
The Pin kit for IA-32 and Intel(R) 64 architectures is a combined kit. Both a 32-bit version and a 64-bit version of Pin are present in the kit. This allows Pin to instrument complex applications on Intel(R) 64 architectures which may have 32-bit and 64-bit components.<p>
An application and a tool are invoked in "mixed-mode" as follows:<p>
<div class="fragment"><pre class="fragment">pin [pin-option]... -t64 &lt;64-bit toolname&gt; -t &lt;32-bit toolname&gt; [tool-options]...
-- &lt;application&gt; [application-option]..
</pre></div><p>
See source/tools/CrossIa32Intel64/makefile for further information.<p>
The file "pin" is a script that expects the Pin binary "pinbin" to be in the architecture-specific "bin" subdirectory (i.e. intel64/bin). The "pin" script distinguishes the 32-bit version of the Pin binary from the 64-bit version of the Pin binary by using the -p32/-p64 switches, respectively. Today, the 32-bit version of the Pin binary is invoked, and the path of the 64-bit version of Pin is passed as an argument using the -p64 switch. However, one could change this to invoke the 64-bit version of the Pin binary, and pass the 32-bit version of the Pin binary as an argument using the -p32 switch.<p>
See <a class="el" href="index.html#LIBRARIES">Libraries for Linux</a> for more information about the environment variables that are set up in the "pin" script.<h3><a class="anchor" name="INJECTION">
Injection</a></h3>
The -injection switch is UNIX-only and controls the way pin is injected into the application process. The default, dynamic, is recommended for all users. It uses parent injection unless it is unsupported (Linux 2.4 kernels). Child injection creates the application process as a child of the pin process so you will see both a pin process and the application process running. In parent injection, the pin process exits after injecting the application and is less likely to cause a problem. Using parent injection on an unsupported platform may lead to nondeterministic errors.<p>
IMPORTANT: The description about invoking assumes that the application is a program binary (and not a shell script). If your application is invoked indirectly (from a shell script or using 'exec') then you need to change the actual invocation of the program binary by prefixing it with pin/pintool options. Here's one way of doing that:<p>
<div class="fragment"><pre class="fragment"> # Track down the actual application binary, say it is 'application_binary'.
 % mv application_binary application_binary.real

 # Write a shell script named 'application_binary' with the following contents.
 # (change 'itrace' to your desired tool)

 #!/bin/sh
 pin -t itrace.so -- application_binary.real $*
</pre></div><p>
After you do this, whenever 'application_binary' is invoked indirectly (from some shell script or using 'exec'), the real binary will get invoked with the right pin/pintool options.<p>
======================================================================================== <h2><a class="anchor" name="DEBUGGING">
Tips for Debugging a Pintool</a></h2>
========================================================================================<h3><a class="anchor" name="XXX">
Using gdb on Linux</a></h3>
When running an application under the control of Pin and a Pintool there are two different programs residing in the address space. The application, and the Pin instrumentation engine together with your Pintool. The pintool is normally a shared object loaded by Pin. This section describes how to use gdb to find bugs in a Pintool. You cannot run Pin directly from gdb since Pin uses the debugging API to start the application. Instead, you must invoke Pin from the command line with the -pause_tool switch, and use gdb to attach to the Pin process from another window. The -pause_tool n switch makes Pin print out the process identifier (pid) and pause for n seconds.<p>
Pin searches for the tool in an internal search algorithm. Therefore in many cases gdb is unable to load the debug info for the tool. There are several options to help gdb find the debug info.<p>
Option 1 is to use full path to the tool when running pin.<p>
Option 2 is to tell gdb to load the debugging information of the tool. Pin prompts with the exact gdb command to be used in this case.<p>
To check that gdb loaded the debugging info to the tool use the command "info sharedlibrary" and you should see that gdb has read the symbols for your tool (as in the example below).<p>
<div class="fragment"><pre class="fragment">(gdb) info sharedlibrary
From        To          Syms Read   Shared Object Library
0x001b3ea0  0x001b4d80  Yes         /lib/libdl.so.2
0x003b3820  0x00431d74  Yes         /usr/intel/pkgs/gcc/4.2.0/lib/libstdc++.so.6
0x0084f4f0  0x00866f8c  Yes         /lib/i686/libm.so.6
0x00df8760  0x00dffcc4  Yes         /usr/intel/pkgs/gcc/4.2.0/lib/libgcc_s.so.1
0x00e5fa00  0x00f60398  Yes         /lib/i686/libc.so.6
0x40001c50  0x4001367f  Yes         /lib/ld-linux.so.2
0x008977f0  0x00af7784  Yes         ./dcache.so
</pre></div><p>
For example, if your tool is called opcodemix and the application is /bin/ls, you can use gdb as described below. The following example is for the Intel(R) 64 Linux platform. Substitute "ia32" or "ia64" for the IA-32 architecture or IA-64 architecture.<p>
Change directory to the directory where your tool resides, and start gdb with pin, but do not use the run command.<p>
<div class="fragment"><pre class="fragment">$ /usr/bin/gdb ../../../intel64/bin/pinbin
GNU gdb Red Hat Linux (6.3.0.0-1.132.EL4rh)
Copyright 2004 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "x86_64-redhat-linux-gnu"...Using host libthread_db library "/lib64/tls/libthread_db.so.1"
(gdb)
</pre></div><p>
In another window, start your application with the -pause_tool switch.<p>
<div class="fragment"><pre class="fragment">$ ../../../intel64/bin/pinbin -pause_tool 10 -t obj-intel64/opcodemix.so -- /bin/ls
Pausing to attach to pid 28769
To load the tool's debug info to gdb use:
   add-symbol-file .../source/tools/SimpleExamples/obj-intel64/opcodemix.so 0x2a959e9830
</pre></div><p>
Then go back to gdb and attach to the process.<p>
<div class="fragment"><pre class="fragment">(gdb) attach 28769
Attaching to program: .../intel64/bin/pinbin, process 28769
0x000000314b38f7a2 in ?? ()
(gdb)
</pre></div><p>
Now, you should tell gdb to load the Pintool debugging information, by copying the debugging message we got when invoking pin with the -pause_tool switch..<p>
<div class="fragment"><pre class="fragment">(gdb) add-symbol-file .../source/tools/SimpleExamples/obj-intel64/opcodemix.so 0x2a959e9830
add symbol table from file ".../source/tools/SimpleExamples/obj-intel64/opcodemix.so" at
        .text_addr = 0x2a959e9830
        (y or n) y
        Reading symbols from .../source/tools/SimpleExamples/obj-intel64/opcodemix.so...done.
(gdb)
</pre></div><p>
Now, instead of using the gdb run command, you use the <code>cont</code> command to continue execution. You can also set breakpoints as normal.<p>
<div class="fragment"><pre class="fragment">(gdb) b opcodemix.cpp:447
Breakpoint 1 at 0x2a959ecf60: file opcodemix.cpp, line 447.
(gdb) cont
Continuing.

Breakpoint 1, main (argc=7, argv=0x3ff00f12f8) at opcodemix.cpp:447
447     int main(int argc, CHAR *argv[])
(gdb) 
</pre></div><p>
If the program does not exit, then you should detach so gdb will release control.<p>
<div class="fragment"><pre class="fragment">(gdb) detach
Detaching from program: .../intel64/bin/pinbin, process 28769
(gdb) 
</pre></div><p>
If you recompile your program and then use the run command, gdb will notice that the binary has been changed and reread the debug information from the file. This does not always happen automatically when using attach. In this case you must use the "add-symbol-file" command again to make gdb reread the debug information.<h3><a class="anchor" name="DBG">
Using the Visual Studio Debugger on Windows</a></h3>
When running an application under the control of Pin and a Pintool there are two different programs residing in the address space. The application, and the Pin instrumentation engine together with your Pintool. The pintool is a dynamically loaded library (.dll) loaded by Pin. This section describes how to use the Visual Studio Debugger to find bugs in a Pintool. You cannot run Pin directly from the debugger since Pin uses the debugging API to start the application. Instead, you must invoke Pin from the command line with the -pause_tool switch, and use Visual Studio to attach to the Pin process from another window. The -pause_tool n switch makes Pin print out the process identifier (pid) and pause for n seconds. You have n seconds (20 in our example) to attach the application with the debugger.<p>
<div class="fragment"><pre class="fragment"> % pin &lt;pin options&gt; -pause_tool 20 -t &lt;tool name&gt;  &lt;tool options&gt; -- &lt;app name&gt; &lt;app options&gt;
pin suspended process [id=&lt;pid&gt;] waiting for debugger attach. Press &lt;Enter&gt; when ready to continue...
</pre></div><p>
In the Visual Studio window, attach to the application process using the "Debug"-&gt;"Attach to Process" menu selection. You can set breakpoints in your tool in the usual way.<p>
Note, it is necessary to build your pin tool with debug symbols if you want symbolic information.<p>
======================================================================================== <h2><a class="anchor" name="LOGGING">
Logging Messages from a Pintool</a></h2>
========================================================================================<p>
Pin provides a mechanism to write messages from a Pintool to a logfile. To use this capability, call the LOG() API with your message. The default filename is pintool.log, and it is created in the currently working directory. Use the -logfile switch after the tool name to change the path and file name of the log file.<p>
<div class="fragment"><pre class="fragment">LOG( <span class="stringliteral">"Replacing function in "</span> + <a class="code" href="group__IMG__BASIC__API.html#g9f68164bfac7c031b82549eba91681c3">IMG_Name</a>(img) + <span class="stringliteral">"\n"</span> );
LOG( <span class="stringliteral">"Address = "</span> + <a class="code" href="group__MISC__PRINT.html#g87f513d501545295d33610f0d81dac5f">hexstr</a>( <a class="code" href="group__RTN__BASIC__API.html#gb74b01b5b6feb47a1f52d9f8ea7ea154">RTN_Address</a>(rtn)) + <span class="stringliteral">"\n"</span> );
LOG( <span class="stringliteral">"Image ID = "</span> + <a class="code" href="group__MISC__PRINT.html#gc6fa0ac95dc5a5baf1093baa1efc6b6c">decstr</a>( <a class="code" href="group__IMG__BASIC__API.html#g9440e63ee69888e8889a90912f605316">IMG_Id</a>(img) ) + <span class="stringliteral">"\n"</span> );
</pre></div><p>
======================================================================================== <h2><a class="anchor" name="PERFORMANCE">
Performance Considerations When Writing  a Pintool</a></h2>
========================================================================================<p>
The way a Pintool is written can have great impact on the performace of the tool, i.e. how much it slows down the applications it is instrumenting. This section demonstrates some techniques that can be used to improve tool performance. Let's start with an example. The following piece of code is derived from the source/tools/SimpleExamples/edgcnt.cpp:<p>
The instrumentation component of the tool is show below<p>
<div class="fragment"><pre class="fragment">VOID Instruction(INS ins, <span class="keywordtype">void</span> *v)
{
      ...

      <span class="keywordflow">if</span> ( [ins is a branch or a call instruction] ) 
      {
          
        
        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR) docount2,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883669f246ea24704e3a30a8ec25354b">IARG_BRANCH_TARGET_ADDR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b568177719c0c3ef7fa35672eefe4209d8361">IARG_BRANCH_TAKEN</a>,
                       IARG_END);
      }

      ...
}
</pre></div><p>
The analysis component looks like this: <div class="fragment"><pre class="fragment">VOID docount2( ADDRINT src, ADDRINT dst, INT32 taken )
{
    <span class="keywordflow">if</span>(!taken) <span class="keywordflow">return</span>;
    COUNTER *pedg = Lookup( src,dst );
    pedg-&gt;_count++;
} 
</pre></div><p>
The purpose of the tool is to count how often each controlflow changing edge in the control flowgraph is traversed. The tool considers both calls and branches but for brevity we will not mention branches in our description. The tool works as follows: The instrumentation component instruments each branch with a call to docount2. As parameters we pass in the origin and the target of the branch and whether the branch was taken or not. Branch origin and target represent of the source and destination of the controlflow edges. If a branch is not taken the controlflow does not change and hence the analysis routine returns right away. If the branch is taken we use the src and dst parameters to look up the counter associated with this edge (Lookup will create a new one if this edge has not been seen before) and increment the counter. Note, that the tool could have been simplified somewhat by using IPOINT_TAKEN_BRANCH option with <a class="el" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall()</a>.<h3><a class="anchor" name="shifting_computation">
Shifting Computation for Analysis to Instrumentation Code</a></h3>
About every 5th instruction executed in a typical application is a branch. Lookup will called whenever these instruction are executed, causing significant application slowdown. To improve the situation we note that the instrumentation code is typically called only once for every instruction, while the analysis code is called everytime the instruction is executed. If we can somehow shift computation from the analysis code to the instrumentation code we will improve the overall performance. Our example tools offer multiple such opportunites which will explore in turn. The first observation is that for most branches we can find out inside of Instruction() what the branch target will be . For those branches we can call Lookup inside of Instruction() rather than in docount2(), for indirect branches which are relatively rare we still have to use our original approach. All this is reflected in the folling code. We add a second "lighter" analsysis function, docount. While the original docount2() remains unchanged:<p>
<div class="fragment"><pre class="fragment">VOID docount( COUNTER *pedg, INT32 taken )
{
    <span class="keywordflow">if</span>( !taken ) <span class="keywordflow">return</span>;
    pedg-&gt;_count++;
}
</pre></div><p>
And the instrumentation will be somewhat more complex:<p>
<div class="fragment"><pre class="fragment">VOID Instruction(INS ins, <span class="keywordtype">void</span> *v)
{
      ...

    <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g64333f9a28052aabc341a7a0d3c16aec">INS_IsDirectBranchOrCall</a>(ins))
    {
        COUNTER *pedg = Lookup( <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#gd3b5f975c84b126531b38930b94b5544">INS_Address</a>(ins),  <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#ga52df2852835cd0938a5f2c0e81aaecd">INS_DirectBranchOrCallTargetAddress</a>(ins) );

        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR) docount, 
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, pedg, 
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b568177719c0c3ef7fa35672eefe4209d8361">IARG_BRANCH_TAKEN</a>, 
                       IARG_END);           
    }
    <span class="keywordflow">else</span>
    {
        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR) docount2,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883669f246ea24704e3a30a8ec25354b">IARG_BRANCH_TARGET_ADDR</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b568177719c0c3ef7fa35672eefe4209d8361">IARG_BRANCH_TAKEN</a>,
                       IARG_END);
    }

      ...
}
</pre></div><h3><a class="anchor" name="control_flow">
Eliminating Control Flow</a></h3>
The code for docount() is very compact which provides performance advantages; it may also allow it to be inlined by Pin, thereby avoiding the overhead of a call. The heuristics for when a analysis routine is inlined by Pin are subject to change. But small routines without any control flow (single basic block) are almost guaranteed to be inlined. Unfortunately, docount() does have (albeit limited) control flow. Observing that the parameter, 'taken', will be zero or one we can eliminate the remaining control flow as follows:<p>
<div class="fragment"><pre class="fragment">VOID docount( COUNTER *pedg, INT32 taken )
{
    pedg-&gt;_count += taken;
}
</pre></div><p>
Now docount() can be inlined.<h3><a class="anchor" name="compiler_inlining">
Compiler Considerations for Inlining</a></h3>
The way that the tool is built affects inlining as well. If an analysis routine has a function call to another function, it would not be a candidate for inlining by Pin unless the function call was inlined by the compiler. If the function call is inlined by the compiler, the analysis routine would be a candidate for inlining by Pin. Therefore, it is advisable to write any subroutines called by the analysis routine in a way that allows the compiler to inline the subroutines.<p>
On Linux IA-32 architectures, Pin tools are built non-PIC (Position Independent Code), which allows the compiler to inline both local and global functions. Tools for Linux Intel 64 architectures are built PIC, but the compiler will not inline any globally visible function due to function pre-emption. Therefore, it is advisable to declare the subroutines called by the analysis function as 'static' on Linux Intel 64 architectures.<h3><a class="anchor" name="let_pin_decide">
Letting Pin Decide Where to Instrument</a></h3>
At times we do not care about the exact point where calls to analysis code are being inserted as long as it is within a given basic block. In this case we can let Pin make the decission where to insert. This has the advantage that Pin can select am insertion point that requires minimal register saving and restoring. The following code from ManualExamples/inscount2.cpp shows how this is done for the instruction count example using IPOINT_ANYWHERE with <a class="el" href="group__BBL__BASIC__API.html#g5fba2db08badc1f77616c8f41ce31884">BBL_InsertCall()</a>.<p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

<span class="comment">// The running count of instructions is kept here</span>
<span class="comment">// make it static to help the compiler optimize docount</span>
<span class="keyword">static</span> UINT64 icount = 0;

<span class="comment">// This function is called before every block</span>
<span class="comment">// Use the fast linkage for calls</span>
VOID <a class="code" href="group__INST__ARGS.html#gf3202cd2f4be9bf9d4fa7a035ece147b">PIN_FAST_ANALYSIS_CALL</a> docount(ADDRINT c) { icount += c; }
    
<span class="comment">// Pin calls this function every time a new basic block is encountered</span>
<span class="comment">// It inserts a call to docount</span>
VOID Trace(<a class="code" href="group__TRACE__BASIC__API.html#g72dbbb83ae9ca6278053a75123c920cc">TRACE</a> trace, VOID *v)
{
    <span class="comment">// Visit every basic block  in the trace</span>
    <span class="keywordflow">for</span> (BBL bbl = <a class="code" href="group__TRACE__BASIC__API.html#g1804f26fc605c9344d57be21b392796b">TRACE_BblHead</a>(trace); <a class="code" href="group__BBL__BASIC__API.html#g5aaace888f68ec067f60e3b74c0b9131">BBL_Valid</a>(bbl); bbl = <a class="code" href="group__BBL__BASIC__API.html#g60805b0620b58e2c9ca2add6e16d26ef">BBL_Next</a>(bbl))
    {
        <span class="comment">// Insert a call to docount for every bbl, passing the number of instructions.</span>
        <span class="comment">// IPOINT_ANYWHERE allows Pin to schedule the call anywhere in the bbl to obtain best performance.</span>
        <span class="comment">// Use a fast linkage for the call.</span>
        <a class="code" href="group__BBL__BASIC__API.html#g5fba2db08badc1f77616c8f41ce31884">BBL_InsertCall</a>(bbl, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a2198931604835e0f9ad1cd29cc1bc1f384">IPOINT_ANYWHERE</a>, AFUNPTR(docount), <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c51073d5f62b8800cb3285ede6f9077e">IARG_FAST_ANALYSIS_CALL</a>, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, <a class="code" href="group__BBL__BASIC__API.html#g3d7437048b7fd658b1e4d413c69d9ccb">BBL_NumIns</a>(bbl), IARG_END);
    }
}

KNOB&lt;string&gt; KnobOutputFile(<a class="code" href="group__KNOB__BASIC.html#gg7cca44bfaca0b4c0f4a6a469ae5b9d67f0336979b5a81ce10e8a3d8f2345d606">KNOB_MODE_WRITEONCE</a>, <span class="stringliteral">"pintool"</span>,
    <span class="stringliteral">"o"</span>, <span class="stringliteral">"inscount.out"</span>, <span class="stringliteral">"specify output file name"</span>);

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    <span class="comment">// Write to a file since cout and cerr maybe closed by the application</span>
    ofstream OutFile;
    OutFile.open(KnobOutputFile.Value().c_str());
    OutFile.setf(ios::showbase);
    OutFile &lt;&lt; <span class="stringliteral">"Count "</span> &lt;&lt; icount &lt;&lt; endl;
    OutFile.close();
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    cerr &lt;&lt; <span class="stringliteral">"This tool counts the number of dynamic instructions executed"</span> &lt;&lt; endl;
    cerr &lt;&lt; endl &lt;&lt; KNOB_BASE::StringKnobSummary() &lt;&lt; endl;
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__TRACE__BASIC__API.html#gb3762f773502ad865216ef941c38799e">TRACE_AddInstrumentFunction</a>(Trace, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><h3><a class="anchor" name="fast_linkage">
Using Fast Call Linkages</a></h3>
For very small analysis functions, the overhead to call the function can be comparable to the work done in the function. Some compilers offer optimized call linkages that eliminate some of the overhead. For example, gcc for the IA-32 architecture has a regparm attribute for passing arguments in registers. Pin supports a limited number of alternate linkages. To use it, you must annotate the declaration of the analysis function with <a class="el" href="group__INST__ARGS.html#gf3202cd2f4be9bf9d4fa7a035ece147b">PIN_FAST_ANALYSIS_CALL</a>. The InsertCall function must pass <a class="el" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681c51073d5f62b8800cb3285ede6f9077e">IARG_FAST_ANALYSIS_CALL</a>. If you change one without changing the other, the arguments will not be passed correctly. See the inscount2.cpp example in the previous section for a sample use. For large analysis functions, the benefit may not be significant, but it is unlikely that PIN_FAST_ANALYSIS_CALL would ever cause a slowdown.<p>
Another call linkage optimization is to eliminate the frame pointer. We recommend using -fomit-frame-pointer to compile tools with gcc. See the gcc documentation for an explanation of what it does. The standard Pintool makefiles include -fomit-frame-pointer. Like PIN_FAST_ANALYSIS_CALL, the benefit is largest for small analysis functions. Debuggers rely on frame pointers to display stack traces, so eliminate this option when trying to debug a PinTool. If you are using a standard PinTool makefile, you can do this by overriding the definition of OPT on the command line with<p>
<div class="fragment"><pre class="fragment">make OPT=-O0
</pre></div><h3><a class="anchor" name="partial_inline">
Rewriting Conditional Analysis Code to Help Pin Inline</a></h3>
Pin improves instrumentation performance by automatically inlining analysis routines that have no control-flow changes. Of course, many analysis routines do have control-flow changes. One particularly common case is that an analysis routine has a single "if-then" test, where a small amount of analysis code plus the test is always executed but the "then" part is executed only once a while. To inline this common case, Pin provides a set of conditional instrumentation APIs for the tool writer to rewrite their analysis routines into a form that does not have control-flow changes. The following example from source/tools/ManualExamples/isampling.cpp illustrates how such rewriting can be done:<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*</span>
<span class="comment"> *  This file contains a Pintool for sampling the IPs of instruction executed.</span>
<span class="comment"> *  It serves as an example of a more efficient way to write analysis routines</span>
<span class="comment"> *  that include conditional tests.</span>
<span class="comment"> *  Currently, it works on IA-32 and Intel(R) 64 architectures.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include "pin.H"</span>

FILE * trace;

<span class="keyword">const</span> INT32 N = 100000;
<span class="keyword">const</span> INT32 M =  50000;

INT32 icount = N;

<span class="comment">/*</span>
<span class="comment"> *  IP-sampling could be done in a single analysis routine like:</span>
<span class="comment"> *</span>
<span class="comment"> *        VOID IpSample(VOID *ip)</span>
<span class="comment"> *        {</span>
<span class="comment"> *            --icount;</span>
<span class="comment"> *            if (icount == 0)</span>
<span class="comment"> *            {</span>
<span class="comment"> *               fprintf(trace, "%p\n", ip);</span>
<span class="comment"> *               icount = N + rand() % M;</span>
<span class="comment"> *            }</span>
<span class="comment"> *        }</span>
<span class="comment"> *</span>
<span class="comment"> *  However, we break IpSample() into two analysis routines,</span>
<span class="comment"> *  CountDown() and PrintIp(), to facilitate Pin inlining CountDown()</span>
<span class="comment"> *  (which is the much more frequently executed one than PrintIp()).</span>
<span class="comment"> */</span>

ADDRINT CountDown()
{
    --icount;
    <span class="keywordflow">return</span> (icount==0);
}


<span class="comment">// The IP of the current instruction will be printed and</span>
<span class="comment">// the icount will be reset to a random number between N and N+M.</span>
VOID PrintIp(VOID *ip)
{
    fprintf(trace, <span class="stringliteral">"%p\n"</span>, ip);
    
    <span class="comment">// Prepare for next period</span>
    icount = N + rand() % M; <span class="comment">// random number from N to N+M</span>
}


<span class="comment">// Pin calls this function every time a new instruction is encountered</span>
VOID Instruction(INS ins, VOID *v)
{
    <span class="comment">// CountDown() is called for every instruction executed</span>
    <a class="code" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)CountDown, IARG_END);
    
    <span class="comment">// PrintIp() is called only when the last CountDown() returns a non-zero value.</span>
    <a class="code" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)PrintIp, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681897daee5920e5c9b437f7da52faa758e">IARG_INST_PTR</a>, IARG_END);
    
}

<span class="comment">// This function is called when the application exits</span>
VOID Fini(INT32 code, VOID *v)
{
    fprintf(trace, <span class="stringliteral">"#eof\n"</span>);
    fclose(trace);
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Print Help Message                                                    */</span>
<span class="comment">/* ===================================================================== */</span>

INT32 Usage()
{
    PIN_ERROR( <span class="stringliteral">"This Pintool samples the IPs of instruction executed\n"</span>
                + KNOB_BASE::StringKnobSummary() + <span class="stringliteral">"\n"</span>);
    <span class="keywordflow">return</span> -1;
}

<span class="comment">/* ===================================================================== */</span>
<span class="comment">/* Main                                                                  */</span>
<span class="comment">/* ===================================================================== */</span>

<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    trace = fopen(<span class="stringliteral">"isampling.out"</span>, <span class="stringliteral">"w"</span>);
    
    <span class="comment">// Initialize pin</span>
    <span class="keywordflow">if</span> (<a class="code" href="group__PIN__CONTROL.html#g078bed712e6822f3b42a7b4815ba5c0a">PIN_Init</a>(argc, argv)) <span class="keywordflow">return</span> Usage();

    <span class="comment">// Register Instruction to be called to instrument instructions</span>
    <a class="code" href="group__INS__INST__API.html#ga80cd9a7905b82a86b9e31d9bf589dbe">INS_AddInstrumentFunction</a>(Instruction, 0);

    <span class="comment">// Register Fini to be called when the application exits</span>
    <a class="code" href="group__PIN__CONTROL.html#gd5efea3f1ee5611af535e22f35bce145">PIN_AddFiniFunction</a>(Fini, 0);
    
    <span class="comment">// Start the program, never returns</span>
    <a class="code" href="group__PIN__CONTROL.html#gdfaa67ec042ca4a007869b9d2cc080b9">PIN_StartProgram</a>();
    
    <span class="keywordflow">return</span> 0;
}
</pre></div><p>
In the above example, the original analysis routine IpSample() has a conditional control-flow change. It is rewritten into two analysis routines: CountDown() and PrintIp(). CountDown() is the simpler one of the two, which doesn't have control-flow change. It also performs the original conditional test and returns the test result. We use the conditional instrumentaton APIs <a class="el" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall()</a> and <a class="el" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall()</a> to tell Pin that tbe analysis routine specified by an <a class="el" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall()</a> (i.e. PrintIp() in this example) is executed only if the result of the analysis routine specified by the previous <a class="el" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall()</a> (i.e. CountDown() in this example) is non-zero. Now CountDown(), the common case, can be inlined by Pin, and only once a while does Pin need to execute PrintIp(), the non-inlined case.<h3><a class="anchor" name="handling_reps">
Optimizing Instrumentation of REP Prefixed Instructions</a></h3>
The IA-32 and Intel 64 architectures include REP prefixed string instructions. These use a REP prefix on a string operation to repeat the execution of the inner operation. For some instructions the repeat count is determined solely by the value in the count register. For others (SCAS,CMPS), the count register provides an upper limit on the number of iterations, while the REP opcode provides a condition to be tested which can exit the REP loop before the full number of iterations has been executed.<p>
Pin treats REP prefixed instructions as an implicit loop around the inner instruction, so <a class="el" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a> and <a class="el" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a214b3338de54a3d5823a5b612fd4d2d846">IPOINT_AFTER</a> instrumentation is executed for that instruction once for each iteration of the (implicit) loop. Since each execution of the inner instruction is instrumented, IARG_MEMORY{READ,READ2,WRITE}_SIZE can be determined statically from the instruction (1,2,4,8 bytes), and IARG_MEMORY{OP,READ,READ2,WRITE}_EA can also be determined (even if DF==1, so the inner instructions are decrementing their arguments and moving backwards through store).<p>
REP prefixed instructions are treated as predicated, where the predicate is that the count register is non-zero. Therefore canonical instrumentation for memory accesses such as<p>
<div class="fragment"><pre class="fragment">    <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g9200fcba361c9272ad963a5c5cb5c235">INS_MemoryOperandIsRead</a>(ins,memOp))
    {
        <a class="code" href="group__INS__INST__API.html#g446df8cbefd4950b78cba7c9e7346053">INS_InsertPredicatedCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>,(AFUNPTR)logMemory, 
                                 <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681883955f1b855db490b9fca95e5497995">IARG_MEMORYOP_EA</a>, memOp,
                                 <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, <a class="code" href="group__INS__BASIC__API__GEN__IA32.html#gf14f2e298d864d2114a8dad4eec1864f">INS_MemoryOperandSize</a>(ins,memOp),
                                 IARG_END);
    }
</pre></div><p>
will see all of the memory accesses made by the REP prefixed operations.<p>
To allow tools to count entries into a REP prefixed instruction, and to optimize, Pin provides <a class="el" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818827b05e8f598b702e7d089b3dd014d7">IARG_FIRST_REP_ITERATION</a>, which can be passed as an argument to an analysis routine. It is TRUE if this is the first iteration of a REP prefixed instruction, FALSE otherwise.<p>
Thus to perform an action only on the first iteration of a REP prefixed instruction, one can use code like this (assuming that "takeAction" wants to be called on the first iteration of all REP prefixed instructions, even ones with a zero repeat count):<p>
To obtain the repeat count, you can use <div class="fragment"><pre class="fragment">        IARG_REGISTER_VALUE, <a class="code" href="group__INS__BASIC__API__IA32.html#gfe90cae5c2dead027c67ac7945ac6917">INS_RepCountRegister</a>(ins),
</pre></div> which will pass the value in the appropriate count register (one of REG_CX,REG_ECX,REG_RCX depending on the instruction).<p>
As an example, here is code which counts the number of times REP prefixed instructions are executed, optimizing cases in which the REP prefixed instruction only depends on the count register.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>stats
{
    UINT64 count;                               <span class="comment">// Times we start the REP prefixed op</span>
    UINT64 repeatedCount;                       <span class="comment">// Times we execute the inner instruction</span>
    UINT64 zeroLength;                          <span class="comment">// Times we start but don't execute the inner instruction because count is zero</span>
<span class="keyword">public</span>:
    stats() : count(0), repeatedCount(0), zeroLength(0) {}
    VOID output() <span class="keyword">const</span>;
    VOID add(UINT32 firstRep, UINT32 repCount)
    {
        count += firstRep;
        repeatedCount += repCount;
        <span class="keywordflow">if</span> (repCount == 0)
            zeroLength += 1;
    }
    BOOL empty()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> count == 0; }
    stats&amp; operator+= (<span class="keyword">const</span> stats &amp;other) 
    { 
        count += other.count;
        repeatedCount += other.repeatedCount;
        zeroLength += other.zeroLength;
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }
};

<span class="comment">// Trivial analysis routine to pass its argument back in an IfCall so that we can use it </span>
<span class="comment">// to control the next piece of instrumentation.</span>
<span class="keyword">static</span> ADDRINT returnArg (BOOL arg)
{
    <span class="keywordflow">return</span> arg;
}

<span class="comment">// Analysis functions for execution counts.</span>
<span class="comment">// Analysis routine, FirstRep and Executing tell us the properties of the execution.</span>
<span class="keyword">static</span> VOID addCount (UINT32 opIdx, UINT32 firstRep, UINT32 repCount)
{
    stats * s = &amp;statistics[opIdx];

    s-&gt;add(firstRep, repCount);
}

<span class="comment">// Instrumentation routines.</span>
<span class="comment">// Insert code for counting how many times the instruction is executed</span>
<span class="keyword">static</span> VOID insertRepExecutionCountInstrumentation (INS ins, UINT32 opIdx)
{
    <span class="keywordflow">if</span> (takesConditionalRep(opIdx))
    {
        <span class="comment">// We have no smart way to lessen the number of</span>
        <span class="comment">// instrumentation calls because we can't determine when</span>
        <span class="comment">// the conditional instruction will finish.  So we just</span>
        <span class="comment">// let the instruction execute and have our</span>
        <span class="comment">// instrumentation be called on each iteration.  This is</span>
        <span class="comment">// the simplest way of handling REP prefixed instructions, where</span>
        <span class="comment">// each iteration appears as a separate instruction, and</span>
        <span class="comment">// is independently instrumented.</span>
        <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)addCount,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, opIdx,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818827b05e8f598b702e7d089b3dd014d7">IARG_FIRST_REP_ITERATION</a>,
                       <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56810f0eb050dae80f622d800071bb3b9d69">IARG_EXECUTING</a>,
                       IARG_END);
    }
    <span class="keywordflow">else</span>
    {
        <span class="comment">// The number of iterations is determined solely by the count register value,</span>
        <span class="comment">// therefore we can log all we need at the start of each REP "loop", and skip the</span>
        <span class="comment">// instrumentation on all the other iterations of the REP prefixed operation. Simply use</span>
        <span class="comment">// IF/THEN instrumentation which tests IARG_FIRST_REP_ITERATION.</span>
        <span class="comment">//</span>
        <a class="code" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)returnArg, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818827b05e8f598b702e7d089b3dd014d7">IARG_FIRST_REP_ITERATION</a>, IARG_END);
        <a class="code" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)addCount,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, opIdx,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, 1,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818b1a445366074f7277035293fcc20c98">IARG_REG_VALUE</a>, <a class="code" href="group__INS__BASIC__API__IA32.html#gfe90cae5c2dead027c67ac7945ac6917">INS_RepCountRegister</a>(ins),
                           IARG_END);
    }
}
</pre></div><p>
To perform this optimization when collecting memory access addresses, you will also need to worry about the state of EFLAGS.DF, since the string operations work from high address to low address when EFLAGS.DF==1.<p>
Here is an example which shows how to handle that. <div class="fragment"><pre class="fragment"><span class="comment">// Compute the base address of the whole access given the initial address,</span>
<span class="comment">// repeat count and element size. It has to adjust for DF if it is asserted.</span>
<span class="keyword">static</span> ADDRINT computeEA (ADDRINT firstEA, UINT32 eflags, UINT32 count, UINT32 elementSize)
{
    <span class="keyword">enum</span> {
        DF_MASK = 0x0400
    };

    <span class="keywordflow">if</span> (eflags &amp; DF_MASK)
    {
        ADDRINT size = elementSize*count;
        
        <span class="comment">// The string ops post-decrement, so the lowest address is one elementSize above</span>
        <span class="comment">// where you might think it should be.</span>
        <span class="keywordflow">return</span> firstEA - size + elementSize;  
    }
    <span class="keywordflow">else</span>
        <span class="keywordflow">return</span> firstEA;
}

<span class="keyword">static</span> VOID logMemoryAddress (UINT32 op,        <span class="comment">// Index of instruction</span>
                              BOOL first,       <span class="comment">// First iteration?</span>
                              ADDRINT baseEA,   <span class="comment">// Effective address being accessed on this iteration</span>
                              ADDRINT count,    <span class="comment">// Iteration count</span>
                              UINT32 size,      <span class="comment">// Size in bytes of the per-iteration access</span>
                              UINT32 eflags,    <span class="comment">// Eflags</span>
                              ADDRINT tag)      <span class="comment">// Name for the type of access</span>
{
    <span class="keyword">const</span> <span class="keywordtype">char</span> * tagString = reinterpret_cast&lt;const char *&gt;(tag);
    UINT32 width = 20;
    
    <span class="keywordflow">if</span> (!first)
    {
        out &lt;&lt; <span class="stringliteral">"  "</span>;                            <span class="comment">// Indent REP iterations</span>
        width -= 2;
    }
    out &lt;&lt; opcodes[op].name &lt;&lt; <span class="charliteral">' '</span> &lt;&lt; tagString &lt;&lt; <span class="charliteral">' '</span>;
    out &lt;&lt; std::hex &lt;&lt; std::setw(width) &lt;&lt; computeEA(baseEA, eflags, count, size) &lt;&lt; <span class="charliteral">':'</span>;
    out &lt;&lt; std::dec &lt;&lt; std::setw(20) &lt;&lt; size*count &lt;&lt; endl;
}

<span class="comment">// Insert instrumentation to log memory addresses accessed. </span>
<span class="keyword">static</span> VOID insertRepMemoryTraceInstrumentation(INS ins, UINT32 opIdx)
{
    <span class="keyword">const</span> opInfo * op = &amp;opcodes[opIdx];

    <span class="keywordflow">if</span> (takesConditionalRep(opIdx))
    {
        <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g52d77b7e3ad272c7aed02875dc9907d5">INS_IsMemoryRead</a>(ins))
        {
            <a class="code" href="group__INS__INST__API.html#g82d2ecc73dcd5e2af26fef5bd6ff7190">INS_InsertCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)logMemoryAddress,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, opIdx,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818827b05e8f598b702e7d089b3dd014d7">IARG_FIRST_REP_ITERATION</a>,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56813cf8e5e03da1a8033539aab405df247a">IARG_MEMORYREAD_EA</a>,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56810f0eb050dae80f622d800071bb3b9d69">IARG_EXECUTING</a>,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, op-&gt;size,
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, 0,      <span class="comment">// Fake Eflags, since we're called at each iteration it doesn't matter</span>
                           <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, (ADDRINT)<span class="stringliteral">"Read "</span>,
                           IARG_END);
        }
        <span class="comment">// And similar code for MEMORYREAD2, MEMORYWRITE</span>
    }
    <span class="keywordflow">else</span>
    {
        <span class="keywordflow">if</span> (<a class="code" href="group__INS__BASIC__API__GEN__IA32.html#g52d77b7e3ad272c7aed02875dc9907d5">INS_IsMemoryRead</a>(ins))
        {
            <a class="code" href="group__INS__INST__API.html#g4182ef22ec1351bb0ee998b023263349">INS_InsertIfCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)returnArg, <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818827b05e8f598b702e7d089b3dd014d7">IARG_FIRST_REP_ITERATION</a>, IARG_END);
            <a class="code" href="group__INS__INST__API.html#g0063b9298e92dfc50569d033fcaa4bee">INS_InsertThenCall</a>(ins, <a class="code" href="group__INST__ARGS.html#gga46cc1807fc61addd9afe69ee6736a21067f64649fede2cbd09ede8c118c6a0c">IPOINT_BEFORE</a>, (AFUNPTR)logMemoryAddress,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, opIdx,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b5681dbe9ffb8ed09a01b294343c88b0fe35f">IARG_BOOL</a>, TRUE,      <span class="comment">// First must be TRUE else we wouldn't be called</span>
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56813cf8e5e03da1a8033539aab405df247a">IARG_MEMORYREAD_EA</a>,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818b1a445366074f7277035293fcc20c98">IARG_REG_VALUE</a>, <a class="code" href="group__INS__BASIC__API__IA32.html#gfe90cae5c2dead027c67ac7945ac6917">INS_RepCountRegister</a>(ins),
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56814346d7faa1ba877f5bcaf6281473bea3">IARG_UINT32</a>, op-&gt;size,
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818b1a445366074f7277035293fcc20c98">IARG_REG_VALUE</a>, REG_EFLAGS,      
                               <a class="code" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56811bf9954bfcc59b75c446dd2edd2875f0">IARG_ADDRINT</a>, (ADDRINT)<span class="stringliteral">"Read "</span>,
                               IARG_END);
        }
        <span class="comment">// And similar code for MEMORYREAD2, MEMORYWRITE</span>
    }
}
</pre></div><p>
Since there are real codes where a significant proportion of all instructions are REP prefixed, using <a class="el" href="group__INST__ARGS.html#gg7e2c955c99fa84246bb2bce1525b56818827b05e8f598b702e7d089b3dd014d7">IARG_FIRST_REP_ITERATION</a> to collect information at the beginning of the REP "loop" while skipping it for the later iterations can be a significant optimization.<p>
A tool which demonstrates all of these techniques can be found in source/tools/ManualExamples/countreps.cpp, from which these (slightly edited) code snippets were taken.<p>
======================================================================================== <h2><a class="anchor" name="RESTRICTIONS">
Pintool Information and Restrictions</a></h2>
========================================================================================<h3><a class="anchor" name="General">
General</a></h3>
There are several things that a Pintool writer must be aware of.<ul>
<li>pthread functions cannot be called from an analysis or replacement routine (<a class="el" href="index.html#MT">Instrumenting Multi-threaded Applications</a>)</li><li>Floating point registers are not saved or restored when calling an analysis or replacement routine (<a class="el" href="index.html#FP">Floating Point Support in Analysis Routines</a>)</li><li>IARG_REG_VALUE cannot be used to pass floating point register values to an analysis routine.</li><li>Also, see the OS-specific restrictions below. <a class="el" href="index.html#WINDOWS_OS">Windows OS</a> or <a class="el" href="index.html#LINUX_OS">Linux OS</a></li></ul>
<p>
Often, a Pintool writer wants to run the SPEC benchmarks to see the results of their research. There are many ways one can update the scripts to invoke Pin on the SPEC tests; this is one. In your $SPEC/config file, add the following two lines:<p>
<div class="fragment"><pre class="fragment">   submit=$PIN_HOME/intel64/bin/pin -t /my/pin/tool -- $command
   use_submit_for_speed=yes
</pre></div><p>
Now the SPEC harness will automatically run Pin with whatever benchmarks it runs. Note that you need the full path name for Pin and Pintool binaries. Replace "intel64" with "ia32" if you are using a 32-bit system.<h3><a class="anchor" name="LINUX_OS">
Linux OS</a></h3>
Pin identifies system calls at the actual system call trap instruction, not the libc function call wrapper. Tools need to be aware of oddities like this when interpreting system call arguments, etc.<h3><a class="anchor" name="WINDOWS_OS">
Windows OS</a></h3>
On Windows, Pin has been compiled with /D_SECURE_SCL=0. Pintools must also be compiled with /D_SECURE_SCL=0, otherwise the STL containers shared between Pin and the Pintool can have different memory layouts.<p>
Pin on Windows guarantees safe usage of C/C++ run-time services in Pin tools, including indirect calls to Windows API through C run-time library. Any other use of Windows API in Pin tool is not guaranteed to be safe:<ul>
<li>reentrant use of shared system resources may cause crashes and lost of transparency</li><li>a tool that directly or indirectly locks shared resource by calling to a system API under Pin lock may cause deadlock</li><li>using alertable system calls or installing handlers of asynchronous system events in a tool may violate the logic of the application, cause recursive invocation of instrumentation/analysis callbacks in the tool.</li></ul>
<p>
Pin on Windows does not separate DLLs loaded by the tool from the application DLLs - it uses the same system loader. In order to avoid isolation problems, Pin tool should not load any DLL that can be shared with the application. For the same reason, Pin tool should avoid static links to any common DLL, except for those listed in PIN_COMMON_LIBS (see source.flags file).<p>
In probe mode, the application runs natively, and the probe is placed in the original code. If a tool replaces a function shared by the tool and the application, an undesirable behavior may occur. For example, if a tool replaces EnterCriticalSection() with an analysis routine that calls printf(), this could result in an infinite loop, because printf() can also call EnterCriticalSection(). The application would call EnterCriticalSection(), and the control flow would go to the replacement routine, and it would call EnterCriticalSection() (via printf) which would call the replacement routine, and so on.<h3><a class="anchor" name="namespace">
Conflicts between Pin and Windows</a></h3>
Pin uses some base types that conflict with Windows types. If you use "windows.h", you may see compilation errors. To avoid this problem, we recommend wrapping the windows.h file as follows. Items that reside in the windows.h file must be referenced using the WINDOWS:: prefix.<p>
<div class="fragment"><pre class="fragment"><span class="keyword">namespace </span>WINDOWS
{
<span class="preprocessor">#include &lt;windows.h&gt;</span>
}
</pre></div><h3><a class="anchor" name="building">
Building tools for VC8 kit in Visual Studio 2005*</a></h3>
In order to use pin kit VC8, you must have Visual Studio 2005* installed on your computer.<p>
An example of the Visual Studio 2005* project that builds pin tool in the Visual Studio IDE can be found in the MyPinTool directory.<p>
Enter this directory and open MyPinTool.vcproj project or MyPinTool.sln solution. To build the tool, press "Build Solution" (F7).<p>
To run an application, instrumented by MyPinTool, press "Start Without Debugging" (Ctrl-F5). You can select another application and change tool's switches in the "MyPinTool Properties-&gt;Debugging" page.<p>
You can use MyPinTool as a template for your own project. Please, look carefully at the compilation and linking switches in the MyPinTool property pages. Mandatory switches can be found in the ms.flags file in the kit's source/tools directory. Also note the library order, as this is important, too.<p>
The mandatory compiler switches are:<p>
<div class="fragment"><pre class="fragment">  /MT              link to static CRT library. Using 
                   CRT DLL could cause conflict with
                   the application using the same DLL.
  /EHs- /EHa-      disable exception handling in the tool,
                   otherwise it could interfere in the
                   application's exception handling.
  /wd4530          turn off the warning about not having 
                   /EHsc turned on, while using STL.
  /D_SECURE_SCL=0  STL containers shared between Pin and Pintools
                   must be laid out the same way. 

######################################################################################
#               MSVC 8.0 compiler options for PIN tools
# PIN_COMMON_CXXFLAGS      mandatory compilation switches common to all platforms
# PIN_IA32_CXXFLAGS        mandatory compilation switches for ia32 architecture
# PIN_IA32E_CXXFLAGS       mandatory compilation switches for intel64 architecture
######################################################################################

PIN_COMMON_CXXFLAGS = \
    /MT /EHs- /EHa- /wd4530 /DTARGET_WINDOWS /DBIGARRAY_MULTIPLIER=1 /DUSING_XED \
    /D_CRT_SECURE_NO_DEPRECATE /D_SECURE_SCL=0

PIN_IA32_CXXFLAGS           = /DTARGET_IA32 /DHOST_IA32
PIN_IA32E_CXXFLAGS          = /DTARGET_IA32E /DHOST_IA32E

</pre></div><p>
The mandatory linking switches are:<p>
<div class="fragment"><pre class="fragment">  /EXPORT:main   main function of the tool has to be exported
  /ENTRY:....    tool DLL should be initialized by pin.lib
  /NODEFAULTLIB  do not link and use any system library except
                 for those listed explicitly to avoid conflicts
                 with an application using the same library
  /BASE:....     helps to avoid layout conflicts with DLLs linked
                 to the application


######################################################################################
#               MS linker options for PIN tools
# PIN_COMMON_LDFLAGS      mandatory linking switches common to all platforms
# PIN_IA32_LDFLAGS        mandatory linking switches for ia32 architecture
# PIN_IA32E_LDFLAGS       mandatory linking switches for intel64 architecture
# PIN_COMMON_LIBS         libraries to be linked to the tool on all platforms
# PIN_IA32_LIBS           libraries to be linked to the tool on ia32 machine
# PIN_IA32E_LIBS          libraries to be linked to the tool on intel64 machine
######################################################################################

PIN_COMMON_LIBS         = pin.lib libxed.lib libcpmt.lib libcmt.lib pinvm.lib kernel32.lib
PIN_IA32_LIBS           = ntdll-32.lib
PIN_IA32E_LIBS          = ntdll-64.lib

PIN_COMMON_LDFLAGS      = /DLL /EXPORT:main /NODEFAULTLIB
PIN_IA32_LDFLAGS        = /MACHINE:x86 /ENTRY:Ptrace_DllMainCRTStartup@12 /BASE:0x55000000
PIN_IA32E_LDFLAGS       = /MACHINE:x64 /ENTRY:Ptrace_DllMainCRTStartup /BASE:0xC5000000

</pre></div><h3><a class="anchor" name="nmake">
Building tools for VC8 kit using Microsoft* NMAKE* utility</a></h3>
Open Command Prompt window and enter the kit's root directory or one of its subdirectories. Check to see that the directory contains the Nmakefile file. Notice, some of the subdirectories do not contain Nmakefile because they are not intended to demonstrate pin features in Windows. Type one of the following commands:<p>
To build all tool examples: <div class="fragment"><pre class="fragment">     nmake
</pre></div><p>
To run all tests: <div class="fragment"><pre class="fragment">     nmake test
</pre></div><p>
To delete build targets and results of tests: <div class="fragment"><pre class="fragment">    nmake clean
</pre></div><p>
To build specific tool example: <div class="fragment"><pre class="fragment">     cd SimpleExamples
      ..\nmake opcodemix.dll
</pre></div><p>
To test specific tool: <div class="fragment"><pre class="fragment">     cd SimpleExamples
     ..\nmake opcodemix.test
</pre></div><p>
Notice, "nmake" in the above commands is the nmake.bat file from the kit's root directory. To invoke nmake.exe directly, you must specify the makefile as the input file:<p>
<div class="fragment"><pre class="fragment">     nmake.exe /F Nmakefile
</pre></div><p>
Otherwise, instead of Nmakefile, nmake.exe will find the GNU "makefile" file that resides in the same directory.<h3><a class="anchor" name="multi">
Constructing PinTools from multiple DLLs on Windows</a></h3>
A Pin tool can be composed from multiple DLLs:<ul>
<li>"main DLL", which is specified in the Pin command line after "-t" switch</li><li>a number of "secondary DLLs", linked to the "main DLL" statically or loaded dynamically.</li></ul>
<p>
When considering this configuration, take into account that multi-DLL Pin tool may increase memory fragmentation and cause layout conflicts with application images. If there is no compelling reasons for using multiple DLLs, build your tool as a single DLL to reduce the risk of memory conflicts.<p>
Limitations and instructions:<ul>
<li>Don't use any Pin API in "secondary DLLs". Only "main DLL" can use Pin API!</li><li>Use one of the following methods to load "secondary DLLs":<ul>
<li>statically link "secondary DLLs" to the "main DLL"</li><li>dynamically load "secondary DLLs" in the main() function of "main DLL". Do not load DLLs in instrumentation/analysis callbacks - it is unsafe!</li></ul>
</li><li>If necessary, unload "secondary DLLs" in the main() function of "main DLL". Do not unload DLLs in instrumentation/analysis callbacks - it is unsafe!</li><li>IMPORTANT: Build each DLL with the recommended pin tool building flags (see <a class="el" href="index.html#building">Building tools for VC8 kit in Visual Studio 2005*</a>).</li><li>Remove /EXPORT:main link flag for "secondary DLLs".</li><li>Specify different base address for each DLL (/BASE link flag). When choosing base addresses, try to minimize memory fragmentation and layout conflicts.</li></ul>
<h3><a class="anchor" name="supported">
Supported executables</a></h3>
Pin can instrument Windows* subsystem executables.<br>
 It can't instrument other executables (such as MS-DOS, Win16 or a POSIX subsystem executables).<p>
======================================================================================== <h2><a class="anchor" name="WINLIBRARIES">
Libraries for Windows</a></h2>
========================================================================================<p>
Pin on Windows uses dbghelp.dll by Microsoft* to provide symbolic information. This DLL is not distributed with the kit. In order to get support for symbolic information in Pin, you have to download the "Debugging Tools For Windows*" package, version 6.11.1.404 from <a href="http://www.microsoft.com/whdc/devtools/debugging/default.mspx">http://www.microsoft.com/whdc/devtools/debugging/default.mspx</a> . Use "Debugging Tools For Windows* 32-bit Version" for IA-32 architectures and "Debugging Tools For Windows* - Native x64" for Intel(R) 64 architectures. Distribution of the debugging tools is provided in .msi format which must be installed to extract a single file. Copy dbghelp.dll from the package into "ia32\bin" or "intel64\bin" directory of the Pin kit. This directory should already contain pin.exe and pinvm.dll files.<p>
======================================================================================== <h2><a class="anchor" name="LIBRARIES">
Libraries for Linux</a></h2>
========================================================================================<h3><a class="anchor" name="LIBRARIES_INTRO">
Introduction</a></h3>
The Linux version of pin requires the shared objects from glibc:<p>
<div class="fragment"><pre class="fragment">libc
libm
libdl
ld-linux*
</pre></div><p>
and g++ libraries:<p>
<div class="fragment"><pre class="fragment">libstdc++
libgcc_s
</pre></div><p>
If your system does not have the runtime libraries required for gcc3.4 or later(/usr/lib/libstdc++.so.6), then we recommend that you install them. Installing the compiler will install the runtime libraries. If that is not possible, then we provide the libraries and a method to use them from a local directory. If you want to use a probe based tool, then you cannot use the default glibc that comes with recent linux distributions. We provide the libraries and a method to use them from a local directory.<h3><a class="anchor" name="BUILD_TOOLS_ON_LINUX">
How to build tools on Linux</a></h3>
Pin tools on Linux are shared objects loaded by pin before the application starts. Pin and the tool share the runtime libraries therefore the tool must be compiled with a compiler compatible with pin. Pin is compiled by GCC 3.4.6 and is tested regularly with tools compiled with various GCC versions ranging from version 3.4.6 to version 4.3.1.<p>
The pin kit has a makefile that can be used to compile your tool. If you don't use make to build your tool, then please follow the compiler definitions in the makefile.gnu.config file or follow the examples in the kit.<h3><a class="anchor" name="LIBRARIES_NO_PROBE">
How to Install Libraries If You Do Not Use Probe-mode</a></h3>
If your system does not have libstdc++.so.6 installed and you are not using probe mode, then download pin-jit-runtime.tar.gz and untar it into the top level directory of the pin kit.<p>
<div class="fragment"><pre class="fragment">tproj&gt; tar zxf pin-2.4-20350-gcc.3.4.6-ia32_intel64-linux.tar.gz
tproj&gt; cd pin-2.4-20350-gcc.3.4.6-ia32_intel64-linux
tproj/pin-2.4-20350-gcc.3.4.6-ia32_intel64-linux&gt; tar zxf pin-jit-runtime.tar.gz
</pre></div><p>
The file "pin" is a script that will set up the environment to find the libraries you installed from pin-jit-runtime.tar.gz. These directories will be searched first, followed by directories that are on the LD_LIBRARY_PATH.<p>
If you need to change the directory structure or copy pin to a different directory, then you must understand the following. The file "pin" is a script that expects the binary "pinbin" to be in the architecture-specific "bin" subdirectory (e.g. ia32/bin). The script expects the libraries to be found in the architecture-specific "runtime" subdirectory (i.e. ia32/runtime). If you need a different directory structure, you can edit the pin script. The pin binary does not make assumptions about the directory structure.<p>
We try to keep the libraries in pin-jit-runtime.tar.gz up to date so you can use the latest version of gcc. If you have problems with undefined symbols at runtime, then our libraries are probably too old for your compiler. You may need to copy the libstdc++ and libgcc_s from your build system to the appropriate directory.<h3><a class="anchor" name="LIBRARIES_PROBE">
How To Install Libraries If You Use Probe-mode</a></h3>
If you are using probe mode, you cannot use the standard glibc on your system. You need to install pin-probe-runtime.tar.gz. This file can be downloaded from <a href="http://www.pintool.org.">http://www.pintool.org.</a><p>
<div class="fragment"><pre class="fragment">tproj&gt; tar zxf pin-probe-runtime.tar.gz
</pre></div><p>
The pin script expects to find glibc in the architecture-specific "runtime" subdirectory (i.e. ia32/runtime), so be careful about rearranging files and directories.<h3><a class="anchor" name="BUILD_PROBES_TOOLS_ON_LINUX">
How to build tools for Probe-mode on Linux</a></h3>
Backward compatibility in libraries in Linux is achieved by using version-symbols. New versions of glibc and the standard C++ runtime libraries have backward compatibility. The pin-probe-runtime includes glibc 2.3.4 and a version of C++ runtime libraries that can be used with this version of glibc.<p>
The simplest way to be compatible with this version of glibc is to install red hat el4 or one of its clones (e.g. centos) and use the system compiler. It is also possible to build a tool on newer Linux OS releases, as long as the tool does not reference symbols that are not in glibc 2.3.4. If there is a problem, you will get an error message about not being able to find symbols when starting pin. We have tested a variety of tools on recent linux distributions and have not seen any problems.<h3><a class="anchor" name="LIBRARIES_PACKAGING">
Packaging Pintools For a Binary Distribution</a></h3>
If you are distributing pin tools in binary form, then we suggest that you preserve the layout of pin-jit-runtime.tar.gz:<p>
<div class="fragment"><pre class="fragment">ia32/runtime/glibc/
ia32/runtime/libgcc_s.so.1@
ia32/runtime/libstdc++.so.6.0.9*
ia32/runtime/libgcc_s-3.4.6-20060404.so.1*
ia32/runtime/libstdc++.so.6@
ia32/runtime/libgcc_s.so@
ia32/runtime/libstdc++.so.6.0.3*

</pre></div><p>
The "ia32" subdirectory is used for the IA-32 architecture. Similarly, "intel64" is used for the Intel(R) 64 architecture, and "ia64" is used for the IA-64 architecture.<h3><a class="anchor" name="LIBRARIES_DETAILS">
Detailed Explanation For Altering Directory Layout</a></h3>
We strongly recommend that you use an unmodified "pin" script and the library tar files that we provide. If you cannot then you will have to invest more time to understand the library requirements. Here is a brief explanation of the mechanism that the script uses:<p>
We have to modify the library paths so pin can find its libraries, but we don't want to affect the application. Pin uses these environment variables to control library paths.<p>
PIN_VM_LD_LIBRARY_PATH - LD_LIBRARY_PATH will be set to this value before starting vm or binary tool<p>
PIN_LD_RESTORE_REQUIRED - Tells injector, vm, or binary tool that it must restore the loader environment variables at startup, using the following variables.<p>
PIN_APP_LD_LIBRARY_PATH - LD_LIBRARY_PATH is restored to this value. If PIN_LD_RESTORE_REQUIRED is set, but this variable is not, then LD_LIBRARY_PATH will be unset.<p>
PIN_APP_LD_ASSUME_KERNEL - LD_ASSUME_KERNEL is restored to this value. If PIN_LD_RESTORE_REQUIRED is set, but this variable is not, then LD_ASSUME_KERNEL will be unset.<p>
The pin injector starts an application and then injects a vm into the address space of an application, and runs the application in the vm. The vm requires a binary, which we call "pinbin". The injector happens to be the same binary as the vm. When an injector starts up from the command line by invoking "pin", it needs the g++ libraries. If they are not in the standard place, then LD_LIBRARY_PATH must be set to point to them. The injector must use the standard glibc so don't point the LD_LIBRARY_PATH to the glibc that we redistribute.<p>
When an injector starts a vm, it must setup the library path by using PIN_LD_LIBRARY_PATH. This should point to the g++ libraries. If you are using probe mode, then it should also point to the glibc files.<p>
We don't want the application using any pin libraries so we restore the LD_LIBRARY_PATH before invoking the application by using PIN_LD_RESTORE_REQUIRED, PIN_OLD_LD_LIBRARY_PATH, and PIN_OLD_LD_ASSUME_KERNEL.<p>
See MIXED-MODE for more information on invoking Pin on Intel(R) 64 Architectures.<p>
======================================================================================== <h2><a class="anchor" name="INSTALLATION">
Installing Pin</a></h2>
========================================================================================<p>
Each kit contains Pin and libraries for a specific architecture. Make sure the kit you download is for the right architecture. The Pin libraries use C++, and the compiler you use to build the tool must be compatible with the Pin library. This restriction only applies to building tools; you can instrument applications built by any compiler.<p>
See the README file in the kit for specific information about compiler version and other limitations. If your compiler is not compatible with the kit, send mail to <a href="mailto:pinheads@yahoogroups.com">pinheads@yahoogroups.com</a>.<p>
To install a kit, unpack a kit and change to the directory.<p>
Linux: <div class="fragment"><pre class="fragment">$ tar zxf pin-2.4-20148-gcc.3.4.6-ia32_intel64-linux.tar.gz
$ cd pin-2.4-20148-gcc.3.4.6-ia32_intel64-linux
</pre></div><p>
Windows: Unzip the installation files, extracting all files in the kit. <div class="fragment"><pre class="fragment">$ cd  pin-2.4-20148-gcc.3.4.6-ia32_intel64-linux
</pre></div><p>
Build and test the examples from the manual.<p>
<div class="fragment"><pre class="fragment">$ cd source/tools/ManualExamples/
$ make test
/usr/bin/g++ -c -Wall -Werror -Wno-unknown-pragmas -g -O3 -fomit-frame-pointer
         -DBIGARRAY_MULTIPLIER=1 -DUSING_XED -g -fno-strict-aliasing -I../Include
         -I../InstLib -I../../../extras/xed2-intel64/include -I../../../source/include
         -I../../../source/include/gen -DTARGET_IA32E -DHOST_IA32E -fPIC -DTARGET_LINUX
         -o obj-intel64/inscount0.o inscount0.cpp
/usr/bin/g++ -g -shared -Wl,-Bsymbolic -Wl,--version-script=../../../source/include/pintool.ver
         -L../Lib/ -L../ExtLib/ -L../../../extras/xed2-intel64/lib -L../../../intel64/lib
         -L../../../intel64/lib-ext  -o obj-intel64/inscount0.so obj-intel64/inscount0.o
         -L../Lib/ -L../ExtLib/ -L../../../extras/xed2-intel64/lib -L../../../intel64/lib
         -L../../../intel64/lib-ext -lpin  -lxed -ldwarf -lelf -ldl  -gtouch inscount0.tested
touch inscount0.failed
touch obj-intel64/inscount0.so.makefile.copy; rm obj-intel64/inscount0.so.makefile.copy
../../../pin -slow_asserts    -t obj-intel64/inscount0.so -- /bin/cp makefile obj-intel64/inscount0.so.makefile.copy
cmp makefile obj-intel64/inscount0.so.makefile.copy
rm obj-intel64/inscount0.so.makefile.copy; rm inscount0.failed

&lt;etc.&gt;
</pre></div><p>
Run one of the sample tools from the installed directory. Use "obj-ia32" for the IA-32 architecture, "obj-intel64" for the Intel(R) 64 architecture, and "obj-ia64" for the IA-64 architecture.<p>
<div class="fragment"><pre class="fragment">$ ../../../pin -t obj-intel64/pinatrace.so -- /bin/ls
_insprofiler.cpp  atrace.out   inscount0.o      itrace.cpp  proccount
atrace          imageload.cpp  inscount1.cpp    itrace.o    proccount.cpp
atrace.cpp      inscount0      insprofiler.cpp  itrace.out  proccount.o
atrace.o        inscount0.cpp  itrace           makefile    proccount.out
$ head pinatrace.out 
0x40001ee0: R 0xbfffe1e8
0x40001efd: W 0xbfffe224
0x40001f09: W 0xbfffe228
0x40001f20: W 0xbfffe2b4
0x40001f20: W 0xbfffe2b8
0x40001f20: W 0xbfffe2bc
0x40001f20: W 0xbfffe2c0
0x40001f20: W 0xbfffe2c4
0x40001f20: W 0xbfffe2c8
0x40001f20: W 0xbfffe2cc
$ 
</pre></div><p>
To write your own tool, copy one of the example directories and edit the makefile to add your tool. The sample tool MyPinTool is recommended. This tool allows you to build either inside or outside the Pin environment.<p>
======================================================================================== <h2><a class="anchor" name="FEEDBACK">
Questions? Bugs?</a></h2>
========================================================================================<p>
Send bugs and questions to <a href="mailto:pinheads@yahoogroups.com">pinheads@yahoogroups.com</a>. Complete bug reports that are easy to reproduce are fixed faster, so try to provide as much information as possible. Include: kit number, your OS version, compiler version. Try to reproduce the problem in a simple example that you can send us.<p>
======================================================================================== <h2><a class="anchor" name="LEGAL">
Disclaimer and Legal Information</a></h2>
========================================================================================<p>
The information in this manual is subject to change without notice and Intel Corporation assumes no responsibility or liability for any errors or inaccuracies that may appear in this document or any software that may be provided in association with this document. This document and the software described in it are furnished under license and may only be used or copied in accordance with the terms of the license. No license, express or implied, by estoppel or otherwise, to any intellectual property rights is granted by this document. The information in this document is provided in connection with Intel products and should not be construed as a commitment by Intel Corporation.<p>
EXCEPT AS PROVIDED IN INTEL'S TERMS AND CONDITIONS OF SALE FOR SUCH PRODUCTS, INTEL ASSUMES NO LIABILITY WHATSOEVER, AND INTEL DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY, RELATING TO SALE AND/OR USE OF INTEL PRODUCTS INCLUDING LIABILITY OR WARRANTIES RELATING TO FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, OR INFRINGEMENT OF ANY PATENT, COPYRIGHT OR OTHER INTELLECTUAL PROPERTY RIGHT. Intel products are not intended for use in medical, life saving, life sustaining, critical control or safety systems, or in nuclear facility applications.<p>
Designers must not rely on the absence or characteristics of any features or instructions marked "reserved" or "undefined." Intel reserves these for future definition and shall have no responsibility whatsoever for conflicts or incompatibilities arising from future changes to them.<p>
The software described in this document may contain software defects which may cause the product to deviate from published specifications. Current characterized software defects are available on request.<p>
Copyright 2004-2010, Intel Corporation. All rights reserved.<p>
Microsoft, Windows, and the Windows logo are trademarks, or registered trademarks of Microsoft Corporation in the United States and/or other countries.<p>
Java is a registered trademark of Oracle and/or its affiliates.<p>
Other names and brands may be claimed as the property of others.<p>
Copyright Intel Corporation. All rights reserved. Intel Corporation, 2200 Mission College Blvd., Santa Clara, CA 95052-8119, USA.<p>
======================================================================================== <hr size="1"><address style="align: right;"><small>Generated on Fri Oct 22 02:29:22 2010 for Pin by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
