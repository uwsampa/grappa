<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>XED2: XED2 User Guide - Fri Oct 22 02:28:20 2010 </title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>XED command interface</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
</table>
The command line tool called xed or xed.exe is built when you build the examples (<a class="el" href="group__EXAMPLES.html">Examples of using XED</a>) that come with XED. The xed-ex3 is just encode portion of the xed command line tool.<p>
This tool is useful for encoding and decoding or even decoding-then-re-encoding a single instruction or all the instructions in the text segment of an ELF binary (32 or 64b). For decoding, just jump to the examples.<p>
This section also explains a little language for writing the instructions for encode requests (-e option). I am constantly using this tool and updating it. The xed-ex3 (xed-ex3.exe) example is just the encoder portion of the xed command line tool.<p>
The SUPPRESSED operands emitted by the decoder are not used when encoding. They are ignored. They are not required to select an encoding.<p>
The syntax for encodable strings is as follows: <div class="fragment"><pre class="fragment">             Opcode[/width]   [operand [operand]]
</pre></div><p>
The width is a 8, 16, 32 or 64, indicating the effective operand width if it differs from the default. 8b operations generally require this. Or since most operations that default to 32b widths in 64b mode, it is required for 64b operation widths in 64b mode.<p>
The operand specifier is one of the following.<p>
<ul>
<li>A register name such as EAX or R8B, etc. Case does not matter.</li></ul>
<p>
<ul>
<li>An immediate specifier such as IMM:12ff</li></ul>
<p>
<ul>
<li>A branch displacement specifier such as BRDISP:0000001f</li></ul>
<p>
<ul>
<li>A memory specifier that indicates the base register, index register, scale value, and displacement value. If one of the fields is not required, a - is necessary. The displacement is omittable. For example: MEM4:ESI,EAX,8,ff or MEM4:EBX. The first one specifies that the memory address 4 bytes and should be ESI + EAX * 8 + 0xff. The second one specifies that EBX should be used to access 4 bytes of memory; note the displacement is omitted. A segment override can be specified as follows: MEM4:GS:EAX by using a segment-name followed by a ":" before the base register. If there is no base register, you can use a "-", for example: MEM4:GS:-,-,11223344. One also needs to specify a memory operation width. This can be accomplished by indicating a number of bytes just after the MEM specifier. For example: MEM2:EAX indicates a 2 byte memory operation.</li></ul>
<p>
<ul>
<li>An address generation specifer that has the same syntax as the above MEM: specifier, but is only used for LEA instructions. Example: AGEN:EAX,EBX,2,-</li></ul>
<p>
Here is the help message:<p>
<div class="fragment"><pre class="fragment">% obj/xed -h
Usage: obj/xed [options]
One of the following is required:
  -i input_file             (decode file)
  -ide input_file           (decode/encode file)
  -d hex-string             (decode one instruction)
  -e instruction            (encode, must be last)
  -de hex-string            (decode-then-encode)
 
Optional arguments:
  -v verbosity  (0=quiet, 1=errors, 2=useful-info, 3=trace, 5=very verbose)
  -n number-of-instructions-to-decode (default 10,000, accepts K/M/G qualifiers)
  -I            (Intel SYSV syntax for disassembly)
  -A            (ATT SYSV syntax for disassembly)
  -16           (for LEGACY_16 mode)
  -32           (for LEGACY_32 mode, default)
  -64           (for LONG_64 mode w/64b addressing)
  -s32          (32b stack addressing, default, not in LONG_64 mode)
  -s16          (16b stack addressing, not in LONG_64 mode)
</pre></div><p>
Here are a couple of examples:<p>
<div class="fragment"><pre class="fragment">% xed -d 0000
ADD INT_ALU BASE  Opcode: 00  MODRM: 00 Bytes: 2
        Eb/EXPLICIT/RW Gb/EXPLICIT/R 
        ADD EffWidth: 8b
        MachineMode: LEGACY_32 AddrWidth: 32b StackAddrWidth: 32b
        MEM/EXPLICIT/RW REG/AL(REG8)/EXPLICIT/R 
        Read Write BASE= EAX(REG32) MemopLength = 1

        rFLAGS: of-mod sf-mod zf-mod af-mod pf-mod cf-mod Read:  Written: of sf zf af pf cf             writes

% xed -e ADD EAX EBX
Encodable! 01d8

xed -e ADD EAX MEM4:ESP,EBX,4
Encodable! 03049c

% xed -d 6a00
PUSH INT_ALU BASE  Opcode: 6a  Immed: 00 Bytes: 2
        Ib/EXPLICIT/R STACKPUSH/SUPPRESSED/R 
        PUSH EffWidth: 32b
        MachineMode: LEGACY_32 AddrWidth: 32b StackAddrWidth: 32b
        MEM/SUPPRESSED/W REG/ESP(REG32)/SUPPRESSED/RW IMM/EXPLICIT/R 
        Write SEG= SS BASE= ESP(REG32) MemopLength = 4
        IMMED: 00

        Does not use rFLAGS

% xed -e MOV EAX MEM4:SS:ESP
Encodable! 8b0424
</pre></div><p>
Or using the xed-ex3 example tool: <div class="fragment"><pre class="fragment">% obj/xed-ex3
Usage: obj/xed-ex3 [-16|-32|-64] [-s16|-s32] encode-string
</pre></div><p>
The -16, -32 or -64 are for specifying the major mode of the machine. The major mode of the machine determines the default data operand size and default addressing width. In 64b mode, the default data size is 32b and the default addressing mode is 64b addressing. In 32b mode, the default addressing width is 32b. In 16b mode, the default addressing width is 16b. In 32b mode or 16b mode, the stack addressing width must also be specified. Usually it matches the major mode. The -s16 option is for specifying 16b stack addressing in 32b mode. The -s32 is for specifying 32b stack addressing in 16 bit mode.<p>
<div class="fragment"><pre class="fragment">% obj/xed-ex3 -64 PUSH/64 RAX
Encode request:
PUSH Prefixes:  EffOpWidth: 64b EffAddrWidth: 64b
        MachineMode: LONG_64 AddrWidth: 64b StackAddrWidth: 32b
        REG/RAX(REG64)/EXPLICIT/RW 
        MemopLength = 0

Encodable! 50

% obj/xed-ex3 MOV MEM4:EAX IMM:11223344
Encode request:
MOV Prefixes:  EffOpWidth: 32b EffAddrWidth: 32b
        MachineMode: LEGACY_32 AddrWidth: 32b StackAddrWidth: 32b
        MEM0/EXPLICIT/RW IMM/EXPLICIT/RW 
        TmpltIdx=0 BASE= EAX(REG32) MemopLength = 0
        IMMED: 0x11223344 <span class="keywordtype">signed</span>: 1144201745 starts@byte: 1

Encodable! c70011223344
</pre></div><h2><a class="anchor" name="ENCODE_EXAMPLE">
An example of using the encoder</a></h2>
The encoder language file which is part of the xed command line tool shows how to build up instructions from scratch. The example uses a string to drive the creation of the instruction, but that is just an example. Look at the parse_encode_request function for the required pieces.<p>
<div class="fragment"><pre class="fragment"><span class="comment">/*BEGIN_LEGAL </span>
<span class="comment">Intel Open Source License </span>
<span class="comment"></span>
<span class="comment">Copyright (c) 2002-2010 Intel Corporation. All rights reserved.</span>
<span class="comment"> </span>
<span class="comment">Redistribution and use in source and binary forms, with or without</span>
<span class="comment">modification, are permitted provided that the following conditions are</span>
<span class="comment">met:</span>
<span class="comment"></span>
<span class="comment">Redistributions of source code must retain the above copyright notice,</span>
<span class="comment">this list of conditions and the following disclaimer.  Redistributions</span>
<span class="comment">in binary form must reproduce the above copyright notice, this list of</span>
<span class="comment">conditions and the following disclaimer in the documentation and/or</span>
<span class="comment">other materials provided with the distribution.  Neither the name of</span>
<span class="comment">the Intel Corporation nor the names of its contributors may be used to</span>
<span class="comment">endorse or promote products derived from this software without</span>
<span class="comment">specific prior written permission.</span>
<span class="comment"> </span>
<span class="comment">THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<span class="comment">``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<span class="comment">LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<span class="comment">A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE INTEL OR</span>
<span class="comment">ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<span class="comment">SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<span class="comment">LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<span class="comment">DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<span class="comment">THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<span class="comment">(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="comment">OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="comment">END_LEGAL */</span>

<span class="comment">// This is an example of how to use the encoder from scratch in the context</span>
<span class="comment">// of parsing a string from the command line.  </span>


<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;iomanip&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;sstream&gt;</span>
<span class="preprocessor">#include &lt;cassert&gt;</span>
<span class="preprocessor">#include &lt;cstring&gt;</span>
<span class="preprocessor">#include &lt;cstdlib&gt;</span>
<span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
<span class="preprocessor">#include "<a class="code" href="xed-interface_8h.html">xed-interface.h</a>"</span>
<span class="preprocessor">#include "<a class="code" href="xed-portability_8h.html">xed-portability.h</a>"</span>
<span class="preprocessor">#include "xed-examples-util.h"</span>
}
<span class="preprocessor">#include "xed-enc-lang.H"</span>




<span class="keyword">using namespace </span>std;
<span class="keyword">static</span> <span class="keywordtype">char</span> xed_enc_lang_toupper(<span class="keywordtype">char</span> c) {
    <span class="keywordflow">if</span> (c &gt;= <span class="charliteral">'a'</span> &amp;&amp; c &lt;= <span class="charliteral">'z'</span>)
        <span class="keywordflow">return</span> c-<span class="charliteral">'a'</span>+<span class="charliteral">'A'</span>;
    <span class="keywordflow">return</span> c;
}

<span class="keyword">static</span> string upcase(string s) {
    string t = <span class="stringliteral">""</span>;
    <a class="code" href="xed-types_8h.html#4f6211e57e8a06c6ddde22f8c344ad7d">xed_uint_t</a> len = static_cast&lt;xed_uint_t&gt;(s.size());
    <a class="code" href="xed-types_8h.html#4f6211e57e8a06c6ddde22f8c344ad7d">xed_uint_t</a> i;
    <span class="keywordflow">for</span>(i=0 ; i &lt; len ; i++ ) 
        t = t + xed_enc_lang_toupper(s[i]);
    <span class="keywordflow">return</span> t;
}

<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>
xed_split_args(<span class="keyword">const</span> string&amp; sep, 
               <span class="keyword">const</span> string&amp; input, 
               vector&lt;string&gt;&amp; output_array)
{
    <span class="comment">// returns the number of args</span>
    <span class="comment">// rip off the separator characters and split the src string based on separators.</span>
    
    <span class="comment">// find the string between last_pos and pos. pos is after last_pos</span>
    string::size_type last_pos = input.find_first_not_of(sep, 0);
    string::size_type pos = input.find_first_of(sep, last_pos);  
    <span class="keywordflow">if</span> (CLIENT_VERBOSE3)
        printf(<span class="stringliteral">"input %s\tlast_pos "</span> <a class="code" href="xed-portability_8h.html#5faee3534300d425bae3cddf5394cdfa">XED_FMT_U</a> <span class="stringliteral">" pos "</span> <a class="code" href="xed-portability_8h.html#5faee3534300d425bae3cddf5394cdfa">XED_FMT_U</a> <span class="stringliteral">"\n"</span>, 
               input.c_str() , <a class="code" href="xed-portability_8h.html#95bae36643a1c0231c14d638ff43100b">XED_STATIC_CAST</a>(<a class="code" href="xed-types_8h.html#4f6211e57e8a06c6ddde22f8c344ad7d">xed_uint_t</a>,last_pos), <a class="code" href="xed-portability_8h.html#95bae36643a1c0231c14d638ff43100b">XED_STATIC_CAST</a>(<a class="code" href="xed-types_8h.html#4f6211e57e8a06c6ddde22f8c344ad7d">xed_uint_t</a>,pos));
    <span class="keywordtype">int</span> i=0;
    <span class="keywordflow">while</span>( pos != string::npos &amp;&amp; last_pos != string::npos ) 
    {
        string a = input.substr(last_pos, pos-last_pos);
        output_array.push_back(a); 
        <span class="keywordflow">if</span> (CLIENT_VERBOSE3)
            printf(<span class="stringliteral">"\t\tlast_pos "</span> XED_FMT_U <span class="stringliteral">" pos "</span> XED_FMT_U <span class="stringliteral">" i %d\n"</span>, 
                   <a class="code" href="xed-portability_8h.html#95bae36643a1c0231c14d638ff43100b">XED_STATIC_CAST</a>(<a class="code" href="xed-types_8h.html#4f6211e57e8a06c6ddde22f8c344ad7d">xed_uint_t</a>,last_pos),
                   <a class="code" href="xed-portability_8h.html#95bae36643a1c0231c14d638ff43100b">XED_STATIC_CAST</a>(<a class="code" href="xed-types_8h.html#4f6211e57e8a06c6ddde22f8c344ad7d">xed_uint_t</a>,pos),
                   i);
        last_pos = input.find_first_not_of(sep, pos);
        pos = input.find_first_of(sep, last_pos);  
        i++;
    }
    <span class="keywordflow">if</span> (last_pos != string::npos &amp;&amp; pos == string::npos)
    {
        <span class="keywordflow">if</span> (CLIENT_VERBOSE3)
            printf(<span class="stringliteral">"\t\tGetting last substring at "</span> XED_FMT_U <span class="stringliteral">"\n"</span>, <a class="code" href="xed-portability_8h.html#95bae36643a1c0231c14d638ff43100b">XED_STATIC_CAST</a>(<a class="code" href="xed-types_8h.html#4f6211e57e8a06c6ddde22f8c344ad7d">xed_uint_t</a>,last_pos));
        string a = input.substr(last_pos); <span class="comment">// get the rest of the string</span>
        output_array.push_back(a);
        i++;
    }
    <span class="keywordflow">if</span> (CLIENT_VERBOSE3)
        printf(<span class="stringliteral">"\t returning %d\n"</span>,i);
    <span class="keywordflow">return</span> i;
}

vector&lt;string&gt; 
tokenize(<span class="keyword">const</span> string&amp; s,
         <span class="keyword">const</span> string&amp; delimiter) {
    vector&lt;string&gt; v;
    (void) xed_split_args(delimiter, s, v);
    <span class="keywordflow">return</span> v;
}


<span class="keywordtype">void</span> slash_split(<span class="keyword">const</span> string&amp; src,
                 string&amp; first, <span class="comment">// output</span>
                 string&amp;  second) <span class="comment">//output</span>
{
  string::size_type p = src.find(<span class="stringliteral">"/"</span>);
  <span class="keywordflow">if</span> (p == string::npos) {
    first = src;
    second = <span class="stringliteral">""</span>;
  }
  <span class="keywordflow">else</span> {
    first = src.substr(0,p);
    second = src.substr(p+1);
  }
}

<span class="keyword">class </span>immed_parser_t {
  <span class="keyword">public</span>:
    <a class="code" href="xed-types_8h.html#7b03cfdd50b61cf63f302db50d31b336">xed_bool_t</a> valid;
    string immed;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> width_bits;
    xed_uint64_t immed_val;
    string tok0;

    immed_parser_t(<span class="keyword">const</span> string&amp; s, 
                   <span class="keyword">const</span> string&amp; arg_tok0) <span class="comment">//CONS</span>
        : valid(false),
          tok0(arg_tok0)
    {
        vector&lt;string&gt; vs = tokenize(s,<span class="stringliteral">":"</span>);
        <span class="keywordflow">if</span> (vs.size() == 2) {
            <span class="keywordflow">if</span> (vs[0] == tok0) {
                string immed_str = vs[1];
                immed_val = convert_ascii_hex_to_int(immed_str.c_str());
                width_bits = static_cast&lt;unsigned int&gt;(immed_str.size()*4); <span class="comment">// nibbles to bits</span>
                valid = <span class="keyword">true</span>;
            }
        }
    }

    <span class="keywordtype">void</span>
    print(ostream&amp; o)<span class="keyword"> const </span>{
        o &lt;&lt; tok0 
          &lt;&lt; <span class="stringliteral">"("</span> ;
        <span class="keywordflow">if</span> (valid)  {
            <span class="comment">// not printing immed_val directly because VC98 (MSVS6) cannot print uint64's</span>
            <a class="code" href="unionxed__union64__t.html">xed_union64_t</a> u;
            u.<a class="code" href="unionxed__union64__t.html#8f015c9ecc53aa8403647aeeb3ed1830">u64</a> = immed_val;
            o &lt;&lt; std::hex;
            o &lt;&lt; setfill(<span class="charliteral">'0'</span>);
            o &lt;&lt; std::setw(8);
            o &lt;&lt; (int) u.<a class="code" href="unionxed__union64__t.html#3a76b2209bad9582ba15e13bd2a099c3">s</a>.<a class="code" href="unionxed__union64__t.html#c38b7f196348971a1e3e0604beb40aae">hi32</a>;
            o &lt;&lt; std::setw(8);
            o &lt;&lt; (int) u.<a class="code" href="unionxed__union64__t.html#3a76b2209bad9582ba15e13bd2a099c3">s</a>.<a class="code" href="unionxed__union64__t.html#438b85bc7debffb519238d60a1a9ac59">lo32</a>;
            o &lt;&lt; setfill(<span class="charliteral">' '</span>);
            o &lt;&lt; std::dec;
        }
        <span class="keywordflow">else</span> 
            o &lt;&lt; <span class="stringliteral">"???"</span>;
        o &lt;&lt; <span class="stringliteral">")"</span>;
    }

};

ostream&amp; operator&lt;&lt;(ostream&amp; o, <span class="keyword">const</span> immed_parser_t&amp; x) 
{
    x.print(o);
    <span class="keywordflow">return</span> o;
}


<span class="keyword">class </span>seg_parser_t
{
  <span class="keyword">public</span>:
    <a class="code" href="xed-types_8h.html#7b03cfdd50b61cf63f302db50d31b336">xed_bool_t</a> valid;
    <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edb">xed_reg_enum_t</a> segment_reg;
    string segment;
    <a class="code" href="xed-types_8h.html#4f6211e57e8a06c6ddde22f8c344ad7d">xed_uint_t</a> segno;

    seg_parser_t(<span class="keyword">const</span> string&amp; s) <span class="comment">// CONS</span>
        : valid(false),
          segment_reg(<a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edbfe8a716b1cbd2e63067d390f609b59f3">XED_REG_INVALID</a>),
          segno(0)
    {
        vector&lt;string&gt; vs = tokenize(s,<span class="stringliteral">":"</span>);
        <a class="code" href="xed-types_8h.html#4f6211e57e8a06c6ddde22f8c344ad7d">xed_uint_t</a> ntokens = static_cast&lt;xed_uint_t&gt;(vs.size());
<span class="preprocessor">#if 0</span>
<span class="preprocessor"></span>        cerr &lt;&lt; <span class="stringliteral">"ntokens "</span> &lt;&lt; ntokens &lt;&lt; <span class="stringliteral">": "</span> ;
        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;ntokens;i++) cerr  &lt;&lt; <span class="charliteral">'['</span> &lt;&lt; vs[i] &lt;&lt; <span class="stringliteral">"] "</span>;
        cerr &lt;&lt; endl;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        <span class="keywordflow">if</span> (ntokens == 2) {
            <span class="keywordflow">if</span> (vs[0] == <span class="stringliteral">"SEG"</span> || vs[0] == <span class="stringliteral">"SEG0"</span>) {
                segment = vs[1];
                segno = 0;
                segment_reg = <a class="code" href="xed-reg-enum_8h.html#370f75460cc8548e5d6fee562c3b70ce">str2xed_reg_enum_t</a>(segment.c_str());
                <span class="keywordflow">if</span> (segment_reg != <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edbfe8a716b1cbd2e63067d390f609b59f3">XED_REG_INVALID</a> &amp;&amp; <a class="code" href="group__REGINTFC.html#gb4258ece10211080e3d10c0144cada72">xed_reg_class</a>(segment_reg) == <a class="code" href="xed-reg-class-enum_8h.html#e0dcadcddc3924c2f24ed1bdecfb1656886d8bfc8819b5dcf31c4dca649ee483">XED_REG_CLASS_SR</a>) {
                    valid=<span class="keyword">true</span>;
                }
            }
            <span class="keywordflow">if</span> (vs[0] == <span class="stringliteral">"SEG1"</span>) {
                segment = vs[1];
                segno = 1;
                segment_reg = <a class="code" href="xed-reg-enum_8h.html#370f75460cc8548e5d6fee562c3b70ce">str2xed_reg_enum_t</a>(segment.c_str());
                <span class="keywordflow">if</span> (segment_reg != <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edbfe8a716b1cbd2e63067d390f609b59f3">XED_REG_INVALID</a> &amp;&amp; <a class="code" href="group__REGINTFC.html#gb4258ece10211080e3d10c0144cada72">xed_reg_class</a>(segment_reg) == <a class="code" href="xed-reg-class-enum_8h.html#e0dcadcddc3924c2f24ed1bdecfb1656886d8bfc8819b5dcf31c4dca649ee483">XED_REG_CLASS_SR</a>) {
                    valid=<span class="keyword">true</span>;
                }
            }
        }
    }

};

<span class="keyword">class </span>mem_bis_parser_t 
{
    <span class="comment">// parse: MEMlength:[segment:]base,index,scale[,displacement]</span>
    <span class="comment">// parse: AGEN:base,index,scale[,displacement]</span>
    <span class="comment">// The displacement is optional</span>


    <span class="comment">// split on colons first</span>
    <span class="comment">// MEM4:FS:EAX,EBX,4,223344   mem4 fs eax,ebx,4,22334455  -&gt; 3 tokens</span>
    <span class="comment">// MEM4:FS:EAX,EBX,4          mem4 fs eax,ebx,4   -&gt; 3 tokens</span>
    <span class="comment">// MEM4:EAX,EBX,4,223344      mem4 eax,ebx,4,223344..  -&gt; 2 tokens</span>
    <span class="comment">// MEM4:FS:EAX,EBX,4          mem4 fs  eas,ebx,4     -&gt; 3 tokens</span>

  <span class="keyword">public</span>:
    <a class="code" href="xed-types_8h.html#7b03cfdd50b61cf63f302db50d31b336">xed_bool_t</a> valid;
    <a class="code" href="xed-types_8h.html#7b03cfdd50b61cf63f302db50d31b336">xed_bool_t</a> mem;
    <a class="code" href="xed-types_8h.html#7b03cfdd50b61cf63f302db50d31b336">xed_bool_t</a> agen;
    <a class="code" href="xed-types_8h.html#7b03cfdd50b61cf63f302db50d31b336">xed_bool_t</a> disp_valid;
    string segment;
    string base;
    string index;
    string scale;
    string disp; <span class="comment">//displacement</span>
    <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edb">xed_reg_enum_t</a> segment_reg;
    <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edb">xed_reg_enum_t</a> base_reg;
    <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edb">xed_reg_enum_t</a> index_reg;
    xed_uint8_t scale_val;


    xed_int64_t disp_val;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> disp_width_bits;

    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mem_len;

    <span class="keywordtype">void</span>
    print(ostream&amp; o)<span class="keyword"> const </span>{
        <span class="keywordflow">if</span> (agen) 
            o &lt;&lt; <span class="stringliteral">"AGEN"</span>; 
        <span class="keywordflow">if</span> (mem) 
            o &lt;&lt; <span class="stringliteral">"MEM"</span>; 
        <span class="keywordflow">if</span> (mem_len) 
            o &lt;&lt; setw(1) &lt;&lt; mem_len;
        o &lt;&lt; <span class="stringliteral">"("</span>;
        <span class="keywordflow">if</span> (segment_reg != <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edbfe8a716b1cbd2e63067d390f609b59f3">XED_REG_INVALID</a>)
            o &lt;&lt; segment_reg &lt;&lt; <span class="stringliteral">":"</span>;
        o &lt;&lt; base_reg;
        o &lt;&lt; <span class="stringliteral">","</span> &lt;&lt; index_reg 
          &lt;&lt; <span class="stringliteral">","</span> 
          &lt;&lt; (<span class="keywordtype">unsigned</span> int) scale_val;
        <span class="keywordflow">if</span> (disp_valid) 
            o &lt;&lt;  <span class="stringliteral">","</span> &lt;&lt; disp;
        o &lt;&lt; <span class="stringliteral">")"</span>;
     
    }
  
    mem_bis_parser_t(<span class="keyword">const</span> string&amp; s) <span class="comment">//CONS</span>
        : valid(false),
          mem(false),
          agen(false),
          disp_valid(false),
          base(<span class="stringliteral">"INVALID"</span>),
          index(<span class="stringliteral">"INVALID"</span>),
          scale(<span class="stringliteral">"1"</span>),
          segment_reg(<a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edbfe8a716b1cbd2e63067d390f609b59f3">XED_REG_INVALID</a>),
          base_reg(<a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edbfe8a716b1cbd2e63067d390f609b59f3">XED_REG_INVALID</a>),
          index_reg(<a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edbfe8a716b1cbd2e63067d390f609b59f3">XED_REG_INVALID</a>),
          disp_val(0),
          disp_width_bits(0),
          mem_len(0)
    {
        string t = upcase(s);
        <span class="comment">// split on colon first</span>
        vector&lt;string&gt; vs = tokenize(t,<span class="stringliteral">":"</span>); 
        <a class="code" href="xed-types_8h.html#4f6211e57e8a06c6ddde22f8c344ad7d">xed_uint_t</a> ntokens = static_cast&lt;xed_uint_t&gt;(vs.size());
        vector&lt;string&gt; astr;
        <a class="code" href="xed-types_8h.html#4f6211e57e8a06c6ddde22f8c344ad7d">xed_uint_t</a> n_addr_tokens;
        string main_token, addr_token;
        
        <span class="keywordflow">if</span> (ntokens == 3) { <span class="comment">/* has a segment base */</span>
            main_token = vs[0];
            segment = vs[1];
            addr_token = vs[2];
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ntokens == 2) {
            main_token = vs[0];
            segment = <span class="stringliteral">"INVALID"</span>;
            addr_token = vs[1];
        }
        <span class="keywordflow">else</span> 
            <span class="keywordflow">return</span>;

        <span class="keywordflow">if</span> (main_token == <span class="stringliteral">"AGEN"</span>)
            agen=<span class="keyword">true</span>;
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (main_token.substr(0,3) == <span class="stringliteral">"MEM"</span>) {
            mem = <span class="keyword">true</span>;
            <span class="keywordflow">if</span> (main_token.size() &gt; 3) {
                string len = main_token.substr(3);
                mem_len = strtol(len.c_str(),0,0);
                <span class="comment">//printf("mem_len  = " XED_FMT_U "\n", mem_len);</span>
            }
        }
        <span class="keywordflow">else</span> 
            <span class="keywordflow">return</span>;

        <span class="keywordflow">if</span> (agen &amp;&amp; segment != <span class="stringliteral">"INVALID"</span>)
            xedex_derror(<span class="stringliteral">"AGENs cannot have segment overrides"</span>);

        astr = tokenize(addr_token,<span class="stringliteral">","</span>);
        n_addr_tokens = static_cast&lt;xed_uint_t&gt;(astr.size());
        <span class="keywordflow">if</span> (n_addr_tokens == 0 || n_addr_tokens &gt; 4)
            xedex_derror(<span class="stringliteral">"Bad addressing mode syntax for memop"</span>);

        base = astr[0];
        <span class="keywordflow">if</span> (base == <span class="stringliteral">"-"</span> || base == <span class="stringliteral">"NA"</span>) 
            base = <span class="stringliteral">"INVALID"</span>;

        <span class="keywordflow">if</span> (n_addr_tokens &gt; 2) 
            index = astr[1];
        <span class="keywordflow">if</span> (index == <span class="stringliteral">"-"</span> || index == <span class="stringliteral">"NA"</span>) 
            index = <span class="stringliteral">"INVALID"</span>;

        <span class="keywordflow">if</span> (n_addr_tokens &gt; 2) 
            scale = astr[2];
        <span class="keywordflow">if</span> (scale == <span class="stringliteral">"-"</span> || scale == <span class="stringliteral">"NA"</span>) 
            scale = <span class="stringliteral">"1"</span>;

        <span class="keywordflow">if</span> (scale == <span class="stringliteral">"1"</span> || scale == <span class="stringliteral">"2"</span> || scale == <span class="stringliteral">"4"</span> || scale == <span class="stringliteral">"8"</span>) {
            valid=<span class="keyword">true</span>;
            scale_val = <a class="code" href="xed-portability_8h.html#95bae36643a1c0231c14d638ff43100b">XED_STATIC_CAST</a>(xed_uint8_t,strtol(scale.c_str(), 0, 10));
            segment_reg = <a class="code" href="xed-reg-enum_8h.html#370f75460cc8548e5d6fee562c3b70ce">str2xed_reg_enum_t</a>(segment.c_str());
            base_reg = <a class="code" href="xed-reg-enum_8h.html#370f75460cc8548e5d6fee562c3b70ce">str2xed_reg_enum_t</a>(base.c_str());
            index_reg = <a class="code" href="xed-reg-enum_8h.html#370f75460cc8548e5d6fee562c3b70ce">str2xed_reg_enum_t</a>(index.c_str());

            <span class="comment">// look for a displacement</span>
            <span class="keywordflow">if</span> (n_addr_tokens == 4 &amp;&amp; astr[3] != <span class="stringliteral">"-"</span>) {
                disp = astr[3];
                disp_valid = <span class="keyword">true</span>;
                <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nibbles = <a class="code" href="xed-portability_8h.html#95bae36643a1c0231c14d638ff43100b">XED_STATIC_CAST</a>(<span class="keywordtype">int</span>,disp.size());
                <span class="keywordflow">if</span> (nibbles &amp; 1) {
                    <span class="comment">// ensure an even number of nibbles</span>
                    string zero(<span class="stringliteral">"0"</span>);
                    disp = zero + disp;
                    nibbles++;
                }
                disp_val = convert_ascii_hex_to_int(disp.c_str());
                disp_width_bits = nibbles*4; <span class="comment">// nibbles to bits</span>
            }
        }
    }
};

ostream&amp; operator&lt;&lt;(ostream&amp; o, <span class="keyword">const</span> mem_bis_parser_t&amp; x) {
  x.print(o);
  <span class="keywordflow">return</span> o;
}

<a class="code" href="group__ENC.html#gc19a60430b05a2baa08faeff10258cbe">xed_encoder_request_t</a> parse_encode_request(ascii_encode_request_t&amp; areq) {
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i;
    <a class="code" href="group__ENC.html#gc19a60430b05a2baa08faeff10258cbe">xed_encoder_request_t</a> req;
    <a class="code" href="group__ENC.html#g7cde0a73e3610011bd03517ab8d9452c">xed_encoder_request_zero_set_mode</a>(&amp;req,&amp;(areq.dstate)); <span class="comment">// calls xed_encoder_request_zero()</span>

    <span class="comment">/* This is the important function here. This encodes an instruction from scratch.</span>
<span class="comment">       </span>
<span class="comment">    You must set:</span>
<span class="comment">    the machine mode (machine width, addressing widths)</span>
<span class="comment">    the iclass</span>
<span class="comment">    for some instructions you need to specify prefixes (like REP or LOCK).</span>
<span class="comment">    the operands:</span>
<span class="comment">           operand kind (XED_OPERAND_{AGEN,MEM0,MEM1,IMM0,IMM1,RELBR,PTR,REG0...REG15}</span>
<span class="comment">           operand order </span>
<span class="comment">                    xed_encoder_request_set_operand_order(&amp;req,operand_index, XED_OPERAND_*);</span>
<span class="comment">                    where the operand_index is a sequential index starting at zero.</span>
<span class="comment"></span>
<span class="comment">           operand details </span>
<span class="comment">                     FOR MEMOPS: base,segment,index,scale,displacement for memops, </span>
<span class="comment">                  FOR REGISTERS: register name</span>
<span class="comment">                 FOR IMMEDIATES: immediate values</span>
<span class="comment">       </span>
<span class="comment">     */</span>
    

    vector&lt;string&gt; tokens = tokenize(areq.command,<span class="stringliteral">" "</span>);
    <span class="comment">// first token has the operand and our temporary hack for the immediate</span>

    string first, second;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> token_index = 0;

    <span class="keywordflow">while</span>(token_index &lt; tokens.size()) {
        slash_split(tokens[token_index], first, second);
        <span class="keywordflow">if</span> (CLIENT_VERBOSE3)
            printf( <span class="stringliteral">"[%s][%s][%s]\n"</span>, tokens[0].c_str(), first.c_str(), second.c_str());

        <span class="keywordflow">if</span> (token_index == 0 &amp;&amp; first == <span class="stringliteral">"REP"</span>) {
            <a class="code" href="group__ENC.html#g92571117c652c2355358ca4afd28c5b7">xed_encoder_request_set_rep</a>(&amp;req);
            token_index++;
            <span class="keywordflow">continue</span>;
        }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span> (token_index == 0 &amp;&amp; first == <span class="stringliteral">"REPNE"</span>) {
            <a class="code" href="group__ENC.html#g28ce8afadcfb592cfe3f36fa5d3fda91">xed_encoder_request_set_repne</a>(&amp;req);
            token_index++;
            <span class="keywordflow">continue</span>;
        }
  
        token_index++;
        <span class="keywordflow">break</span>;
    }

    <span class="comment">// we can attempt to override the mode </span>
    <span class="keywordflow">if</span> (second == <span class="stringliteral">"8"</span>) 
        <a class="code" href="group__ENC.html#gbb9a299f15575a822221b72f789ded7c">xed_encoder_request_set_effective_operand_width</a>(&amp;req, 8);
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (second == <span class="stringliteral">"16"</span>) 
        <a class="code" href="group__ENC.html#gbb9a299f15575a822221b72f789ded7c">xed_encoder_request_set_effective_operand_width</a>(&amp;req, 16);
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (second == <span class="stringliteral">"32"</span>) 
        <a class="code" href="group__ENC.html#gbb9a299f15575a822221b72f789ded7c">xed_encoder_request_set_effective_operand_width</a>(&amp;req, 32);
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (second == <span class="stringliteral">"64"</span>) 
        <a class="code" href="group__ENC.html#gbb9a299f15575a822221b72f789ded7c">xed_encoder_request_set_effective_operand_width</a>(&amp;req, 64);

    first = upcase(first);
    <a class="code" href="xed-iclass-enum_8h.html#aac14887efb58dc90badb71262573543">xed_iclass_enum_t</a> iclass =  <a class="code" href="xed-iclass-enum_8h.html#c78130f69f5ec4b898fc570ad8681c06">str2xed_iclass_enum_t</a>(first.c_str());
    <span class="keywordflow">if</span> (iclass == <a class="code" href="xed-iclass-enum_8h.html#aac14887efb58dc90badb712625735437fd4f674cd9733d91132080614f281fd">XED_ICLASS_INVALID</a>) {
        ostringstream os;
        os &lt;&lt; <span class="stringliteral">"Bad instruction name: "</span> &lt;&lt; first;
        xedex_derror(os.str().c_str());
    }
    <a class="code" href="group__ENC.html#g5c17ede76d6be221908d31b0377175cb">xed_encoder_request_set_iclass</a>(&amp;req, iclass );

    <a class="code" href="xed-types_8h.html#4f6211e57e8a06c6ddde22f8c344ad7d">xed_uint_t</a> memop = 0;
    <a class="code" href="xed-types_8h.html#4f6211e57e8a06c6ddde22f8c344ad7d">xed_uint_t</a> regnum = 0;
    <span class="comment">// put the operands in the request. Loop through tokens </span>
    <span class="comment">// (skip the opcode iclass, handled above)</span>
    <a class="code" href="xed-types_8h.html#4f6211e57e8a06c6ddde22f8c344ad7d">xed_uint_t</a> operand_index = 0;
    <span class="keywordflow">for</span>( i=token_index; i &lt; tokens.size(); i++, operand_index++ ) {
        string str_res_reg, second_x;
        slash_split(tokens[i], str_res_reg, second_x);
        str_res_reg = upcase(str_res_reg);
        <span class="comment">// prune the AGEN or MEM(base,index,scale[,displacement]) text from str_res_reg</span>
        <span class="comment">// FIXME: add MEM(immed) for the OC1_A and OC1_O types????</span>
        mem_bis_parser_t mem_bis(str_res_reg);
        <span class="keywordflow">if</span> (mem_bis.valid) {
            <span class="keywordflow">if</span> (mem_bis.mem) {
                <span class="keywordflow">if</span> (memop == 0) {
                    <span class="comment">// Tell XED that we have a memory operand</span>
                    <a class="code" href="group__ENC.html#g6a3d3301f69578aeccf29ce41eb89581">xed_encoder_request_set_mem0</a>(&amp;req);
                    <span class="comment">// Tell XED that the mem0 operand is the next operand:</span>
                    <a class="code" href="group__ENC.html#ga6ba83191291a42dbcf8519390ed354d">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a33b594d6f19eb9277ccce735c79fc2b28e">XED_OPERAND_MEM0</a>);
                }
                <span class="keywordflow">else</span> {
                    <a class="code" href="group__ENC.html#g98e04279fcc6a673ac8acd2c9b87e9ad">xed_encoder_request_set_mem1</a>(&amp;req);
                    <span class="comment">// Tell XED that the mem1 operand is the next operand:</span>
                    <a class="code" href="group__ENC.html#ga6ba83191291a42dbcf8519390ed354d">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a33556f96b12f59bf39bc02082da3a083a4">XED_OPERAND_MEM1</a>);
                }
                memop++;
            }
            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (mem_bis.agen) {
                <span class="comment">// Tell XED we have an AGEN</span>
                <a class="code" href="group__ENC.html#g052c0edd23cca8477a64ad864a188b09">xed_encoder_request_set_agen</a>(&amp;req);
                <span class="comment">// The AGEN is the next operand</span>
                <a class="code" href="group__ENC.html#ga6ba83191291a42dbcf8519390ed354d">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a3348110e0aa58fa1830b3ded9a3ff0e432">XED_OPERAND_AGEN</a>);
            }
            <span class="keywordflow">else</span> 
                assert(mem_bis.agen || mem_bis.mem);

            <a class="code" href="xed-reg-class-enum_8h.html#e0dcadcddc3924c2f24ed1bdecfb1656">xed_reg_class_enum_t</a> rc = <a class="code" href="group__REGINTFC.html#g00e9543720afdd94cf3e5812dafbf69c">xed_gpr_reg_class</a>(mem_bis.base_reg);
            <a class="code" href="xed-reg-class-enum_8h.html#e0dcadcddc3924c2f24ed1bdecfb1656">xed_reg_class_enum_t</a> rci = <a class="code" href="group__REGINTFC.html#g00e9543720afdd94cf3e5812dafbf69c">xed_gpr_reg_class</a>(mem_bis.index_reg);
<span class="preprocessor">#if 0</span>
<span class="preprocessor"></span>            <span class="keywordflow">if</span> (mem_bis.base_reg != <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edbfe8a716b1cbd2e63067d390f609b59f3">XED_REG_INVALID</a> &amp;&amp; mem_bis.index_reg != <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edbfe8a716b1cbd2e63067d390f609b59f3">XED_REG_INVALID</a>) 
                <span class="keywordflow">if</span> (rc != rci) {
                    ostringstream os;
                    os &lt;&lt; <span class="stringliteral">"The base and index regs do not agree on the address size"</span> &lt;&lt; endl;
                    xedex_derror(os.str().c_str()); <span class="comment">// dies</span>
                }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>            
            <span class="keywordflow">if</span> (rc == <a class="code" href="xed-reg-class-enum_8h.html#e0dcadcddc3924c2f24ed1bdecfb1656cfaf8993373961579f696490a19e2c08">XED_REG_CLASS_GPR32</a> || rci == <a class="code" href="xed-reg-class-enum_8h.html#e0dcadcddc3924c2f24ed1bdecfb1656cfaf8993373961579f696490a19e2c08">XED_REG_CLASS_GPR32</a>) 
                <a class="code" href="group__ENC.html#gb1f00cc9c14a22f097c6f0cd1e7a1989">xed_encoder_request_set_effective_address_size</a>(&amp;req, 32);
            <span class="keywordflow">if</span> (rc == <a class="code" href="xed-reg-class-enum_8h.html#e0dcadcddc3924c2f24ed1bdecfb16569c2a8ca6da2d355527a32d0ad7f46dc3">XED_REG_CLASS_GPR16</a> || rci == <a class="code" href="xed-reg-class-enum_8h.html#e0dcadcddc3924c2f24ed1bdecfb16569c2a8ca6da2d355527a32d0ad7f46dc3">XED_REG_CLASS_GPR16</a>) 
                <a class="code" href="group__ENC.html#gb1f00cc9c14a22f097c6f0cd1e7a1989">xed_encoder_request_set_effective_address_size</a>(&amp;req, 16);

            <span class="comment">// fill in the memory fields</span>
            <a class="code" href="group__ENC.html#gdd28aa6759b1dfd5090a8ebc2f151a57">xed_encoder_request_set_base0</a>(&amp;req, mem_bis.base_reg);
            <a class="code" href="group__ENC.html#g5947798ae78f68147ac18a124a498b4d">xed_encoder_request_set_index</a>(&amp;req, mem_bis.index_reg);
            <a class="code" href="group__ENC.html#g911336fccdb9a2be3c1c196af147d936">xed_encoder_request_set_scale</a>(&amp;req, mem_bis.scale_val);
            <a class="code" href="group__ENC.html#ge4493ae0364f81df78b0d7ee81fdd825">xed_encoder_request_set_seg0</a>(&amp;req, mem_bis.segment_reg);

            <span class="keywordflow">if</span> (mem_bis.mem_len) 
                <a class="code" href="group__ENC.html#ga2da5dd30cfc101e8fcff373cee5c31c">xed_encoder_request_set_memory_operand_length</a>(&amp;req, mem_bis.mem_len ); <span class="comment">// BYTES</span>
            <span class="keywordflow">if</span> (mem_bis.disp_valid)
                <a class="code" href="group__ENC.html#gfc895f1a46482aa3aadd42c2e2e2e0ba">xed_encoder_request_set_memory_displacement</a>(&amp;req,
                                                            mem_bis.disp_val,
                                                            mem_bis.disp_width_bits/8);
            <span class="keywordflow">continue</span>;
        }

        seg_parser_t seg_parser(str_res_reg);
        <span class="keywordflow">if</span> (seg_parser.valid) {
            <span class="keywordflow">if</span> (CLIENT_VERBOSE3) 
                printf(<span class="stringliteral">"Setting segment to %s\n"</span>, <a class="code" href="xed-reg-enum_8h.html#56cacf198a8c0ff596beda0cd37ce39d">xed_reg_enum_t2str</a>(seg_parser.segment_reg));
            <span class="keywordflow">if</span> (seg_parser.segno == 0)
                <a class="code" href="group__ENC.html#ge4493ae0364f81df78b0d7ee81fdd825">xed_encoder_request_set_seg0</a>(&amp;req, seg_parser.segment_reg);
            <span class="keywordflow">else</span>
                <span class="comment">/*  need SEG1 for MOVS[BWDQ]*/</span>
                <a class="code" href="group__ENC.html#g4884803c77238976a27949f7cd0c7e8c">xed_encoder_request_set_seg1</a>(&amp;req, seg_parser.segment_reg);

            <span class="comment">/* SEG/SEG0/SEG1 is NOT a normal operand. It is a setting, like</span>
<span class="comment">             * the lock prefix. Normally the segment will be specified with</span>
<span class="comment">             * normal memory operations. With memops without MODRM, or</span>
<span class="comment">             * impliclit memops, we need a way of specifying the segment</span>
<span class="comment">             * when it is not the default. This is the way. it does not</span>
<span class="comment">             * change encoding forms. (When segments are "moved", they are</span>
<span class="comment">             * REG operands, not SEG0/1, and are specified by name like EAX</span>
<span class="comment">             * is.) */</span>
            <span class="keywordflow">continue</span>;
        }

        immed_parser_t imm(str_res_reg, <span class="stringliteral">"IMM"</span>);
        <span class="keywordflow">if</span> (imm.valid) {
            <span class="keywordflow">if</span> (CLIENT_VERBOSE3) 
                printf(<span class="stringliteral">"Setting immediate value to "</span> <a class="code" href="xed-portability_8h.html#0a9d7f95b66014f70a711ea0558c2a19">XED_FMT_LX</a> <span class="stringliteral">"\n"</span>, imm.immed_val);
            <a class="code" href="group__ENC.html#g46d1e3977be45ebd03640af578564c05">xed_encoder_request_set_uimm0_bits</a>(&amp;req, 
                                               imm.immed_val,
                                               imm.width_bits);
            <a class="code" href="group__ENC.html#ga6ba83191291a42dbcf8519390ed354d">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a3300f3a04470e3ae430e375dedb6b4d4ec">XED_OPERAND_IMM0</a>);
            <span class="keywordflow">continue</span>;
        }
        immed_parser_t simm(str_res_reg, <span class="stringliteral">"SIMM"</span>);
        <span class="keywordflow">if</span> (simm.valid) {
            <span class="keywordflow">if</span> (CLIENT_VERBOSE3) 
                printf(<span class="stringliteral">"Setting immediate value to "</span> <a class="code" href="xed-portability_8h.html#0a9d7f95b66014f70a711ea0558c2a19">XED_FMT_LX</a> <span class="stringliteral">"\n"</span>, simm.immed_val);
            <a class="code" href="group__ENC.html#gc88b64f03506a5754924023cf587fece">xed_encoder_request_set_simm</a>(&amp;req, 
                                         <a class="code" href="xed-portability_8h.html#95bae36643a1c0231c14d638ff43100b">XED_STATIC_CAST</a>(xed_int32_t,simm.immed_val),
                                         simm.width_bits/8); <span class="comment">//FIXME</span>
            <a class="code" href="group__ENC.html#ga6ba83191291a42dbcf8519390ed354d">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a3300f3a04470e3ae430e375dedb6b4d4ec">XED_OPERAND_IMM0</a>);
            <span class="keywordflow">continue</span>;
        }
        immed_parser_t imm2(str_res_reg, <span class="stringliteral">"IMM2"</span>);
        <span class="keywordflow">if</span> (imm2.valid) {
            <span class="keywordflow">if</span> (imm2.width_bits != 8)
                xedex_derror(<span class="stringliteral">"2nd immediate must be just 1 byte long"</span>);
            <a class="code" href="group__ENC.html#g1dc8415f72d7a4e4a179cf56c98a97e3">xed_encoder_request_set_uimm1</a>(&amp;req, imm2.immed_val);
            <a class="code" href="group__ENC.html#ga6ba83191291a42dbcf8519390ed354d">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a33f5f6a168c4a1b3e53773a38f7f052f11">XED_OPERAND_IMM1</a>);
            <span class="keywordflow">continue</span>;
        }

        immed_parser_t disp(str_res_reg, <span class="stringliteral">"BRDISP"</span>);
        <span class="keywordflow">if</span> (disp.valid) {
            <span class="keywordflow">if</span> (CLIENT_VERBOSE3) 
                printf(<span class="stringliteral">"Setting  displacement value to "</span> <a class="code" href="xed-portability_8h.html#0a9d7f95b66014f70a711ea0558c2a19">XED_FMT_LX</a> <span class="stringliteral">"\n"</span>, disp.immed_val);
            <a class="code" href="group__ENC.html#g51e07e8ec4e2b329e5db4fd34cebd382">xed_encoder_request_set_branch_displacement</a>(&amp;req,
                                                        <a class="code" href="xed-portability_8h.html#95bae36643a1c0231c14d638ff43100b">XED_STATIC_CAST</a>(xed_uint32_t,disp.immed_val),
                                                        disp.width_bits/8); <span class="comment">//FIXME</span>
            <a class="code" href="group__ENC.html#ga6ba83191291a42dbcf8519390ed354d">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a336eeab62720e3ae7f7d53a32cafbb1bc0">XED_OPERAND_RELBR</a>);
            <a class="code" href="group__ENC.html#g1b1eb97c09170002eaa290aa9c4ca005">xed_encoder_request_set_relbr</a>(&amp;req);
            <span class="keywordflow">continue</span>;
        }

        immed_parser_t ptr_disp(str_res_reg, <span class="stringliteral">"PTR"</span>);
        <span class="keywordflow">if</span> (ptr_disp.valid) {
            <span class="keywordflow">if</span> (CLIENT_VERBOSE3) 
                printf(<span class="stringliteral">"Setting pointer displacement value to "</span> <a class="code" href="xed-portability_8h.html#0a9d7f95b66014f70a711ea0558c2a19">XED_FMT_LX</a> <span class="stringliteral">"\n"</span>, ptr_disp.immed_val);
            <a class="code" href="group__ENC.html#g51e07e8ec4e2b329e5db4fd34cebd382">xed_encoder_request_set_branch_displacement</a>(&amp;req,
                                                        <a class="code" href="xed-portability_8h.html#95bae36643a1c0231c14d638ff43100b">XED_STATIC_CAST</a>(xed_uint32_t,ptr_disp.immed_val),
                                                        ptr_disp.width_bits/8); <span class="comment">//FIXME</span>
            <a class="code" href="group__ENC.html#ga6ba83191291a42dbcf8519390ed354d">xed_encoder_request_set_operand_order</a>(&amp;req,operand_index, <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a337b6a7827f66e7f32d2fe9227e58820cf">XED_OPERAND_PTR</a>);
            <a class="code" href="group__ENC.html#gf1e5d909590a0e6010595dedd9ed05ad">xed_encoder_request_set_ptr</a>(&amp;req);
            <span class="keywordflow">continue</span>;
        }

        <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edb">xed_reg_enum_t</a> reg = <a class="code" href="xed-reg-enum_8h.html#370f75460cc8548e5d6fee562c3b70ce">str2xed_reg_enum_t</a>(str_res_reg.c_str());
        <span class="keywordflow">if</span> (reg == <a class="code" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edbfe8a716b1cbd2e63067d390f609b59f3">XED_REG_INVALID</a>) {
            ostringstream os;
            os &lt;&lt; <span class="stringliteral">"Bad register name: "</span> &lt;&lt; str_res_reg &lt;&lt; <span class="stringliteral">" on operand "</span> &lt;&lt; i;
            xedex_derror(os.str().c_str()); <span class="comment">// dies</span>
        }
        <span class="comment">// The registers operands aer numbered starting from the first one</span>
        <span class="comment">// as XED_OPERAND_REG0. We incremenet regnum (below) every time we add a</span>
        <span class="comment">// register operands.</span>
        <a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a33">xed_operand_enum_t</a> r = <a class="code" href="xed-portability_8h.html#95bae36643a1c0231c14d638ff43100b">XED_STATIC_CAST</a>(<a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a33">xed_operand_enum_t</a>,<a class="code" href="xed-operand-enum_8h.html#b30d7e8aa0f4b2a0b18bb1655c3d2a3304d716e747292fdf8bacd58d3c7ffe4c">XED_OPERAND_REG0</a> + regnum);
        <span class="comment">// store the register identifer in the operand storage field</span>
        <a class="code" href="group__ENC.html#g0b32708e3be77ac90334b107940548a7">xed_encoder_request_set_reg</a>(&amp;req, r, reg);
        <span class="comment">// store the operand storage field name in the encode-order array</span>
        <a class="code" href="group__ENC.html#ga6ba83191291a42dbcf8519390ed354d">xed_encoder_request_set_operand_order</a>(&amp;req, operand_index, r);
        regnum++;
    } <span class="comment">// for loop</span>

    <span class="keywordflow">return</span> req;
}
</pre></div> <hr size="1"><address style="align: right;"><small>Generated on Fri Oct 22 02:28:20 2010 for XED2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
