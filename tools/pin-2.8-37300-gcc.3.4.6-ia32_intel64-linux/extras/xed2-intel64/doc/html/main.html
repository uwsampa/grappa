<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>XED2: XED2 User Guide - Fri Oct 22 02:28:19 2010 </title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.6 -->
<div class="tabs">
  <ul>
    <li id="current"><a href="main.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li>
      <form action="search.php" method="get">
        <table cellspacing="0" cellpadding="0" border="0">
          <tr>
            <td><label>&nbsp;<u>S</u>earch&nbsp;for&nbsp;</label></td>
            <td><input type="text" name="query" value="" size="20" accesskey="s"/></td>
          </tr>
        </table>
      </form>
    </li>
  </ul></div>
<h1>XED2 User Guide</h1>
<p>
by Mark Charney<p>
<dl compact><dt><b>Id</b></dt><dd>xed-doc-top.txt 2531 2010-09-16 19:24:46Z mjcharne </dd></dl>
<p>
======================================================================================== <h2><a class="anchor" name="INTRO">
Introduction</a></h2>
========================================================================================<p>
XED is an acronym for X86 Encoder Decoder. It is pronounced like the (British) English "z". XED2 is the current implementation of XED, in C. (XED0 is written in C++).<p>
XED is a software library (and associated headers) for encoding and decoding X86 (IA-32 instruction set and Intel&reg; 64 instruction set) instructions. The decoder takes sequences of 1-15 bytes along with machine mode information and produces a data structure describing the opcode and operands, and flags. The encoder takes a similar data structure and produces a sequence of 1 to 15 bytes. XED is multi-thread safe.<p>
XED was designed to be very fast and extensible.<p>
XED compiles with the following compilers:<p>
<ol type=1>
<li>GNU gcc 2.96, 3.2.x, 3.3.x, 3.4.x, 4.1,x 4.2.x, 4.3.x</li><li>Microsoft Visual C++ 6 (VC98), Visual Studio 7 (.NET 2003), VS8 (Professional 2005), and VS9 (Professional 2008)</li><li>Intel ICL/ICC 7.1,8.x 9.x and 10</li></ol>
<p>
XED works with the following operating systems:<p>
<ol type=1>
<li>Linux, various flavors</li><li>Microsoft Windows (with and without cygwin)</li><li>Apple Mac OS* X</li><li>FreeBSD</li></ol>
<p>
The XED examples (<a class="el" href="group__EXAMPLES.html">Examples of using XED</a>) also include binary image readers for Windows PECOFF, ELF and Mac OS* X MACHO binary file formats for 32b and 64b. These allow XED to be used as a simple (not symbolic) disassembler. The XED disassembler supports 3 output formats: Intel, ATT SYSV, and a more detailed internal format describing all resources read and written.<p>
========================================================================================<p>
Table of Contents<ul>
<li><a class="el" href="main.html#BUILD">Building</a> Building your program with XED</li><li><a class="el" href="main.html#TERMS">Terms</a> Terminology</li><li><a class="el" href="main.html#OVERVIEW">Overview</a> Overview of the XED approach</li><li><a class="el" href="main.html#API_REF">API reference</a> Detailed descriptions of the API</li><li><a class="el" href="group__EXAMPLES.html">Examples</a> Examples</li><li><a class="el" href="main.html#FEEDBACK">Feedback</a> Questions? Bugs?</li><li><a class="el" href="main.html#LEGAL">Disclaimer and Legal Information</a></li></ul>
<p>
======================================================================================== <h2><a class="anchor" name="BUILD">
Building your program using XED.</a></h2>
========================================================================================<p>
This section describes the requirements for compiling with XED and linking the libxed.a library. It assumes you are building from a XED kit, and not directly from the sources. (See the "install" option in the XED build manual for information on making kits).<p>
The structure of a XED2 kit is as follows: <div class="fragment"><pre class="fragment">                              |-bin------
                              |-doc------|-html-
                              |-examples-
               |-xed-kit-name-|-include--
                              |-lib------
                              |-misc-----
</pre></div><p>
To use XED your sources should include the top-most header file: xed-interface.h.<p>
Your compilation statement must include: <div class="fragment"><pre class="fragment">    -Ixed-kit-name/include
</pre></div> where "xed-kit-name" is the place you've unpacked the XED kit.<p>
Your Linux or Mac OS* X link statement must reference the libxed library: <div class="fragment"><pre class="fragment">    -lxed-kit-name/lib/libxed.a
</pre></div><p>
(or link against libxed.lib for Windows).<p>
XED uses base types with the following names: xed_uint8_t, xed_uint16_t, xed_uint32_t, xed_uint64_t xed_int8_t, xed_int16_t, xed_int32_t, and xed_int64_t. XED also defines a "xed_uint_t" type that is shorthand for "unsigned int".<p>
Please see the section <a class="el" href="group__INIT.html">XED initialization</a> for more information about using XED, and also the examples in <a class="el" href="group__EXAMPLES.html">Examples of using XED</a>.<p>
======================================================================================== <h2><a class="anchor" name="TERMS">
Terminology</a></h2>
========================================================================================<p>
X86 instructions are 1-15 byte values. They consist of several well defined components that total at most 15 bytes:<p>
<ol type=1>
<li>legacy prefix bytes. Used for many purposes.</li><li>REX prefix byte. Only in 64b mode. It has 4 1-bit fields: W, R, X, and B. The W bit modifies the operation width. The R, X and B fields extend the register encodings.</li><li>1-2 opcode bytes</li><li>MODRM byte. Used for addressing memory, refining opcodes, specifying registers. Optional, but common. It has 3 fields: the 2-bit mod, the 3-bit reg and 3-bit "r/m" fields.</li><li>SIB byte. Used for specifying memory addressing, optional. It has 3 fields: the 2-bit scale, 3-bit index and 3-bit base.</li><li>Displacement bytes. Used for specifying memory offsets, optional.</li><li>Immediate bytes. Optional</li></ol>
<p>
One specific opcode byte is used as an 'escape' to indicate that two opcode bytes are required. All two-byte opcodes have this escape as their first opcode byte.<p>
Immediates and displacements are usually limited to 4 bytes, but there are several variants of the MOV instruction that can take 8B values. The AMD 3DNow ISA extension uses the immediate field to provide additional opcode information.<p>
The encodings are very byte-oriented. Bit-fields in the REX, opcode, MODRM and SIB bytes are simple and self-contained.<p>
The legacy prefix bytes are used for:<p>
<ol type=1>
<li>operand size overrides (1 prefix),</li><li>address size overrides (1 prefix),</li><li>atomic locking (1 prefix),</li><li>default segment overrides (6 prefixes),</li><li>repeating certain instructions (2 prefixes), and</li><li>opcode refinement.</li></ol>
<p>
There are 11 distinct legacy prefixes. Three of them (operand size, and the two repeat prefixes) have different meanings in different contexts; Sometimes they are used for opcode refinement and do not have their default meaning. Less frequently. two of the segment overrides can be used for conditional branch hints.<p>
There are also multiple ways to encode certain instructions, with the same or differing length.<p>
======================================================================================== <h2><a class="anchor" name="OVERVIEW">
Overview of XED approach</a></h2>
========================================================================================<p>
XED has two fundamental interfaces: encoding and decoding. Supporting these interfaces are many data structures, but the two starting points are the <a class="el" href="group__ENC.html#gc19a60430b05a2baa08faeff10258cbe">xed_encoder_request_t</a> and the <a class="el" href="group__DEC.html#g3ffbd4a72c68c7e8b96ebb03a6719735">xed_decoded_inst_t</a> . The <a class="el" href="group__DEC.html#g3ffbd4a72c68c7e8b96ebb03a6719735">xed_decoded_inst_t</a> has more information than the <a class="el" href="group__ENC.html#gc19a60430b05a2baa08faeff10258cbe">xed_encoder_request_t</a> , but both types are derived from a set of common fields called the <a class="el" href="xed-operand-storage_8h.html#dd3db22cd2c259d5fca4660bfa16fbd4">xed_operand_values_t</a>.<p>
The output of the decoder, the <a class="el" href="group__DEC.html#g3ffbd4a72c68c7e8b96ebb03a6719735">xed_decoded_inst_t</a> , includes additional information that is not required for encoding, but provides more information about the instruction resources.<p>
The common operand fields, used by both the encoder and decoder, hold the operands and the memory addressing information.<p>
The decoder has an operands array that holds order of the decoded operands. This array indicates whether or not the operands are read or written.<p>
The encoder has an operand array where the encoder user must specify the order of the operands used for encoding.<p>
======================================================================================== <h2><a class="anchor" name="ICLASS">
Instruction classes</a></h2>
The <a class="el" href="xed-iclass-enum_8h.html#aac14887efb58dc90badb71262573543">xed_iclass_enum_t</a> class describes the instruction names. The names are (mostly) taken from the Intel manual, with exceptions only for certain ambiguities. This is what is typically thought of as the instruction mnemonic. Note, XED does not typically distinguish instructions based on width unless the ISA manuals do so as well. For example, <a class="el" href="xed-iclass-enum_8h.html#aac14887efb58dc90badb71262573543">xed_iclass_enum_t</a>'s are not suffixed with "w", "l" or "q" typically. There are instructions whose <a class="el" href="xed-iclass-enum_8h.html#aac14887efb58dc90badb71262573543">xed_iclass_enum_t</a> ends in a "B" or a "Q" (including all byte operations and certain string operations) and those names are preserved as described in the Intel programmers' reference manuals.<h3><a class="anchor" name="SPECIAL">
Special Cases</a></h3>
There are many special cases that must be accounted for in attempting to handle all the nuances of the ISA. This is an attempt to explain the nonstandard handling of certain instruction names.<p>
The FAR versions of 3 opcodes (really 6 distinct opcodes) are given the opcode names CALL_FAR, JMP_FAR and RET_FAR. The AMD documentation lists the far return as RETF. I call that RET_FAR to be consistent with the other far operations.<p>
To distinguish the SSE2 MOVSD instruction from the base string instruction MOVSD, XED calls the SSE version MOVSD_XMM.<h3><a class="anchor" name="NOPs">
NOPs</a></h3>
NOPs are very special. XED allows for encoding NOPs of 1 to 9 bytes through the use of the XED_ICLASS_NOP (the one byte nop), and XED_ICLASS_NOP2 ... XED_ICLASS_NOP9. These use the recommended NOP sequences from the Intel Software Developers Manual.<p>
The instruction 0x90 is very special in the instruction set because it gets special treatment in 64b mode. In 64b mode, 32b register writes normally zero the upper 32 bits of a 64b register. No so for 0x90. If it did zero the upper 32 bits, it would not be a NOP.<p>
There are two important NOP categories. XED_CATEGORY_NOP and XED_CATEGORY_WIDENOP. The XED_CATEGORY_NOP applies only to the 0x90 opcode. The WIDENOP category applies to the NOPs in the two byte table row 0F19...0F1F. The WIDENOPs take MODRM bytes, and optional SIB and displacements.<p>
======================================================================================== <h2><a class="anchor" name="X86-OPERANDS">
Operands</a></h2>
XED uses the operand order documented in the Intel Programmers' Reference Manual. In most cases, the first operand is a source and destination (read and written) and the second operand is just a source (read).<p>
For decode requests (<a class="el" href="group__DEC.html#g3ffbd4a72c68c7e8b96ebb03a6719735">xed_decoded_inst_t</a>), the operands array is stored in the <a class="el" href="group__DEC.html#g71deffb45370b3b2b4a34ee96ca5fb04">xed_inst_t</a> strcture once the instruction is decoded. For encode requests, the request's operand order is stored in the <a class="el" href="group__ENC.html#gc19a60430b05a2baa08faeff10258cbe">xed_encoder_request_t</a>.<p>
There are several types of operands:<ol type=1>
<li>registers (<a class="el" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edb">xed_reg_enum_t</a>)</li><li>branch displacements</li><li>memory operations (which include base, index, segment and memory displacements)</li><li>immediates</li><li>pseudo resources (which are listed in the <a class="el" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edb">xed_reg_enum_t</a>)</li></ol>
<p>
Each operand has two associated attributes: the R/W action and a visibility. The R/W actions (<a class="el" href="xed-operand-action-enum_8h.html#74cb0ca950489db6e36b1e621c17f951">xed_operand_action_enum_t</a>) indicate whether the operand is read, written or both read-and-written, or conditionally read or written. The visibility attribute (<a class="el" href="xed-operand-visibility-enum_8h.html#a2939a218010ac9d4dc45ecf92b05658">xed_operand_visibility_enum_t</a>) is described in the next subsection.<p>
The memory operation operand is really a pointer to separate fields that hold the memory operation information. The memory operation information is comprised of:<ol type=1>
<li>a segment register</li><li>a base register</li><li>an index register</li><li>a displacement</li></ol>
<p>
There are several important things to note:<ol type=1>
<li>There can only be two memory operations, MEM0 and MEM1.</li><li>MEM0 could also be an AGEN -- a special operand that uses memory information but does not actually read memory. This is only used for the LEA instruction.</li><li>There can only be an index and displacement associated with MEM0.</li><li>There is just one displacement associated with the common fields. It could be associated with either the AGEN/MEM0 or with a branch or call instruction.</li></ol>
<h3><a class="anchor" name="OPERAND_VISIBILITY">
Operand Resource Visibilities</a></h3>
See <a class="el" href="xed-operand-visibility-enum_8h.html#a2939a218010ac9d4dc45ecf92b05658">xed_operand_visibility_enum_t</a> .<p>
There are 3 basic types of resource visibilites:<ol type=1>
<li>EXPLICIT (EXPL),</li><li>IMPLICIT (IMPL), and</li><li>IMPLICIT SUPPRESSED (SUPP) (usually referred to as just "SUPPRESSED").</li></ol>
<p>
Explicit are what you think they are: resources that are required for the encoding and for each explicit resource, there is field in the corresponding instruction encoding. The implicit and suppressed resources are a more subtle.<p>
SUPP operands are:<ol type=1>
<li>not used in picking an encoding,</li><li>not printed in disassembly,</li><li>not represented using operand bits in the encoding.</li></ol>
<p>
IMPL operands are:<ol type=1>
<li>used in picking an encoding,</li><li>expressed in disassembly, and</li><li>not represented using operand bits in the encoding (like SUPP).</li></ol>
<p>
The implicit resources are required for selecting an encoding, but do not show up as a specific field in the instruction representation. Implicit resources do show up in a conventional instruction disassembly. In the IA-32 instruction set or Intel64 instruction set, there are many instructions that use EAX or RAX implicitly, for example. Sometimes the CL or RCX register is implicit. Also, some instructions have an implicit 1 immediate. The opcode you chose fixes your choice of implicit register or immediate.<p>
The suppressed resources are a form of implicit resource, but they are resources not required for encoding. The suppressed operands are not normally displayed in a conventional disassembly. The suppressed operands are emitted by the decoder but are not used when encoding. They are ignored by the encoder. Examples are the stack pointer for PUSH and POP operations. There are many others, like pseudo resources.<p>
The explicit and implicit resources are expressed resources -- they show up in disassembly and are required for encoding. The suppressed resources are considered a kind of implicit resources that are not expressed in ATT System V or Intel disassembly formats.<p>
The suppressed operands are always after the implicit and explicit operands in the operand order.<h3><a class="anchor" name="PSEUDO_RESOURCES">
Pseudo Resources</a></h3>
Some instructions reference machine registers or perform interesting operations that we need to represent. For example, the IDTR and GDTR are represented as pseudo resources. Operations that pop the x87 floating point register stack can have a X87POP or X87POP2 "register" to indicate if the x87 register stack is popped once or twice. These are part of the <a class="el" href="xed-reg-enum_8h.html#013dd4ba3d251f96c635b7df4eec4edb">xed_reg_enum_t</a>.<h3><a class="anchor" name="IMM_DIS">
Immediates and Displacements</a></h3>
Using the API functions for setting immediates, memory displacements and branch displacements. Immediates and Displacements are stored in normal integers internally, but they are stored endian swapped and left justified. The API functions take care of all the endian swapping and positioning so you don't have to worry about that detail.<p>
Immediates and displacements are different things in the ISA. They can be 1, 2, 4 or 8 bytes. Branch displacements (1, 2 or 4 bytes) and Memory displacements (1, 2, 4 or 8 bytes) refer to the signed constants that are used for relative distances or memory "offsets" from a base register (including the instruction pointer) or start of a memory region.<p>
Immediates are signed or unsigned and are used for numerical computations, shift distances, and also hold things like segment selectors for far pointers for certain jump or call instructions.<p>
There is also a second 1B immedate used only for the ENTER instruction.<p>
XED will try to use the shortest allowed width for a displacement or immediate. You can control XED's selection of allowed widths using a notion of "legal widths". A "legal width" is a binary number where each bit represents a legal desired width. For example, when you have a valid base register in 32 or 64b addressing, and a displacement is required, your displacement must be either 1 byte or 4 bytes long. This is expressed by OR'ing 1 and 4 together to get 0101 (base 2) or 5 (base 10).<p>
If a four byte displacement was required, but the value was representable in fewer than four bytes, then the legal width should be set to 0100 (base 2) or 4 (base 10).<p>
======================================================================================== <h2><a class="anchor" name="API_REF">
API Reference</a></h2>
========================================================================================<p>
<ul>
<li><a class="el" href="group__INIT.html">INIT</a> Initialization</li><li><a class="el" href="group__DEC.html">DEC</a> Decoding instructions</li><li><a class="el" href="group__DECODE__CACHE.html">DECODE_CACHE</a> Using the decode cache</li><li><a class="el" href="group__ENC.html">ENC</a> Encoding instructions</li><li><a class="el" href="group__ENCHL.html">ENCHL</a> High level API for encoding instructions</li><li><a class="el" href="group__OPERANDS.html">OPERANDS</a> Operand storage fields</li><li><a class="el" href="group__IFORM.html">IFORM</a> Iforms</li><li><a class="el" href="group__PRINT.html">PRINT</a> Printing (disassembling) instructions</li><li><a class="el" href="group__REGINTFC.html">REGINTFC</a> Register interface functions</li><li><a class="el" href="group__FLAGS.html">FLAGS</a> Flags interface functions</li><li><a class="el" href="group__AGEN.html">AGEN</a> Address generation calculation support</li><li><a class="el" href="group__EXAMPLES.html">Examples</a> Examples</li></ul>
<p>
======================================================================================== <h2><a class="anchor" name="FEEDBACK">
Questions? Bugs?</a></h2>
========================================================================================<p>
Send bugs and questions to <a href="mailto:mark.charney@intel.com">mark.charney@intel.com</a>. Complete bug reports that are easy to reproduce are fixed faster, so try to provide as much information as possible. Include: kit number, your OS version, compiler version. Try to reproduce the problem in a simple example that you can send us.<p>
======================================================================================== <h2><a class="anchor" name="LEGAL">
Disclaimer and Legal Information</a></h2>
========================================================================================<p>
The information in this manual is subject to change without notice and Intel Corporation assumes no responsibility or liability for any errors or inaccuracies that may appear in this document or any software that may be provided in association with this document. This document and the software described in it are furnished under license and may only be used or copied in accordance with the terms of the license. No license, express or implied, by estoppel or otherwise, to any intellectual property rights is granted by this document. The information in this document is provided in connection with Intel products and should not be construed as a commitment by Intel Corporation.<p>
EXCEPT AS PROVIDED IN INTEL'S TERMS AND CONDITIONS OF SALE FOR SUCH PRODUCTS, INTEL ASSUMES NO LIABILITY WHATSOEVER, AND INTEL DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY, RELATING TO SALE AND/OR USE OF INTEL PRODUCTS INCLUDING LIABILITY OR WARRANTIES RELATING TO FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, OR INFRINGEMENT OF ANY PATENT, COPYRIGHT OR OTHER INTELLECTUAL PROPERTY RIGHT. Intel products are not intended for use in medical, life saving, life sustaining, critical control or safety systems, or in nuclear facility applications.<p>
Designers must not rely on the absence or characteristics of any features or instructions marked "reserved" or "undefined." Intel reserves these for future definition and shall have no responsibility whatsoever for conflicts or incompat- ibilities arising from future changes to them.<p>
The software described in this document may contain software defects which may cause the product to deviate from published specifications. Current characterized software defects are available on request.<p>
Intel, the Intel logo, Intel SpeedStep, Intel NetBurst, Intel NetStructure, MMX, Intel386, Intel486, Celeron, Intel Centrino, Intel Xeon, Intel XScale, Itanium, Pentium, Pentium II Xeon, Pentium III Xeon, Pentium M, and VTune are trademarks or registered trademarks of Intel Corporation or its subsidiaries in the United States and other countries.<p>
Other names and brands may be claimed as the property of others.<p>
Copyright (c) 2002-2010, Intel Corporation. All Rights Reserved. <hr size="1"><address style="align: right;"><small>Generated on Fri Oct 22 02:28:19 2010 for XED2 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.6 </small></address>
</body>
</html>
