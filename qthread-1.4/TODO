These are ideas for things to add (in no particular order):

 1. Change the futurelib spawner to use up existing concurrency limits before
   blocking

 2. Add a qthread_replace(me, func, arg, argsize) function to enable convenient
   tail-recursion algorithms

 3. Add a qthread_forker(func, ret, ...) that accepts multiple arguments. How
   painful would this be?

 4. Multithreaded shepherds

 5. Directed rescheduling, where I specify that I want to prioritize a given
   thread's return value. The easy thing to do is to use a special type of fork
   that creates a "special" return value (i.e. stored in a hash) so that I
   don't have to save EVERY thread for lookup. However, that approach has
   unexpected consequences when a prioritized thread is blocking on an
   unprioritizeable thread...

 6. Make futurelib limits dynamic

 7. Rework qpool strategy

 8. Port to XMT (is this even possible???)

 9. Rework futures to use preallocated contexts

10. Rework futures to use small structs for queueing new futures

11. Rework most qutil/qloop functions to deal with deactivated shepherds

Things to think about:

 1. Thread-specific data (perhaps shepherd-specific data?)

 2. Non-executing shepherds to allow for memory locales without associated
 	computing resources.

 3. Hierarchical shepherds
