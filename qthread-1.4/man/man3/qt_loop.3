.TH qt_loop 3 "JUNE 2007" libqthread "libqthread"
.SH NAME
.B qt_loop
\- a simple implementation of a threaded loop
.SH SYNOPSIS
.B #include <qthread/qloop.h>

.I void
.br
.B qt_loop
.RI "(const size_t " start ", const size_t " stop ", const size_t " stride ,
.ti +9
.RI "const qt_loop_f " func ", void *" argptr );
.SH DESCRIPTION
This function provides a simple C implementation of a threaded loop. This is
similar to
.BR mt_loop ,
but does not provide much of the convenience and isomorphism that a C++
implementation can provide. On the other hand, it is more portable, and more
predictable.
.PP
This function can be thought of as akin to the following code:
.RS
.PP
unsigned int i;
.br
for (i =
.IR start ;
i <
.IR stop ;
i +=
.IR stride )
{
.RS
.br
.IR func "(NULL, i, i+1, " argptr );
.RE
.br
}
.RE
.PP
A qthread is spawned for every iteration of the above loop. Thus, if start is
50, stop is 100, and stride is 1, there will be 50 qthreads. But, if start is
50, stop is 100, and stride is 2, there will be 25 qthreads.
.PP
The
.I func
argument must be a function pointer with a
.I qt_loop_f
prototype, such as:
.RS
.PP
aligned_t
.I func
(qthread_t *me, size_t start, size_t stop, void *arg);
.RE
.PP
The return value of this function is ignored. However,
.BR qt_loop ()
will not return until all of the qthreads it spawns have returned.
.SH SEE ALSO
.BR qt_loop_future (3),
.BR qt_loop_balance (3),
.BR qt_loop_balance_future (3),
.BR qt_loopaccum_balance (3),
.BR qt_loopaccum_balance_future (3)
