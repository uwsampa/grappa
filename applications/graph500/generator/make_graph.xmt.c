********************************************************************************
*   Cray  Compilation Report
*   Source File:     generator/make_graph.c
*   Program Library: xmt-csr/xmt-csr.pl
*   Module:          make_graph.o
********************************************************************************
        | /* Copyright (C) 2009-2010 The Trustees of Indiana University.             */
        | /*                                                                         */
        | /* Use, modification and distribution is subject to the Boost Software     */
        | /* License, Version 1.0. (See accompanying file LICENSE_1_0.txt or copy at */
        | /* http://www.boost.org/LICENSE_1_0.txt)                                   */
        | /*                                                                         */
        | /*  Authors: Jeremiah Willcock                                             */
        | /*           Andrew Lumsdaine                                              */
        | 
        | #include <stdlib.h>
        | #include <stdint.h>
        | #include <stdio.h>
        | #include <string.h>
        | #include <assert.h>
        | #include <math.h>
        | #ifdef __MTA__
        | #include <sys/mta_task.h>
        | #endif
        | #ifdef GRAPH_GENERATOR_MPI
        | #include <mpi.h>
        | #endif
        | #ifdef GRAPH_GENERATOR_OMP
        | #include <omp.h>
        | #endif
        | 
        | /* Simplified interface to build graphs with scrambled vertices. */
        | 
        | #include "graph_generator.h"
        | #include "utils.h"
        | 
        | #ifdef GRAPH_GENERATOR_MPI
        | static void compute_edge_range(int rank, int size, int64_t M, int64_t* start_idx, int64_t* end_idx) {
        |         int64_t rankc = (int64_t)(rank);
        |         int64_t sizec = (int64_t)(size);
        |         *start_idx = rankc * (M / sizec) + (rankc < (M % sizec) ? rankc : (M % sizec));
        |         *end_idx = (rankc + 1) * (M / sizec) + (rankc + 1 < (M % sizec) ? rankc + 1 : (M % sizec));
        | }
        | #endif
        | 
        | #ifndef GRAPH_GENERATOR_MPI
        | void make_graph(int log_numverts, int64_t M, uint64_t userseed1, uint64_t userseed2, int64_t* nedges_ptr_in, packed_edge** result_ptr_in) {
** multiprocessor parallelization enabled (-par)
** expected to be called in a serial context
** fused mul-add allowed
** debug level: off
        |         /* Add restrict to input pointers. */
        |         int64_t* restrict nedges_ptr = nedges_ptr_in;
        |         packed_edge* restrict* restrict result_ptr = result_ptr_in;
        |         
        |         /* Spread the two 64-bit numbers into five nonzero values in the correct
        |          * range. */
        |         uint_fast32_t seed[5];
        |         make_mrg_seed(userseed1, userseed2, seed);
++ function make_mrg_seed inlined
        |         
        |         *nedges_ptr = M;
        |         packed_edge* edges = (packed_edge*)xmalloc(M * sizeof(packed_edge));
++ function xmalloc inlined
        |         *result_ptr = edges;
        |         
        |         /* In OpenMP and XMT versions, the inner loop in generate_kronecker_range is
        |          * parallel.  */
        |         generate_kronecker_range(seed, log_numverts, 0, M, edges);
        | }
        | #endif /* !GRAPH_GENERATOR_MPI */
        | 
        | #ifdef GRAPH_GENERATOR_MPI
        | void make_graph(int log_numverts, int64_t M, uint64_t userseed1, uint64_t userseed2, int64_t* nedges_ptr, packed_edge** result_ptr) {
        |         int rank, size;
        |         
        |         /* Spread the two 64-bit numbers into five nonzero values in the correct
        |          * range. */
        |         uint_fast32_t seed[5];
        |         make_mrg_seed(userseed1, userseed2, seed);
        |         
        |         MPI_Comm_rank(MPI_COMM_WORLD, &rank);
        |         MPI_Comm_size(MPI_COMM_WORLD, &size);
        |         
        |         int64_t start_idx, end_idx;
        |         compute_edge_range(rank, size, M, &start_idx, &end_idx);
        |         int64_t nedges = end_idx - start_idx;
        |         
        |         packed_edge* local_edges = (packed_edge*)xmalloc(nedges * sizeof(packed_edge));
        |         
        |         double start = MPI_Wtime();
        |         generate_kronecker_range(seed, log_numverts, start_idx, end_idx, local_edges);
        |         double gen_time = MPI_Wtime() - start;
        |         
        |         *result_ptr = local_edges;
        |         *nedges_ptr = nedges;
        |         
        |         if (rank == 0) {
        |                 fprintf(stdout, "graph_generation:               %f s\n", gen_time);
        |         }
        | }
        | #endif
        | 
        | /* PRNG interface for implementations; takes seed in same format as given by
        |  * users, and creates a vector of doubles in a reproducible (and
        |  * random-access) way. */
        | void make_random_numbers(
        |                                                  /* in */ int64_t nvalues    /* Number of values to generate */,
        |                                                  /* in */ uint64_t userseed1 /* Arbitrary 64-bit seed value */,
        |                                                  /* in */ uint64_t userseed2 /* Arbitrary 64-bit seed value */,
        |                                                  /* in */ int64_t position   /* Start index in random number stream */,
        |                                                  /* out */ double* result    /* Returned array of values */
        |                                                  ) {
** multiprocessor parallelization enabled (-par)
** expected to be called in a serial context
** fused mul-add allowed
** debug level: off
        |         int64_t i;
        |         uint_fast32_t seed[5];
        |         make_mrg_seed(userseed1, userseed2, seed);
++ function make_mrg_seed inlined
        |         
        |         mrg_state st;
        |         mrg_seed(&st, seed);
++ function mrg_seed inlined
        |         
        |         mrg_skip(&st, 2, 0, 2 * position); /* Each double takes two PRNG outputs */
        |         
        |         for (i = 0; i < nvalues; ++i) {
    1 S |                 result[i] = mrg_get_double_orig(&st);
** function with unknown side effects: mrg_get_double_orig
        |         }
        | }


********************************************************************************
*   Additional Loop Details
********************************************************************************

Loop   1 in make_random_numbers at line 111
       Loop not pipelined: not structurally ok
       Scheduled to minimize serial time
       Loop summary: 6 instructions, 0 floating point operations
		0 loads, 1 stores, 0 reloads, 0 spills, 1 branches, 1 calls
